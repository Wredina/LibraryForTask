# Руководство по Python
## НАЧАЛО РАБОТЫ
1. Сначала скачиваем с сайта https://www.python.org/downloads/ 
2. в VS установить разрешение Python от микрософта
___
## РАБОТА В КОНСОЛИ
что бы запустить программу:
- python название_файла.py (у меня не сработало)
- в верхней панели, справа, кнопка run

> что бы запустить в консоли программу, когда нажала run, выскочило сообщение об установке компилятора, нажала ок и когда нажимала стрелку вверх (вызов предыдущей команды) - выводился путь компилятора & путь к нужному файлу. Оно используется как команда запуска.
___

## ЗАКОММЕНТИРОВАТЬ
\# - однострочный комментарий

""" текст """ - многострочный

ctrl+k + ctrl+c - комментирует выделенную область

ctrl+k + ctrl+u - расскомментировать выделенную область

ctrl + / - спокойно закомментирует всё однострочными комментариями
___

## ТИПЫ ДАННЫХ
int - целочисленный

float -  дробные числа

bool - логический тип

str - строка

/ - деление (вещественных числах)

// - целочисленное деление

> он имеет динамическую типизацию, как JS, т.е. в переменную можно вложить любой тип.

что бы создать переменную:

название переменной = значение переменной
```Python
n = 1.89
n = "привет"
n = None
```
точка с запятой не ставится.

если попытаться вывести сложение чисел тким образом как

``` python
print(a + b)
```
будет конкатенация строк (только при знаке +)

что бы этого небыло:

метод 1:
```python
a = int(5)
b = float(5,86)
print(a + b)
```
метод 2:
```python
print(int(a) + float(b))
```

- Множественное присваивание
	```py
	a, b = 1, 2
	print(a, b)
	```
	> выведет: 1 2
___
## МЕТОДЫ
* что бы вывести в консоль:
	```python
	print(переменная)
	```
	```python
	print (f"{переменная1} - {переменная2} и ещё {переменная3}")
	```
	```python
	print("{} - {} - {}".format(переменная1,переменная2,переменная3))
	```

* показать тип переменной:
	```python
	n = 5
	print(type(n))
	```
	> выведет <class 'int'>
* параметры print(): sep - separator/разделитель, end - окончание
	> sep заменяет стандартный разделитель пробела на другой элемент
	```python
	print('a', 'b', 'c', sep='*')
	```
	>выведет: a\*b\*c

	>end - заменяет перенос строки на другой элемент

	```python
	print('a', 'b', 'c', end='@')
	print('d', 'e', 'f', end='@@')
	```
	>выведет: a b c@d e f@@
	
	Если нужно более одного переноса строки
	```python
	print('Python', end='\n\n\n')
	```

* ввод с клавиатуры:

	input("текст: ") - открывается ввод данных через консоль

	len(переменная) - выводит длину элемента

	list(переменная) - выводит индексы элемента
___

## МОДУЛИ
### Создаваемый модуль
Что бы подключать какие либо функции модуля, нужно подключать сам модуль
	
- import имя_модуля - подключает модуль
- import имя_модуля from функция - подключает выбранную функцию из модуля
- import имя_ модуля from * - подключает все функции из модуля

Например, создадим файл mpdul_1.py и напишем в нём код
	```py
	def max1(a,b):
		if a > b:
			return a
		return b
	```

### Методы обращения к модулю и его содержимому:

- Импорт всего модуля со всем содержимым внутри
	- import - импортирует функции из нашего файла, либо подключает встроенную библиотеку

	Создадим файл main.py и подключим к нему файл modul_1
	```py
	import modul_1
	```
	
	Что бы обратиться к этой функции, нужно обратиться к модулю и вызвать от туда нашу функцию. Можно передать ещё туда аргументы
	```py
	print(modul_1.max1(5,9))
	```
	> выведет: 9
- Обращение только к нужной функции из модуля
	Создадим файл main.py и уже обратимся к самой функции из файла modul_1
	```py
	from modul_1 import max1
	```
	\*переводится как: из modul_1 ипортировать max1
	
	И теперь можно напрямую обратиться к этой функции и вложить туда аргументы
	```py
	print(max1(5,9))
	```
	> выведет: 9

- Можно обратиться ко всем функциям в данном модуле
	```py
	from modul_1 import *

	print(max1(5,9))
	```
	> выведет: 9

- as - изменение названия импортируемого модуля при работе с ним
	```py
	import modul_1 as m1

	print(m1.max1(5,9))
	```
	> выведет: 9



### МАТЕМАТИЧЕСКИЕ МОДУЛИ 
round(n,2) - округление числа до 2-х символов после запятой

## Команды для подключения модульных библиотек
- подключение рандома целых чисел
	```py
	from random import randint
	```
	пример работы:
	```py
	a = randint(1,10)
	```
	>выдаст рандомное число от 1 до 10 включительно.

## Модуль os
Модуль os представляет множество функций для работы с оперативной системой, причём их поведение, как правило, не зависит от ОС, поэтому программы остаются переносимыми.

Для того, что бы начать работать с данным модулем, необходимо его импортировать в свою программу:

import os

Базовые функции модуля:
- os.chdir(path) - смена текщей директории.
``` py
import os

os.chdir('c:/users/7909/...')
```
- os.getcwd() - текущая рабочая директория
``` py
import os

print(os.getcwd())
```
> выведет : 'c:/users/7909/...'

- os.path - вложенный модуль в модуль os и реализует некоторые полезные функции для работы с путями, такие как:
	- os.path.basename(path) - базовое имя пути
	``` py
	import os

	print(os.path.basename(c:/users/7909/...main.py))
	```
	> выведет : main.py
	- os.path.abspath(path) - возвращает нормализованный абсолютный путь.
	``` py
	import os

	print(os.path.abspath('main.py'))
	```
	> выведет : "c:/users/7909/...main.py"

## Модуль shutil
Содержит набор функций высокого уровня для обработки файлов, групп файлов и папок. Часто ипользуется с модулем os

тоже импортируется

import shutil

- базовые функции:
 - shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.
 - shutil.copy(src,dst) - копирует содержимое файла src в файл или папку dst.
 - shutil.rmtree(path) - удаляет текущую директорию и все поддиректории; path должен указывать на директорию, а не на символическую ссылку.
___

## Условия и циклы

**1. условие в Питоне**
```python
if условие:
	действие
else:
	действие
```
```python
if условие:
	действие
elif условие:
	действие
else
	действие
```
```python
while условие:
	действие
```
```python
while условие:
	действие
else
	действие
```
> Блок else выполнится, когда основное тело цикла перестанет работать самостоятельно. Т.к. если в цикле будет break - принудительно останавливающий цикл, то else не сработает. Поэтому часто используют метод флажка.
---
**2. Метод флажка**

```py
n = int(input())
flag = True
i = 2
while flag:
	if n % i == 0:
		flag = False
		print(i)
	elif i > n // 2:
		print(n)
		flag = False
	i += 1
```
>Цикл выполняется пока flag = True

**3. Цикл for**

Используется как для чисел, так и для строк.

```py
for i in значение:
	действие
```
```py
for i in 1,2,3,14,-5:
	print(i)
```
> выведет в столбик: 1,2,3,14,-5
```py
a = 'qwerty'
print(a[0]) #выведет q

for i in a:
	print(i)
```
> выведет в столбик: q,w,e,r,t,y 

* начать нумерацию с 10

	```py
	word = "pyton"
	for i, elem in enumerate(word, 10):
		print(i, end=" - ")
		print(elem)
	```
	> выведет в столбик: 

	>10 - p

	>11 - y

	>12 - t

	> и т.д....

	i - вмещает в себя индекс элемента и выводит сам элемент

4. Метод range()

Максимально часто используется с циклом for

* range(n) - если указано одно число, выведе все значения от 0 до n (не включающая n)

	r = range(5)
	>выведет: 0,1,2,3,4

* range(n,m) - выдаёт значения из диапазона с шагом +1 (по умолчанию)

	r = range(2,5)
	>выведет: 2,3,4

* range(n,m,q) - где q меняет длину шага

	r = range(1,10,2)
	>выведет: 1,3,5,7,9

* т.к. по умолчанию шаг идёт в + (от меньшего к большему) то если ввести второе значение меньше первого - ничего не выведется

	r = range(0,-5)
	>выведет: ---

* Но мы можем двигаться в сторону уменьшения, если вручную поставим шаг в отрицательную сторону

	r = range(100,0,-20)
	>выведет: 100, 80, 60, 40, 20

* Если нам понадобится узнать длину элемента или слова через метод len()

	```py
	word = 'Python'
	len_word = range(len(word))
	print(len_word)
	```
	> выведет: range (0,6)

	т.е. длина от 0 до 6-ти.

* Можем обратиться к индексам элемента через метод list()

	```py
	word = 'Python'
	len_word = range(len(word))
	print (list(len_word))
	```
	> выведет: [0,1,2,3,4,5]


**демонстративный код**
```py
r = range(100,0,-20)
for i in r:
	print (i)
```
>выведет: 100, 80, 60, 40, 20
```py
line = ''
for i in range(3):
    line = ''
    for j in range(5):
        line += '*'
    print(line)
```
>выведет: 

		*****
		*****
		*****
## Работа со строками
Возьмём за основу текст:
```py
text = "СъЕШЬ ещё этих МяГкИх французских булок"
```
* узнать размер строки (или любой другой коллекции)
	```py
	print(len(text))
	```
	>выведет: 39

* узнать, существует ли какая-то строка (или найти символ) в тексте
	```py
	print ("ещё" in text)
	```
	>выведет: True

* перевести все буквы в нижний регистр
	```py
	print (text.lower())
	```
* перевести все буквы в верхний регистр
	```py
	print (text.upper())
	```
* изменить часть текста на другой
	```py
	print (text.replace("ещё", "ЕЩЁ"))
	```
* удалить все пробелы и знаки переноса
	```py
	text.split()
	```
*  вставить межстрочный интервал
	```py
	list_1 = ['text_1','text_2','text_3']
	', '.join(list_1) 
	```
	>выведет: text_1, text_2, text_3

**ИНДЕКСАЦИЯ В СТРОКАХ**

Отрицательное число в индексте ведёт к последнему элементу.

					0  1  2  3  4  5
					q  w  e  r  t  y
				   -6 -5 -4 -3 -2 -1

> [ : ] - выводит все элементы

>[n : ] - вывод ОТ n эл до конца.

>[ : n] - выводит от 0 ДО n эл

> [x : y] - диапазон от x до y (не включая y)

>[x : y : n] - диапазон от x до y (не включая y) с интервалом в n элементов

* обращение к первому элементу
	```py
	print(text[0]) # c
	```
* обращение к последнем элементу
	```py
	print(text[-1]) # к
	```
или обратимся к длине и возьмём последний символ
```py
print(text[len(text)-1]) # к
```
* вывести 5-й элемент с конца
	```py
	print(text[-5]) # б
	```
* вывести абсолютно все символы
	```py
	print(text[:]) # съешь ещё этих мягких французских булок
	```
* вывести первые 2 элемента
	```py
	print(text[:2]) # съ
	```
* вывести 2 последних элемента
	```py
	print(text[-2:]) # ок
	```
или взять длину строки и вытащить 2 последних эл-та
```py
print(text[len(text)-2:]) # ок
```
* вывести весть текст с 20-го эл-та
	```py
	print(text[20:]) # х французских булок
	```
* вывести текст со 2-го по 9-й элемент
	```py
	print(text[2:9]) # ешь ещё
	```
* можно так же использовать одновременно диапазон с положительными и отрицательными значениями.
	```py
	print(text[6:-18]) # ещё этих мягких
	```
	> сначала идём вправо от 0 до 6-го эл, а потом 	от 0 до -18 влево.
* задать движение от 0 до конца строки с шагом 6
	```py
	print(text[::6]) # сеикакл
	```
или можем взять от 0, до длины текста и поставить шаг 6
	```py
	print(text[0:len(text):6]) # сеикакл
	```
* сложить элементы с 2-го по 9-й с элементом на позиции -5 и с элементами от 0 до 2-х
	```py
	text = text[2:9] + text[-5] + text[:2] # ешь ещёбсь
	``` 

___

## логические операции:
!= - не равно

not - отрицание

and (&) - логическое И

or - логическое ИЛИ

___

## коллекции
### Списки (list)

- list_1 = [] - создание пустого списка

* list_2 = list() - создание пустого списка при помощи функции list()

* list_1 = [1,2,3] - создание списка с тремя элементами
	> выведет: [1,2,3]

если мы не хотим, что бы выводились квадратные скобочки, запятые и другие межстрочные эл, нужно поставить *
	```py
	list_1 = [1,2,3]
	print(*list_1)
	```
	> выведет: 1 2 3

- list_1.append(4) - добавить элемент в конец списка
	>выведет: [1,2,3,4]

- .pop() - удаление последнего списка эл-та
	```py
	list_1 = [1,2,3]
	print(list_1.pop())
	```
	>выведет: [1,2]

- .pop(0) - удаление определённого элемента из списка
	```py
	list_1 = [1,2,3]
	print(list_1.pop(1))
	```
	>выведет: [1,3]

\* удаляемый элемент можно сохранить записав его в переменную

```py
list_1 = [1,2,3]
a = list_1.pop(1)
print(a)
```
>выведет: 2

- .insert(0,n) - добавление элемента n на позицию 0
	```py
	list_1 = [1,2,3]
	print(list_1.insert(2,4))
	```
	>выведет: [1,2,4,3]

### List Comprehension (генератор списка)
Создание списка через цикл for или for + if-else
- простой список с использованием for:
	```py
	list_1 = [exp for item in iterable]
	```
	exp - значение, которое вкладывается

	iterable - кол-во итераций

	например, задача: Создать список из чётных чисел от 1 до 100
	```py
	list_1 = [i for i in range(1,101)]
	```
	> выведет: [1,2,3,...,100]

	или задача: вывести список состоящий из 5-ти NaN
	```py
	list_1 = [NaN for i in range(5)]
	```
	>выведет: [NaN,NaN,NaN,NaN,NaN]

	- генерация списка с использованием for + if-else
	```py
	list_1 = [exp for item in iterable (if conditional)]
	```
	Задача: вывести только чётные числа от 1 до 100
	```py
	list_1 = [i for i in range(1,101) if i % 2 == 0]
	```
	> выведет: [2,4,6,8....100]

	- можно создавать кортежи
	```py
	list_1 = [(i,i) for i in range(1,101) if i % 2 == 0]
	```
	>выведет: [(2,2),(4,4),(6,6),...,(100,100)]

- можно использовать математические методы
	```py
	list_1 = [i * 2 for i in range(10) if i % 2 == 0]
	```
	>выведет: [0,4,8,12,16]
### Кортеж (tuple)

Кортеж - это неизменяемый список.

Используются для защиты от намеренных или случайных изменений данных.

Занимают меньше места в памяти, быстрее работают.

- t = () -  создание пустого кортежа
```py
t = ()
print(type(t))
```
> выведет: class <'tuple'>

- t = (1,) - вкладывание в кортеж элементов (если просто ввести 1 и вывести класс t - то выведется класс input, т.е. число. Поэтому после 1 ставится запятая)
	```py
	t = (1,2,3,)
	print(type(t))
	```
	> выведет: class <'tuple'>

- tuple(переменная) - преобразование списка в кортеж
	```py
	v = [1,2,3]
	v = tuple(v)
	print(v)
	```
	> выведет: (1,2,3)

- распаковка кортежа (множественное присваивание)
	```py
	t = (1,2,3,)
	a,b,c = v
	print(a,b,c)
	```
	> выведет: 1 2 3

### Словари (dict)

Это неупорядоченные коллекции произвольных объектов с доступом по ключу (в списках это индекс, а в словарях мы можем сами задавать этот ключ)

 - d = {} - создание пустого словаря
 - d = dict() - так же создание пустого словаря

 - добавление в словарь элемента
	```py
	d['q'] = 'qwerty'
	print(d)
	```
	> выведет: {'q': 'qwerty'}

	\* нам показывает, что есть ключ 'q' обратившись к которому мы получим значение 'qwerty'

 - что бы вывести элемент из списка
	```py
	d['q'] = 'qwerty'
	print(d['q'])
	```
	> выведет: qwerty

- del - удаление элемента из списка
	```py
	dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
	del dictionary['left']
	print(dictionary)
	```
	> выведет: {'up': '↑', 'down': '↓', 'right': '→'}

### демонстрауия работы цикла for со словарём
```py
dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
del dictionary['left']
for item in dictionary:
	print(item)
```
> выведет только ключи: up down right
```py
dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
del dictionary['left']
for item in dictionary:
	print('{}: {}'.format(item, dictionary[item]))
```
> выведет построчно: up: ↑ down: ↓ right: →
```py
dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
del dictionary['left']
for (k,v) in dictionary.items():
	print(k,v)
```
> выведет построчно: up: ↑ down: ↓ right: →

### Множества (set)
Содержат в себе любые уникальные элементы, т.е. они не могут повторяться. Они могут быть не обязательно упорядоченные.

 - q = set() - создание множества

- .add(значение) - добавление элемента (в рандомное место)

	```py
	colors = {'red','green','blue'}
	colors.add('gray')
	print(colors)
	```
	> выведет: {'red', 'green', 'blue',  'gray'} 

- .remove(значение) - удаление элемента

	```py
	colors = {'red', 'green', 'blue',  'gray'}
	colors.remove('red')
	print(colors)
	```
	> выведет: {'green', 'blue',  'gray'} 

- .discard(значение) - если элемент во множестве есть - удалит его, если нет - ничего не сделает.

	```py
	colors = {'green', 'blue', 'gray'}
	colors.discard('red')
	print(colors)
	```
	> выведет: {'green', 'blue', 'gray'}

- .clear() - удалит все элементы из множества

	```py
	colors = {'green', 'blue', 'gray'}
	colors.clear()
	print(colors)
	```
	>выведет: set()

- .copy() - скопировать множество
	```py
	colors = {'green', 'blue', 'gray'}
	c = colors.copy()
	print(c)
	```
	> выведет: {'green', 'blue', 'gray'}

- множество1.union(множество2) - объеденить множество1 с множеством2
	```py
	a = {1,2,3,7,8}
	b = {3,4,5,6,7,8}
	u = a.union(b)
	print(u)
	```
	>выведет:{1,2,3,4,5,6,7,8}

- множество1.intersection(множество2) - найти пересечения множества1 с множеством2
	```py
	a = {1,2,3,7,8}
	b = {3,4,5,6,7,8}
	i = a.intersection(b)
	print(i)
	```
	>выведет: {3,7,8}

- множество1.difference(множество2) - найти разность множеств (из множества1 убираются значения схожие со множеством2)

	```py
	a = {1,2,3,7,8}
	b = {3,4,5,6,7,8}
	d1 = a.difference(b)
	print(d1)
	```
	>выведет:{1,2}
	```py
	a = {1,2,3,7,8}
	b = {3,4,5,6,7,8}
	d2 = b.difference(a)
	print(d2)
	```
	>выведет:{4,5,6}

### Демонстрация кода
```py
a = {1,2,3,7,8}
b = {3,4,5,6,7,8}
q = a.union(b).difference(a.intersection(b))
print(q)
```
> сначала выполнится действие в скобках a.intersection(b) - найти пересечения a и b = {3,7,8}

> делее действия идут по порядку: a.union(b) - a объединяем с b = {1,2,3,4,5,6,7,8}

>затем из полученного множества находим .difference (разность) с тем, что получилось в скобках, т.е.
{1,2,3,4,5,6,7,8} - {3,7,8} = {1,2,4,5,6}

- frozenset(множество) - (замороженное множество) множество которое нельзя изменять.

	```py
	a = {1,2,3}
	b = frozenset(a)
	print(b)
	```
	> выведет: frozenset({1,2,3})
___

## Функции

- Создание функции

	> def имя_функции(аргумент):

- Создание функции с неограниченным кол-вом аргументов

	> def имя_функции(*аргумент):
	\* этот аргумент можно перебрать через if

- имя функции можно сохранить в переменную и использовать её, например:
	```py
	def f(x):
		return x*x

	a = f
	print(a(5))
	```
	> выведет: 25

- использование имя функции как аргумент:

	- пока будем передавать одно число

	```py
	def calk1(a):
		return a + a

	def calk2(a,b):
		return a*a

	def math(op, x):
		print(op(x))

	math(calk2, 5)
	```
	> 1. создаём функцию math, в которую в качестве аргументов передадим op (это будет некоторая функция) и x (это само число с которым будем работать). 
<br/>
<br/>
	> 2. деалее вызываем функцию math и вкладываем в аргументы имя функции, которую собираемся использовать, и число, с которым будет вестись работа. 
	<br/>
<br/>
	> 3. в теле функции импользуем аргумент, в который вложили передаваему функцию и в него, в качестве аргумента вкладываем число (второй аргумент функции math)
	<br/>
<br/>
	> 4. т.к. вложили функцию calk2 - то выведет 25
	  
	<br/>
	<br/>

	- передаём два числа  
	<br/>
	
	```py
	def calk1(a, b):
		return a + a

	def calk2(a, b):
		return a*a

	def math(op, x, y):
		print(op(x, y))

	math(calk2, 5, 5)
	```
	> выведет: 25

- Lambda функции (как стрелочные в js)
	- помогает сократить код, например:
	``` py
	def calk1(a, b):
		return a + a
	```
	сокращаем в это:
	``` py
	calk1 = lambda a,b: a + b 
	```
	> 1. lambda указывает на аргументы функции. 
	<br>
	<br>
	> 2. если в теле функции простая конструкция, то return не требуется, он возвращается автоматически


	<br>

	- можно использовать lambda как аргумент:
	``` py
	def math(op, x, y):
		print(op(x, y))

	math(lambda a,b: a + b, 5, 5)
	```

### Демостративный код:

- Задача:
	В списке хранятся числа. Нужно выбрать только чётные числа и составить список пар (число; квадрат числа)

	- пример: 1 2 3 5 8 15 23 38
	- получить: [(2,4), (8,6), (38,1444)]
	> обычное решение
	``` py
	data = [1, 2, 3, 5, 8, 15, 23, 38]
	res = list()

	for i in data:
		if i % 2 == 0:
			res.append((i, i**2))
	print res
	```
	> выведет: [(2,4), (8,6), (38,1444)]

	</br>
	</br>

	> решение с использованием lambda функции

	``` py
	def select(f, col):
		return [f(x) for x in col]

	def where(f, col):
		return = [x for x in col if f(x)]

	data = [1, 2, 3, 5, 8, 15, 23, 38]
	res = select(int, data) # приводим к целочисленному виду
	print(res) # выведет [1, 2, 3, 5, 8, 15, 23, 38]
	res = where(lambda x: x % 2 == 0, res) # через лямбда функцию ставим условие
	print(res) # выведет [2,8,38]
	res = list(select(lambda x: (x, x**2), res)) # возведение в квадрат и создание списка
	print(res) # [(2,4), (8,6), (38,1444)]
	```
	> 1. сначала был обычный список
	> 2. выбрали нечётные значения
	> 3. возвели в квадрат

	</br>
	</br>
	</br>

	

- map( , ) - создаёт новый список из уже имеющегося списка применяя к нему функции.
	
	- принимает на вход два аргумента:
		- функция
		- объект (сам список)
	- функция - будет применяться ко всем элементам объекта
	``` py
	list_1 = [x for x in range(1,20)]
	print(list_1) # выведет список от 1 до 20-ти

	list_1 = list(map(lambda x: x+10, list_1)) # к каждому эл-ту списка прибавили 10
	print(list_1) # выведет от 11 до 29
	```
	</br>

	-  Задача: с клавиатуры вводится некий набор чисел, в качестве разделителя используется пробел. Этот набор чисел будет считан в качестве строки. Как превратить list строк в list чисел?

	</br>

	> \*напоминалка: .split( ' ' ) - преобразует строку в список

	``` py
	data = '15,156,69,345,23,43,3,8'
	print(data)

	data = list(map(int, data.split()))
	print(data)
	```

- filter - фильтрует значения из списка
	- принимает 2 аргумента:
		- функцию
		- объект
	- функция фильтра возвращает только те значения, которые True

	</br>

	> например напишем програму, которая выведет все числа с цифрой 5

	```py
	data = [15, 23, 34, 65, 25]
	res = list(filter(lambda x: x % 10 == 5, data))
	print(res)
	```

	</br>

- zip() - применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов входных данных

``` py
zip ([1,2,3], ['о','д','т'], ['f','s','t'])
```
> выведет: [(1,'o','f'), (2, 'д','s'),(3,'т','t')]

</br>

```py
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
data = list(zip(users, ids))
print(data)
```
> выведет: [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14),
('user5', 7)]

</br>

\* zip() проходит по минимальному набору входящих данных.
``` py
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]
data = list(zip(users, ids, salary))
print(data) 
```
> выведет : [('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)]

</br>

- enumerate() - позволяет пронумеровать набор данных. Применяется к итерируемому объекту и возвращает новый итератор с кортежами из индекса и элементов входных данных
``` py
enumerate(['Казань','Смоленск','Рыбки','Чикаго'])
```
> выведет: [(0,'Казань'),(1,'Смоленск'),(2,'Рыбки'),(3,'Чикаго')]

</br>

``` py
users = ['user1', 'user2', 'user3']
data = list(enumerate(users))
print(data)
```
> выведет : [(0, 'user1'), (1, 'user2'), (2, 'user3)]


## Файлы
- файл в текстовом формате используют для:
	- Хранения данных
	- передачи данных в клиент-мерверных проектах
	- хранения конфигов
	- логирования действий

- для работы с файлами нужно:
	- завести переменную, которая будет связанны с этим текстовым файлом.
	- указать путь к файлу
	- указать, в каком режиме мы будем работать с файлом.
	
</br>

- режимы работы с файлами (мод):

	а - (append) - открытие для добавления данных.
	- позволяет добавлять данные в файл
	-если файла не существует, то он создаться и туда начнётся запись

	r - (read) - открытие для чтения данных
	- позволяет читать данные из файла
	- если файла нет, то программа выдаст ошибку

	w - открытие для записи или перезаписи
	- при каждом открытии будет перезапись данных, которые там уже есть
	- если файла не существует - создаст

	w+ - перезапись + чтение
	- позволяет открыть файл для записи(перезаписывания) и читать из него
	- если файла не существует - создаст

	r+ - запись + чтение
	- Позволяет открывать файл для чтения и читать из него
	- если файла не существует - будет ошибка
	
	</br>

	переменная = open('название_файла_с_расширением', 'режим_работы') - открытия файла для работы с ним и запись его в переменную.

	переменная.close() - окончание работы с файлом и его закрытие

``` py
colors = ['red','green','blue']
data = open('file.txt','a') # здесь указываем путь к файлу и режим, в котором будем работать
data.writelines(colors) # убираются разделители, запись данных в файл
data.close()
```
> выведет : создаст файл в нашей дериктории file.txt и запишет туда redgreenblue

если мы допишем в colors ещё какое либо значение:
``` py
colors = ['red','green', 456, 'blue']
data = open('file.txt','a')
data.writelines(colors)
data.close()
```
> выведет : redgreenbluered456blue

- with - конструкция, которая позволяет убрать close

``` py
with open('fale.txt'.'w') as data:
	data.write('line 1\n')
	data.write('line 2\n')
```
> выведет : line 1 b на следующец строке line 2 (все предыдущие данные будут стёрты)

- прочесть файл
``` py
data = open('file.txt', 'r')
for line in data: # циклом проходимся по файлу
	print(line) # и печатаем всё содержимое
data.close()
```

</br>

