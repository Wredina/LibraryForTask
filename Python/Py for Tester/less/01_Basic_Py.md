# Загрузка и установка Python

Переходим на официальный сайт Python в раздел
«Загрузки» <https://www.python.org/downloads/>

При скачивании обязательно поставить галочку на Add Python <...> to PATH (иначе могут быть проблемы при работе в интерактивном режиме и с запуском команд пайтона из консоли)

Для проверки версии python вводится команда

```
python --version
```

Для других ОС

```
python3 --version
```

## Создание виртуального окружения

Это возможность создать отдельную виртуальную копию языка пайтон, что бы создавать проект внутри этой копии.
Это если для разных проектов используются разные версии языка.

Запуск простых программ возможен непосредственно из ОС. Но когда программист
работает над большим проектом, используется виртуальное окружения. Так мы
изолируем проект от других, хранящихся на этом же ПК. Кроме того изменения
внутри проекта не влияют на "эталонную" версию Python, которую только что
установили

Для работы над каждым проектом нужно настроить виртуальное окружение.

Подготовка к созданию окружения

```
mkdir new_project - создание новой папки
cd new_project - переход в папку
```

Создание окружения

```
python -m venv venv — для Windows; - запуск модуля venv и создание папки (тоже venv) в которой будет развёрнуто виртульное окружение

python3 -m venv venv — для Linux и MacOS.

dir - что бы убедиться, что всё создано
```

Активация окружения

```
venv\Scripts\activate — для Windows;
source venv/bin/activate — для Linux и MacOS.
```

Если в начале командной строки вы видите приставку (venv), значит активация прошла успешно.

Для завершения работы внутри виртуального окружения
необходимо выполнить команду

```
deactivate - выход из окружения
```

## PIP

Package Installer for Python — система управления пакетами, которая используется
для установки и управления программными пакетами, написанными на Python.
Благодаря pip мы можем устанавливать сторонние библиотеки, фреймворки,
пакеты. Например через pip устанавливаются Django, Flask, NumPy.

**! Прежде чем устанавливать дополнения убедитесь, что вы
находитесь в каталоге проекта и активировали виртуальное окружение !**

### Команда install

Для установки используем команду install далее указываем название
устанавливаемого дополнения.
Потренируемся с установкой и добавим в проект библиотеку requests. Requests —
это простая, но элегантная библиотека для работы с HTTP

```
pip install requests
```

"Пип" скачает и установит библиотеку requests последней версии в папку venv
виртуального окружения. В основной системе и в других окружениях библиотеки не
будет.

### Команда freeze

Убедимся, что установка прошла успешно. Выполним команду

```
pip freeze
```

Мы получили список всех дополнений внутри нашего виртуального окружения.
Помимо requests были скачаны библиотеки зависимости, необходимые для работы
requests. Данный процесс автоматизирован. Зависимости указывает разработчик, а
pip рекурсивно их устанавливает

### Файл requirements.txt

Чтобы в будущем облегчить развертывание проекта на новом/боевом/тестовом
сервере, используют файл requirements.txt В него помещают перечень всех уже
установленных дополнений. Для этого используют команду

```
pip freeze > requirements.txt
```

Откроем файл и посмотрим на его содержимое

```
more requirements.txt
```

Для быстрой установки в новое окружение всего содержимого файла используется
команда

```
pip install -r requirements.txt
```

## Работа в режиме интерпритатора Python

Это режим, когда внутри консоли можно запустить Пайтон и вбить какие либо команды и Пайтон будет интерпретировать эти команды и выполнять те действия которые от него требуются.

Что бы запустить Пайтон на Винде, нужно вбить команду

```
python
```

Как только появятся стрелочки типа

```
>>>
```

мы перешли в режим интерпритации Пайтон

**! В режиме интерпритатора команды командной строки выполняться не будут !**

### Работа в режиме интерпритатора

#### Арифметические операторы

Особенностью работы в режиме интерпретатора является то, что каждая строка
кода выполняется сразу после нажатия клавиши Ввод.
Чаще всего разработчики используют этот режим в качестве калькулятора

```
"+" - Сложение 398 + 20 = 418
"-" - Вычитание 200 - 50 = 150
"*" - Умножение 34 * 7 = 238
"/" - Деление 36 / 6 = 6.0
"//" - Целочисленное деление 9 // 4 = 2
-9 // 4 = -3 целочисленное деление всегда округляет в меньшую сторону

"%" - Остаток от деления 36 % 5 = 1
"**" - Возведение в степень 2 ** 16 = 65536
```

Если нужен последний вывод, нужно воспользоваться переменной "_". Она
хранит именно финальный результат, т.е. обновляется с каждым новым выводом.

#### Написание кода в интерактивном режиме

Мы можем писать программы любой сложности, использовать переменные,
ветвления, циклы внутри оболочки. При этом наличие двоеточия позволяет писать
несколько строк кода без вывода результата. Python запоминает целый блок и
выводит ответ после нажатия клавиши Ввод дважды.

```
>>> a = 2
>>> b = 6
>>> b
6
>>> a
2
>>> while a < b:
...     print(a)
...     a += 1
...
2
3
4
5
```

После выхода мы теряем все введённые данные.
Что бы выйти из режима интерпритатора нужно использовать функцию exit() или сочетание клавиш Ctrl-Z

# Основы Python

## Python Style. PEP-8 (руководство по стилю) и PEP-257 (оформление документации/комментариев)

Одно из важнейших требований к коду **Python-разработчика** — следование
стандарту PEP-8, который представляет собой описание рекомендованного стиля
кода. Причем PEP-8 действует для основного текста программы, а для строк
документации разработчику рекомендуется придерживаться положений PEP-257.
Документ содержит достаточно объёмное описание стандарта.

## Переменные и требования к именам

В Python всё объект. Числа, строки, массивы и даже функции и классы являются
объектом. Переменная в Python является указателем на объект.
Переменная "a" хранит значение "5". Верно. Также верно, что Python создал объект
целого типа 5.  Далее была
создана переменная "a" которая является указателем на объект целого типа число
пять.

Python является языком со строгой динамической типизацией. Это означает что тип
объекта изменить невозможно он строго задаётся при создании объекта. При этом
переменные могут ссылаться на объекты разных типов. И это не вызывает ошибки

Что ещё нужно знать когда речь идёт о переменных и их именах:

- Python использует кодировку utf-8. Поэтому в качестве имени переменной
может выступать любой набор символов, даже смайлик. Однако правильные
имена это имена на латинице, т.е. английские строчные буквы, слова.
Например name, age.
- Если название переменной состоит из нескольких слов такие слова
записываются строчными буквами разделяются символом подчёркивания.
Этот стиль называется snake_case.
- В качестве первого символа в имени переменной запрещено использовать
цифры и другие знаки пунктуации в этом случае Python выдаст ошибку. Имя
начинается с буквы или символа подчёркивания.
- Не используйте написание слов на транслите. Воспользуйтесь онлайн
переводчиком на английский. Не zdorove, а health

### Константы

Дополнительных команд для создания констант в языке Python нет. Есть лишь
договорённость что константа — это переменная написанное прописными буквами

 ```py
MAX_COUNT = 1000
ZERO = 0
DATA_AFTER_DELETE = 'No data'
DAY = 60 * 60 * 24 
```

Константа в программировании — способ адресации данных, изменение которых
программой не предполагается или запрещается. Python не вызовет исключение,
если вы измените константу внутри кода. Но подобные действия со стороны
программиста являются неверными.

**True, False, None**
Отдельно хочу выделить три встроенные в язык Python константы. Это истина True,
ложь False и ничего None. Первая буква строчная остальные прописные. Истину или
ложь мы получаем в результате логических операций.
позже Значение None означает "ничего" - 'nj pfukeirf. Его можно использовать для создания
переменной, значение которой изначально мы не знаем. Также None возвращают
некоторые функции, результат работы которых не подразумевает возврат значения.

## Функция id()

id() - возвращает адрес объекта в
оперативной памяти вашего компьютера

```py
a = 5
print(id(a))
a = "hello world"
print(id(a))
a = 42.0 * 3.141592 / 2.71828
print(id(a))
```

>1615821406576
>
>1615826697776
>
>1615831485936

## Зарезервированные слова, keyword.kwlist

Существует чуть менее 40 зарезервированных слов, которые образуют базовый
синтаксис языка Python. Ниже представлены они все

```py
False, None, True, and, as, assert, async, await, break, class,
continue, def, del, elif, else, except, finally, for, from,
global, if, import, in, is, lambda, nonlocal, not, or, pass,
raise, return, try, while, with, yield
```

А также case и match начиная с версии Python 3.10.

## Ввод и Вывод данных

функции print() для вывода данных и input() для ввода данных

### Вывод, функция print()

```py
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
```

Функция print() принимает один или несколько объектов разделённых запятыми и
выводят их на печать По умолчанию это вывод в консоль, т.е. стандартный поток
вывода.

```py
print(42)
print(1, 2, 3, 4)
print('Hello', ',', 'world', '!')
```

>вывод
>
>42
>
>1 2 3 4
>
>Hello , world !

Есть так же два ключевых аргумента sep и end.

**sep** по умолчанию хранит один пробел. Именно этим символом разделяются все
объекты, перечисленные через запятую.

**end** по умолчанию хранит символ перехода на новую строку '\n'. Это то, что функция
print добавляет после вывода всех объектов.
код:

```py
print(1,2,3,4, sep='___')
```

вывод:
>1___2___3___4

код:

```py
print(42, end='^^')
```

вывод:
>42^^

код:

```py
print(42, sep='___', end='\n(=^.^=)\n')
print(1, 2, 3, 4, sep='___', end='\n(=^.^=)\n')
print('Hello', ',', 'world', '!', sep='___', end='\n(=^.^=)\n')
```

вывод:
>42
>
>(=^.^=)
>
>1___2___3___4
>
>(=^.^=)
>
>Hello___,___world\_\_\_!
>
>(=^.^=)

код:

```py
print(42, sep='___', end='(=^.^=)')
print(1, 2, 3, 4, sep='___', end='(=^.^=)')
print('Hello', ',', 'world', '!', sep='___', end='(=^.^=)')
```

вывод:
>42___(=^.^=)1___2___3___4(=^.^=)Hello___,___world\_\_\_!(=^.^=)

код:

```py
number = 42
print(number, sep='___', end='\n(=^.^=)\n')
ONE = 1
TWO = 2
print(ONE, TWO, 3, 4, sep='> <', end='>')
```

вывод:
>42
>
>(=^.^=)
>
>1> <2> <3> <4

### Ввод, функция input()

Для ввода данных и сохранение их в переменной используется функция input()

```py
result = input([prompt])
```

Если в качестве аргумента функции передать значение, оно будет выведено как
подсказка перед вводом данных. Функция возвращает объект строкового типа,
который можно сохранить в переменную.

```py
res = input('Напиши что нибудь: ')
print('Ты написал ', res)
```

>высвечивается окно ввода
>
> Напиши что нибудь: new
>
>вывод:
>
>Ты написал new

Для приведения строки к числу используем функции int() — целый тип или float() —
вещественный тип, число с плавающей запятой

```py
age = int(input('Ваш возраст: '))
how_old = age - 18
print(how_old, "лет назад ты стал совершеннолетним")
```
>
>Ваш возраст: 33
>
>15 лет назад ты стал совершеннолетним

### Антипаттерн "магические числа"

В прошлом примере мы использовали антипаттерн — плохой стиль для написания
кода. Число 18 используется в коде коде без пояснений. Такой антипаттерн
называется "магическое число". Рекомендуется помещать числа в константы,
которые храняться в начале файла

```py
ADULT = 18
age = float(input('Ваш возраст: '))
how_old = age - ADULT
print(how_old, "лет назад ты стал совершеннолетним")
```

Плюсом такого подхода является возможность легко корректировать большие
проекты. Представьте, что в вашем коде несколько тысяч строк, а число 18
использовалось несколько десятков раз

- При развертывании проекта в стране, где совершеннолетием считается 21
год вы будете перечитывать весь код в поисках магических "18" и править их
на "21". В случае с константой изменить число нужно в одном месте.
- Дополнительный сложности могут возникнуть, если в коде будет 18 как
возраст совершеннолетия и 18 как коэффициент для рассчёт чего-либо.
Теперь править кода ещё сложнее, ведь возраст изменился, а коэффициент
-нет. В случае с сохранением значений в константы мы снова меняем число в
одном месте.

# Ветвление

Ветвление в программировании — операция, применяющаяся в случаях, когда
выполнение или невыполнение некоторого набора команд должно зависеть от
выполнения или невыполнения некоторого условия.

Ветвление — одна из трёх
базовых конструкций структурного программирования.
"Некоторое условие" должно возвращать истину True или ложь False. В Python есть
возможность использовать неявное преобразование типов. Так любое целое число
помимо нуля считается истиной, а ноль — ложью. Любая коллекция с данными —
истина, а пустая коллекция — ложь.

Зарезервированные слова:

if - Если

else - иначе

elif - ещё если

mach и case - выбор из вариантов

В Python доступны все 6 операций сравнения:

«==» — равно

«>» — больше

«<» — меньше

«!=» — не равно

«<=» — меньше или равно

«>=» — больше или равно

**Отступы вместо фигурных скобок**
отступ в четыре пробела в следующей после if строке кода. По ним пайтон ориентируется в программе

## Если, if

Простейшая проверка условия происходит при помощи зарезервированного слова
if

```py
pwd = 'text'
res = input('Input password: ')
if res == pwd:
print('Доступ разрешён')
```

В строке 3 мы используем if, далее пишем выражение, которое должно вернуть
истину или ложь и завершаем строку двоеточием.

```py
pwd = 'text'
res = input('Input password: ')
if res == pwd:
    print('Доступ разрешён')
    print('Но будьте осторожны')
print('Работа завершена')
```

Строки 4-5 написаны с отступом и будут выполнены в случае истинности в строке 3.
Строка 6 будет выполнена в любом случае, т.к. написана без отступов.

**!PEP-8! рекомендует использовать в качестве отступа 4 пробела.
Программа будет верно работать и с 2 и с 8 отступами, и даже с символом
табуляции (при условии что во всём коде использован единый стиль
отступания). Но программы проверки кода — линтеры будут выдавать
предупреждения, а коллеги по проекту подзатыльники.
Также обратите внимание, что IDE при верной настройке заменяют нажатие
клавиши TAB на клавиатуре на ввод 4 пробелов!**

Обратите внимание на отсутствие скобок в строке 3. Python не требует заключать
логическое выражение в скобки. А IDE c проверкой синтаксиса будет ругаться на
скобки, как на рудимент. Единственный случай, когда вам могут понадобится
скобки, построение сложных логических выражений, где надо поменять порядок
логических проверок с традиционного слева направо, на другой

## Иначе, else

Для выполнения кода в случае ложности логического выражения используется
зарезервированное слово else c обязательным двоеточием после него

```py
pwd = 'text'
res = input('Input password: ')
if res == pwd:
    print('Доступ разрешён')
    print('Но будьте осторожны')
else:
    print('Доступ запрещён')
print('Работа завершена')
```

Слово else относится к тому if, с которым находится на одном уровне. В примере
ниже верхний if связан с нижним else, а средний if со средним else

```py
pwd = 'text'
res = input('Input password: ')
if res == pwd:
    print('Доступ разрешён')
    my_math = int(input('2 + 2 = '))
    if 2 + 2 == my_math:
        print('Вы в нормальном мире')
    else:
        print('Но будьте осторожны')
else:
    print('Доступ запрещён')
print('Работа завершена')
```

## Еще если, elif

Для проверки нескольких выражений используется elif - сокращение от else if

```py
color = input('Твой любимый цвет: ')
if color == 'красный':
    print('Любитель яркого')
elif color == 'зелёный':
    print('Ты не охотник?')
elif color == 'синий':
    print('Ха, классика!')
else:
    print('Тебя не понять')
```

Проверка работает до первого совпадения. После него дальнейший код
пропускается. А если совпадений нет, срабатывает код после else

Выбор из вариантов, match и case
В Python версии 3.10, т.е. совсем недавно появилась новая возможность
множественного сравнения. Это конструкция match и case. После match указываем
переменную для сравнения. Далее идёт блок из множества case с вариантами
сравнения. Рассмотрим работу кода на примере

**!Важно! Если у вас стоит Python версии 3.9 и ниже, код не будет работать!**

```py
color = input('Твой любимый цвет: ')
match color:
    case 'красный' | 'оранжевый':
        print('Любитель яркого')
    case 'зелёный':
        print('Ты не охотник?')
    case 'синий' | 'голубой':
        print('Ха, классика!')
    case _:
        print('Тебя не понять')
```

Данный код аналогичен прошлому варианту с elif. Добавлена возможность
проверить несколько цветов. Например для красного и оранжевого будет один
вывод. Вертикальная черта играет роль оператора "или". Уточню что пользователь
вводит один единственный цвет.
Вместо слова else в данной конструкции используется сочетание case _

# Логические конструкции, or, and, not

В Python доступны три логических оператора:

- and — логическое умножение «И»;
- or — логическое сложение «ИЛИ»;
- not — логическое отрицание «НЕ».
Логика их работы представлена в таблице

| first | second | first and second | first or second | not first |
|-------|--------|------------------|-----------------|-----------|
| true  | true   | true             | true            | false     |
| false | true   | false            | true            | true      |
| true  | false  | false            | true            | -         |
| false | false  | false            | false           | -         |

А теперь пример кода на Python чтобы разобраться в правильном синтаксисе
построения логических выражений. Вычислим високосный год в Григорианском
календаре поэтапно:

```py
year = int(input('Введите год в формате yyyy: '))
if year % 4 != 0:
print("Обычный")
elif year % 100 == 0:
if year % 400 == 0:
print("Високосный")
else:
print("Обычный")
else:
print("Високосный")
```

А теперь выберем все случаи, когда год обычный и запишем их в одну строку:

```py
if year % 4 != 0 or year % 100 == 0 and year % 400 != 0:
print("Обычный")
else:
print("Високосный")
```

Python последовательно слева направо проверяет логическое выражение,
формируя финальный ответ — True или False

# Три дополнения о ветвлении в Python

## Ленивый if

Ещё раз посмотрим на прошлый пример кода

```py
if year % 4 != 0 or year % 100 == 0 and year % 400 != 0:
```

В Python как и в некоторых других языках программирования if "ленивый". Если в
логическом выражении есть оператор or и первое значение то есть левое вернуло
истину, дальнейшая проверка не происходит, возвращается True. Если в
логическом выражении есть оператор and и левая половина вернула ложь, то
возвращается False без проверки правой половины выражения

Не рекомендуется выстраивать очень длинные логические цепочки - это затрудняет читабельность кода.

# Проверка на вхождение, in

Оператор in проверяет вхождение элемента в последовательность

```py
data = [0, 1, 1, 2, 3, 5, 8, 13, 21]
num = int(input('Введи число: '))
if num in data:
print('Леонардо передаёт привет!')
```

А теперь тот же самый код, но с конструкцией not — отрицание:

```py
data = [0, 1, 1, 2, 3, 5, 8, 13, 21]
num = int(input('Введи число: '))
if num not in data:
print('Леонардо грустит :-(')
```

Обратите внимание на порядок слов в строке 3. Python использует максимально
приближенные к человеческому, а точнее к английскому языку стиль
программирования: "Если число не входит в данные, то..."

## Тернарный оператор

Он позволяет записать 4
логические строки в одну.

Было

```py
my_math = int(input('2 + 2 = '))
if 2 + 2 == my_math:
print('Верно!')
else:
print('Вы уверены?')
```

Стало

```py
my_math = int(input('2 + 2 = '))
print('Верно!' if 2 + 2 == my_math else 'Вы уверены?')
```

Слева от if записываем выражение для истины, справа от else результат для лжи

**!Важно! При использовании тернарного оператора важно помнить, что
код должен сохранить свою читаемость. Слишком длинные и сложные
конструкции стоит переписать в более привычном виде в 4 строки.!**

**!PEP-8! требует, чтобы длина строки кода не превышала 80 символов.
Современные мониторы с широкими экранами и высоким разрешением с
легкостью вмещают больше символов. Поэтому ограничение было
пересмотрено и увеличено до 120 символов. Более длинные строки кода в
Python недопустимы, т.к. снижают его читаемость!**

# Циклы

## Логический цикл while

Цикл while является циклом с предусловием. Проверяем логическое условие,
аналогично "если" и в случае истинности выполняем вложенный блок кода. Далее
возвращаемся к проверке условия.
Попробуем перебрать всё чётные числа от нуля до введённого пользователем
исключительно..

```py
num = float(input('Введите число: '))
count = 0
while count < num:
    print(count)
    count += 2
```

Проверка условия после while и выполнение тела цикла продолжается до тех пор,
пока условие истинно.

**Синтаксический сахар**

Обратите внимание на нижнюю строку кода. "+=" - синтаксический сахар Python.

**Синтаксический сахар (англ. syntactic sugar)** в языке программирования — это
синтаксические возможности, применение которых не влияет на поведение
программы, но делает использование языка более удобным для человека.

Для неизменяемых типов данных, а числа в Python неизменяемы, две следующие
строки кода эквивалентны.

```py
num = num + 1
num += 1
num++ # не работает в Python
```

Аналогично можно записать коротко вычитание, умножение, целочисленное
деление и другие операции.

## Возврат в начало цикла, continue

При необходимости работу цикла можно прервать и досрочно вернуться к проверке
условия. Для этого используем зарезервированное слово continue.
Выведем все чётные числа (как в прошлом примере), кроме тех, которые кратны 12

```py
num = float(input('Введите число: '))
STEP = 2
limit = num - STEP
count = -STEP
while count < limit:
    count += STEP
    if count % 12 == 0:
        continue
    print(count)
```

if внутри цикла проверяет кратность двенадцати. В случае истинности команда
continue возвращает нас к началу цикла, к while.

И пара слов о двух оптимизациях в коде:

1. STEP = 2 — добавили константу для движения по чётным и ушли от
"магических чисел". Теперь изменение условия на "вывод чисел кратных 5"
потребует замены числа в одном месте кода.
2. Ввели переменную limit. Чтобы цикл не выводил лишние числа, больше
введенного num, на каждой проверке цикла while надо вычитать значение
шага. Но шаг — константа. Для экономии ресурсов ПК и ускорения работы
кода логично сделать вычитание один раз перед циклом и сравнивать
значения быстрее, без вычитания в строке while

## Досрочное завершение цикла, break

Ещё один способ управления циклом — команда break для его досрочного
завершения. Она отлично подходит для создания циклов с постусловием,
бесконечных циклов с возможностью выхода.
Рассмотрим на примере программы, которая просит ввести число внутри заданного
диапазона

```py
min_limit = 0
max_limit = 10
while True:
    print('Введи число между', min_limit, 'и', max_limit, '? ')
    num = float(input())
    if num < min_limit or num > max_limit:
        print('Неверно')
    else:
        break
print('Было введено число ' + str(num))
```

Конструкция while True: создаёт бесконечный цикл. Вместо True можно было бы
подставить любое выражение, которое всегда возвращает истину. Но именно такая
реализация обеспечивает лучшую читаемость и быстродействие.

## Действие после цикла, else

```py
min_limit = 0
max_limit = 10
count = 3
while count > 0:
    print('Попытка ', count)
    count -= 1
    num = float(input('Введи число между ' + st (min_limit) + ' и ' + str(max_limit) + ': '))
    if num < min_limit or num > max_limit:
        print('Неверно')
    else:
        break
else:
    print('Исчерпаны все попытки. Сожалею.')
    quit()
print('Было введено число ' + str(num))
```

Что изменилось в коде:

- Добавили счётчик count. Цикл проверяет не уменьшился ли счётчик до нуля.
Если нет, переходим в тело цикла. Выводим значение счётчика на каждом
витке цикла и уменьшает его на единицу.
- Добавили else для while. Логика следующая. Если пользователь ввёл верное
число и сработала команда break, блок else для цикла игнорируется. А если
числа вводились ошибочно, счётчик досчитал до нуля и произошел выход из
цикла по "лжи" в while. В этом случае сработает блок кода после else для
цикла.
Если коротко, вызов break в цикле игнорирует else для цикла.
- quit() — ещё одна функция для завершения кода раньше, чем мы дойдём до
конца файла. Это вторая функция. Первой, exit() мы пользовались для
завершения работы сеанса интерпретатора. Работают они аналогично. Завершение работы программы без ошибок. Если нужно обозначить ошибку, то в скобки вводятся число отличное от 0, т.к. 0 - это отсутствие ошибок.
- Мы добавили пустые строки в код. Python игнорирует такие строки. Но
разделение кода на блоки по смыслу упрощает чтение. Кроме того, на
следующих лекциях мы поговорим о пустых строках, которые прописаны в
PEP-8. Но не ставьте пустые строки после каждой строки кода. Если вам
нравится большой межстрочный интервал, настройте его в своей IDE.
- PEP-8! Кстати, последняя строка в файле должны быть пустой. Именно одна,
а не ноль, и не две.

## Цикл итератор for in

Цикл for in используется Python разработчиками намного чаще. Прежде чем
приступить к его рассмотрению уточню, что команды continue, break и else могут
применяться к циклу for in точно так же как и до этого в цикле while.

Рассмотрим работу цикла в качестве итератора последовательности.
Итерироваться будем по массиву с числами из части про ветвления и проверку на
вхождение

```py
data = [0, 1, 1, 2]
for item in data:
    print(item)
```

>0
>
>1
>
>1
>
>2

Цикл последовательно перебирает все элементы массива data и поочерёдно
помещает их в переменную item. После for указываем переменную или переменные
для приема значений, они изменяются на каждом витке цикла. После in указываем
объект, из которого последовательно берём данные

Если внутри циела нам не нужна никакая переменная, а нужно что-то сделать, то:

```py
data = [0, 1, 1, 2]
for _ in data
    print('item')
```

>item
>
>item
>
>item
>
>item

## Цикл по целым числам, он же арифметический цикл, функция range()

Для перебора целых чисел цикл for in используется в связке с функцией range() и работает только с целыми цислами int(). Она
выступает в качестве объекта итератора. Пример печати чётных чисел от нуля до
введённого числа может выглядеть так с циклом for:

```py
num = int(input('Введите число: '))
for i in range(0, num, 2):
print(i)
```

**!Важно! Аргументами функции range() должны быть целые числа, int()!**

Рассмотрим подробнее варианты работы функции range(). Обратите внимание на
количество переданных функции аргументов

**range(stop)** — перебираем значения от нуля до stop исключительно с шагом один

**range(start, stop)** — перебираем значения от start включительно до stop
исключительно с шагом один

**range(start, stop, step)** — перебираем значения от start включительно до stop
исключительно с шагом step.

Пара если.

- Если значение step отрицательное, перебор будет в сторону уменьшения.
- Если start больше stop при положительном step или наоборот start меньше
stop при отрицательном step, цикл не сработает ни разу. range(10, 5, 2) -
ничего

### Имена переменных в цикле

Исторически сложилось, что для переменных, которые "считают арифметику" в
цикле используются переменные i, j, k. Именно в таком порядке с учёт
вложеннности. Этой традиции более полувека. Так что смело продолжайте её и ваш
код поймут. Например так выглядят 3 вложенных цикла. Обратите внимание на
отступы, которые показывают уровень вложенности

```py
count = 10
for i in range(count):
    for j in range(count):
        for k in range(count):
        print(i, j, k)
```

А так выглядят два последовательных цикла

```py
count = 10
for i in range(count):
    print(i)
for i in range(count):
    print(i)
```

Однако, когда мы перебираем какие-то данные, вместо однобуквенных переменных
можно использовать подходящие имена. Например так может выглядеть перебор
животных, которые хранятся в массиве данных.

```py
animals = ['cat', 'dog', 'wolf', 'rat', 'dragon']
for animal in animals:
    print(animal)
```

переводится как

```py
имеем массив животных
для каждого животного в списке животных
    печатаем животное
```

## Цикл с нумерацией элементов, функция enumerate()

В финале рассмотрим ещё одну функцию, enumerate(). Она позволяет добавить
порядковый номер к элементам итерируемой последовательности. Доработаем
пример с животными. Будем выводить порядковый номер перед указанием
животного

```py
animals = ['cat', 'dog', 'wolf', 'rat', 'dragon']
for i, animal in enumerate(animals, start=1):
    print(i, animal)
```

Что изменилось?

- После for указано две переменные через запятую. В i будет помещаться
порядковый номер. В animal очередное животное из списка.
- Функция enumerate() получила в качестве первого аргумента список
животных. Второй аргумент — стартовое значение счётчика, т.е. первое
значение, которое попадёт в i.
Если второй аргумент не передать, нумерация начнётся с нуля.

**!Важно! Функция enumerate позволяет перебирать только целые числа в
порядке возрастания с шагом один!**
