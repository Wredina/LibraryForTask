Массив — упорядоченный набор элементов, каждый из которых хранит одно
значение, идентифицируемое с помощью одного или нескольких индексов. В
простейшем случае массив имеет постоянную длину и хранит единицы данных
одного и того же типа, а в качестве индексов выступают целые числа.
В информатике, список (англ. list) — это абстрактный тип данных, представляющий
собой упорядоченный набор значений, в котором некоторое значение может
встречаться более одного раза. Экземпляр списка является компьютерной
реализацией математического понятия конечной последовательности. Экземпляры
значений, находящихся в списке, называются элементами списка (англ. item, entry
либо element); если значение встречается несколько раз, каждое вхождение
считается отдельным элементом.

# Списки, list()

Динамические изменяемые объекты

List, список является самой часто используемой коллекцией в Python. Прежде чем
говорить о списках, я напомню, что такое массив в информатике. Массив - это
непрерывная область в оперативной памяти компьютера, поделённая на ячейки
одинакового размера хранящие данные одного типа. Массивы могут быть
статическими, то есть размер массива нельзя изменить, и динамическими, когда
размер массива изменяется при добавлении или удалении элементов. Один из
самых больших плюсов в работе с массивами — это доступ к любой из его ячеек за
константное время

- Единый блок в памяти
- Хранит значения любых типов вперемешку
- Добавление элементов в конец
- Доступ к элементам по индексу с константной сложностью

## Создание списка list()

4 способа

```py
list_1 = list()
list_2 = list((3.14, True, "Hello world!"))
list_3 = []
list_4 = [3.14, True, "Hello world!"]
```

список можно создать из другой последовательности. Достаточно
передать её функции list

```
new_list = list(other_iterator)
```

**!Важно! Преобразование одной коллекции в другую имеет линейную
асимптотику, т.е. O(n). И по времени, и по памяти конечно же. Ведь мы создаём
объект списка и копируем в него данные.
7
!**

### Доступ к элементам списка

Как мы уже разобрались список ведёт себя как динамический массив. А это значит,
что к любому элементу списка можно обратиться по индексу. В Python, как и в
большинстве языков программирования, индексация начинается с нуля, то есть,
первый элемент лежит в ячейке под индексом 0, следующий элемент в ячейке один
и так далее

```py
my_list = [2, 4, 6, 8, 10, 12]
print(my_list[3]) # доступ к элементу под индектом 3
print(my_list[6]) # IndexError: list index out of range
```

```py
my_list = [2, 4, 6, 8, 10, 12]
print(my_list[-1]) # обращение к последнему элементу
print(my_list[-10]) # IndexError: list index out of range
```

### Методы работы со списком

- append() - добавление одного элемента в конец
- extend() - добавление нескольких элементов в конец
- pop() - Удаление элемента по индексу (по умолчанию последнего)
- count() - Подсчёт вхождения элемента
- index() - индекс первого вхождения элемента
- insert() - вставка элемента по индексу
- remove() - удаление элемента по значению

#### append()

Для добавления нового элемента в конец списка используется метод append. Метод
принимает один аргумент — объект который будет добавлен в конец динамически
увеличенного списка

```py
a = 42
b = 'Hello world!'
c = [1, 3, 5, 7]
my_list = [None] # создаём список с элементом None
my_list.append(a) # добавляем в конец списка значение переменной a
print(my_list)
my_list.append(b)# добавляем в конец списка значение переменной b
print(my_list)
my_list.append(c)# добавляем в конец списка значение переменной c
print(my_list)
```

> [None, 42]
>
> [None, 42, 'Hello world!']
>
> [None, 42, 'Hello world!', [1, 3, 5, 7]]

Обратите внимание, что при добавлении списка c в список my_list он оказался
целиком в одной ячейке списка. Ссылочная система Pyhton позволяет формировать
структуры любой глубины вложенности.

ПЛОХОЙ КОД

```py
my_list.append(my_list)
print(my_list)
# Вывод: [None, 42, 'Hello world!', [1, 3, 5, 7], [...]]
```

Многоточие в выводе говорит о рекурсивной ссылке. Явный намёк на то, что
программист сделал что-то неверно своей программе.

#### extend()

Метод extend ведёт себя аналогично append, то есть добавляет элементы в конец
списка. В качестве аргумента extend принимает последовательность, итерируется
по ней слева направо и каждый элемент добавляет в новую ячейку списка

extend() не работает с одним элементом, только с последовательностью

```py
a = 42
b = 'Hello world!'
c = [1, 3, 5, 7]
my_list = [None]# создаём список с элементом None
my_list.extend(a) # TypeError: 'int' object is not iterable
print(my_list)
my_list.extend(b)# добавляем в конец списка последовательность переменной b
print(my_list)
my_list.extend(c)# добавляем в конец списка последовательность переменной с
print(my_list)
my_list.extend(my_list)# добавляем в конец списка последовательность того, что лежит в самом списке
print(my_list)
```

- extend(a) — если в метод передать не коллекцию, получим ошибку TypeError.
- extend(b) — строка воспринимается как коллекция, в результате каждый
символ строки помещается в новую ячейку списка.
- extend(c) — итерируемся по списку, c последовательно добавляя его
элементы в список my_list
- extend(my_list) — удваиваем список, добавляя копию всех его элементов.

> [None]
>
> [None, 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!']
>
>[None, 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', 1, 3, 5, 7]
>
>[None, 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', 1, 3, 5, 7, None, 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', 1, 3, 5, 7]

Метод extend имеет константную асимптотику O(1) на добавление одного элемента
и зависит от количества переданных объектов, т.е. O(n), где n - количество
элементов в последовательности.

#### pop()

Метод pop позволяет удалить элемент списка. Удаляемый элемент возвращается
как результат работы метода.

```py
my_list = [2, 4, 6, 8, 10, 12]
spam = my_list.pop() # удаляет последний элемент и записывает его в переменную spam
print(spam, my_list)
eggs = my_list.pop(1) # удаляет элемент под индексом 1 и записывает его в переменную eggs
print(eggs, my_list)
err = my_list.pop(10) # IndexError: pop index out of range
```

> 12 [2, 4, 6, 8, 10]
>
> 4 [2, 6, 8, 10]

Метод pop может принимать на вход индекс удаляемого элемента. Этот элемент
вернётся как результат работы метода, т.е. может быть сохранён в переменную.
Индекс может быть отрицательным. Тогда элемент считается от правой части
списка, с конца

Если указать индекс выходящий за границы списка получим ошибку IndexError.
Метод pop без аргумента имеет константную асимптотику O(1). Метод pop с
аргументом имеет линейную асимптотику. Список не допускает пустых ячеек,
поэтому при удаление элемента из середины списка все элементы находящиеся
правее сдвигаются на одну ячейку влево. Получаем O(n), где n - количество
элементов правее удаляемого

**!Python Style! Переменные spam и eggs используется в языке Python как временные
переменные. Эти названия, ветчина и яйца, используют True Python разработчики.
Ведь язык назван в честь комедийного шоу Летающий цирк Монти Пайтон. А одно
из их видео посвящено шуткам про ветчину и яйца!**

#### count()

Метод count подсчитывает вхождение элемента в список

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 2, 4, 14, 2]
spam = my_list.count(2) # считает совпадения с 2
print(spam)
eggs = my_list.count(3) # считает совпадения с 3
print(eggs)
```

> 4
>
> 0

Метод принимает именно объект, а не индекс. Если объект отсутствует в списке,
count возвращает ноль — элемент был встречен в списке ноль раз.
Count имеет линейную асимптотику O(n), т.к. для подсчёта метод перебирает все
элемента списка и сравнивает их с переданным объектом

#### index()

Метод index возвращает индекс переданного объекта внутри списка.

index(el,start,stop) - в диапазоне индексов от start до stop(если индекс будет больше длины списка, то работа будет только до конца списка, не будет ошибки) искать первое вхождение el

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 2, 4, 14, 2]
spam = my_list.index(4) # первое вхождение цифры 4
print(spam)
eggs = my_list.index(4, spam + 1, 90) # в диапазоне индексов до 1 до 90 искать первое вхождение значения 4
print(eggs)
err = my_list.index(3) # ValueError: 3 is not in list
```

> 1
>
> 8

Метод работает до первого вхождения, т.е. если элемент встречается несколько раз,
возвращается индекс первой встречи. Метод может принимать два
дополнительных аргумента: индекс start и индекс stop. В таком случае поиск
элемента осуществляется внутри заданного диапазона. Если элемент отсутствует в
списке, метод вызывает ошибку ValueError.
Чем ближе элемент к началу списка, тем быстрее работает метод. В лучшем случае
получаем константную асимптотику O(1), в худшем линейную O(n).

**!Если правая граница, stop индекс, окажется больше, чем
количество элементов в списке, поиск будет осуществляться до конца списка.
Ошибку это не вызовет.!**

#### insert()

Метод insert принимает на вход два аргумента — индекс для вставки и объект
вставки. Метод добавляет элемент после индекса.

```py
my_list = [2, 4, 6, 8, 10, 12]
my_list.insert(2, 555) # после индекса 2 вставить значение 555
print(my_list)
my_list.insert(-2, 13) # после индекса -2 вставить значение 13
print(my_list)
my_list.insert(42, 73) # my_list.append(73) вставка произойдёт в конец списка
print(my_list)
```

> [2, 4, 555, 6, 8, 10, 12]
>
> [2, 4, 555, 6, 8, 13, 10, 12]
>
> [2, 4, 555, 6, 8, 13, 10, 12, 73]

Если индекс положительный, элемент добавляется в указанную ячейку, а все
последующие элементы списка сдвигаются на ячейку правее.
Если индекс отрицательный, отсчитывается необходимое количество элементов
справа для вставки. Например -2 означает, что после вставки справа от
добавленного элемента будет находится ещё два.
В том случае, когда индекс оказывается больше, чем количество элементов списка,
объект добавляется в конец. В таком случае логичнее использовать метод append,
выполняющий добавление элемента в конец списка

#### remove()

Метод remove принимает на вход значение, которое он ищет в списке и удаляет первый найденный элемент соответствующий значению

```py
my_list = [2, 4, 6, 8, 10, 12, 6]
my_list.remove(6) # удаляет первое найденное значение 6
print(my_list)
my_list.remove(3) # ValueError: list.remove(x): x not in list
print(my_list)
```

> [2, 4, 8, 10, 12, 6]

Если удаляемый элемент встречается в списке несколько раз, удаляется только
один элемент — самый левый.
А если удаляемый элемент отсутствует в списке, будет вызвана ошибка ValueError.

## Сортировка списков

Одна из частых операций при работе со списками их сортировка. Python позволяет
отсортировать список на месте, inplace, т.е. не создавая копию. А можно создать
копию отсортированного списка как отдельный объект.

**!Важно! При сортировке элементы списка должны быть одного типа.
Иначе Python может не понять как сравнивать между собой элементы разных
типов и вызовет ошибку.!**

ПЛОХОЙ ПРИМЕР

```py
my_list = ['H', 'e', 'l', 'l', 'o', 1, 3, 5, 7]
my_list.sort() # TypeError: '<' not supported betweeninstances of 'int' and 'str'
res = sorted(my_list) # TypeError: '<' not supportedbetween instances of 'int' and 'str'
```

sorted() - принимает на вход любую коллекцию и создаёт новый список. сортирует сортировкой Timsort

sort() - осуществляет сортировку элементов списка без создания копии

reversed() - разворот последовательности

reverse() и синтаксический сахар [::-1] - Метод разворачивает список на месте не создавая копии

### Функция sorted()

Функция sorted принимает на вход любую коллекцию по которой можно
итерироваться и возвращает отсортированный список

**!Важно! Функция sorted может принимать не только списки, но и другие
последовательности: строки, множества, кортежи, словари и т.п.. При этом
функция всегда возвращает список!**

```py
my_list = [4, 8, 2, 9, 1, 7, 2]
sort_list = sorted(my_list) # создаём новый отсортированный список
print(my_list, sort_list, sep='\n')
rev_list = sorted(my_list, reverse=True) # создаём новый список, отсортированный в обратном направлении
print(my_list, rev_list, sep='\n')
```

> [4, 8, 2, 9, 1, 7, 2]
>
> [1, 2, 2, 4, 7, 8, 9]
>
> [4, 8, 2, 9, 1, 7, 2]
>
> [9, 8, 7, 4, 2, 2, 1]

Переданная в функцию коллекция остаётся неизменной после результата работы
функции. Если в функцию передать дополнительный аргумент reverse=True,
сортировка происходит по убыванию.

Внутри функции используется алгоритм сортировки Timsort — гибридная
устойчивая сортировка с временной асимптотикой O(n log n). Дополнительно
тратится O(n) памяти на создание нового отсортированного списка.

### Метод sort()

Метод sort осуществляет сортировку элементов списка без создания копии, inplace

Принимает на вход только список

```py
my_list = [4, 8, 2, 9, 1, 7, 2]
my_list.sort()
print(my_list)
my_list.sort(reverse=True)
print(my_list)
```

>[1, 2, 2, 4, 7, 8, 9]
>
>[9, 8, 7, 4, 2, 2, 1]

Как и функция sorted метод sort упорядочивает элементы по возрастанию. Если
передать дополнительный параметр reverse=True, будет произведена сортировка по
убыванию. Внутри метода работает тот же самый алгоритм сортировки Timsort. Но
память на создание копии списка мы не тратим.

### Функция reversed()

Функция принимает на вход последовательность, которая поддерживает порядок
элементов, возвращает функция объект итератор с обратным порядком элементов

```py
my_list = [4, 8, 2, 9, 1, 7, 2]
res = reversed(my_list)
print(type(res), res)
rev_list = list(reversed(my_list))
print(rev_list)
```

Если нам
нужен новый развёрнутый список, объект итератор стоит обернуть в функцию list. В
таком случае мы получим новый развёрнутый список.

**!Важно! Подобный приём затратен по времени и по памяти!**

Обычно функция reversed используется в сочетании с циклом for in. Такой приём
позволяет работать с элементами списка внутри цикла в обратном порядке.

```py
for item in reversed(my_list):
print(item)
```

### Метод reverse() и синтаксический сахар [::-1]

Метод разворачивает список на месте не создавая копии

Если нам нужно развёрнутая версия списка логичные и удобнее использовать
встроенный метод reverse.

```py
my_list = [4, 8, 2, 9, 1, 7, 2]
my_list.reverse()
print(my_list)
```

Кроме этого в Python есть возможность получить развернутую копию через особую
запись в квадратных скобках, синтаксический сахар. После имени списка в
квадратных скобках слитно записываем два двоеточия и минус один.

```py
my_list = [4, 8, 2, 9, 1, 7, 2]
new_list = my_list[::-1]
print(my_list, new_list, sep='\n')
```

Подобная запись аналогична rev_list = list(reversed(my_list))
рассмотренной выше. Разворот списка с использованием квадратных скобок —
частный случай срезов.

## Создание копий

**!Предупреждение! Создание копий и срезов - очень затратная операция для памяти компьютера. Поэтому желательно всегда стараться выбирать другие пути для решения задачи!**

- Срезы - list[start:stop:step]
- copy() - Создаёт поверхностную копию
- copy.deepcopy() - Рекурсивно создаёт полную копию

### Срезы list[start:stop:step]  

start указывает на первый индекс, который включается в срез. При отсутствии
значения start равен нулю, началу списка.

stop указывает на последний индекс, который не включается в срез. При отсутствии
значения stop равен последнему элементу списка и включает его в срез.

step — шаг движения от star до stop. По умолчанию step равен единице, все
элементы по порядку.

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
print(my_list[2:7:2]) #с индекса 2(вкл) по 7(не вкл) в 2 шага
print(my_list[:7:2]) #с индекса 0 по 7(не вкл) в 2 шага
print(my_list[2::2]) #с индекса 2(вкл) до конца в 2 шага
print(my_list[2:7:]) #с индекса 2(вкл) по 7(не вкл) каждый шаг
print(my_list[8:3:-1]) #с индекса 8(вкл) по 3(не вкл) уменьшая шаг на 1 (движение с права на лево)
print(my_list[3::]) #с индекса 2(вкл) до конца каждый шаг
print(my_list[:7:]) #с индекса 0 до 7(не вкл) каждый шаг
```

>[6,8,12]
>
>[2,6,8,12]
>
>[6,8,12,16]
>
>[16,14,12,10,8]
>
>[2,8,10,12,14,16,18]
>
>[2,4,6,2,8,10,12]

### Метод copy()

Метод copy создаёт поверхностную копию списка.

ПЛОХОЙ ПРИМЕР

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list # Создаём переменную в которую вкладываем готовый список
print(my_list, new_list, sep='\n')# выводим в принт созданную переменную и готовый список
my_list[2] = 555 # в готовый список во второй индекс вкладываем значение 555
print(my_list, new_list, sep='\n') # распечатываем и готовый список и ту переменную, в которую в самом начале вложили готовый список
```

>[2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 555, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 555, 6, 2, 8, 10, 12, 14, 16, 18]

Мы скопировали в переменную new_list указатель на список my_list. Далее мы
изменили элемент в исходном списке. Новый список также оказался изменённым.
Как вы помните list —изменяемый тип данных и подобное поведение нормально.
Что делать, если нужно менять оригинал, но не затрагивать копию. Верно. Метод
copy

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list.copy()# создание поверхостной копии списка и записи его в переменную
print(my_list, new_list, sep='\n')# распечатываем оба списка
my_list[2] = 555 #вкладываем в основной список во второй индекс значение 555
print(my_list, new_list, sep='\n') # распечатываем оба списка
```

>[2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 555, 6, 2, 8, 10, 12, 14, 16, 18]
>
>[2, 4, 6, 2, 8, 10, 12, 14, 16, 18]

Два независимых списка, которые хранятся в разных ячейках оперативной памяти и между собой не связаны

### функция copy.deepcopy()

Иногда программисту приходится работать с вложенными друг в друга
коллекциями. Например матрица или список списков

ТУТ НЕ СРАБОТАЕТ copy()

```py
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_m = matrix.copy()# создаём порехностную копию списка
print(matrix, new_m, sep='\n')# распечатываем оба списка
matrix[0][1] = 555 # вкладываем в основной список значение 555
print(matrix, new_m, sep='\n') # распечатываем
```

>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 555, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 555, 3], [4, 5, 6], [7, 8, 9]]

Метод copy создал поверхностную копию, копию верхнего уровня. Изменения же
вложенных объектов отразится и на оригинале. В таком случае для создания
полной копии любой глубины вложенности используют функцию deepcopy из
модуля copy.

```py
import copy

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_m = copy.deepcopy(matrix)# создаём новый список путём глубокого копирования
print(matrix, new_m, sep='\n')
matrix[0][1] = 555 #вложим в основной список 
print(matrix, new_m, sep='\n')
```

>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 555, 3], [4, 5, 6], [7, 8, 9]]
>
>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

Функция рекурсивно обходит все вложенные объекты создавая их копии.
Изменения одной коллекции теперь не затрагивают её копию

### Плюсы и минусы создания копии

При работе со списками важно помнить, что сам список как хранитель указателей
на объекты занимает место в памяти. Дополнительно занимают память и сами
объекты, на которые список указывает. Создание копии приводит к новым затратам
памяти, ведь мы создаём новый объект список. Если вы работает с большими
данными, создание копии может быть не лучшей идеей - может не хватить памяти
ПК. Кроме того каждая копия требует временных ресурсов на копирование. Прежде
чем использовать срезы, копии задумайтесь можно ли решить задачу иначе,
экономя время и память.
С другой стороны небольшие списки быстро копируются. И если в вашей задаче
важно сохранить оригинал, но нужно модифицировать список для получения
результата —копирование вполне допустимо

## Функция len()

На вход она принимает любую
коллекцию, в которой можно посчитать количество элементов

len(x) - возвращает целое цисло - количество элементов коллекции (не учитывает вложенные коллекции)

**!Важно! Функция одинаково работает не только для списков, но и для
других коллекций.!**

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
print(len(my_list))# выводим на печать длину первого списка
print(len(matrix))# выводим на печать длину второго списка
print(len(matrix[1]))# выводим на печать длину первого элемента в матрице
```

>10
>
>3
>
>4

Подсчитывается количество
элементов первого уровня вложенности. У списка 10 элементов в ячейках с нулевой
по девятую. Функция вернула 10

У матрицы три элемента списка в ячейках с нулевой по вторую. В каждом из
вложенных списков по 4 элемента, т.е. суммарно 12. Но функция len вернула число
3 посчитав элементы верхнего уровня

При обращении к элементу матрицы в ячейке один, т.е. списку [5, 6, 7, 8] функция
len возвращает число 4, верно посчитав количество элементов вложенного списка

Для списков len работает за константное время O(1). Внутри объекта списка всегда
хранится количество элементов. Функция получает это значение, а не занимается
подсчётом

# Пример работы со списками

```py
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
print(my_list[2:6:2])# вернёт [6,8]
print(my_list.pop())#вернёт 18 (это число удалится из списка)
print(my_list.extend([314, 42]))# вернёт None (вставит в список 2 числа, но сам метод ничего не возвращает)
print(my_list.sort(reverse=False))#вернёт 0 (сортирует список от меньшего к большему, но сам по себе ничего не возвращает)
print(my_list)#[2, 4, 6, 2, 8, 10, 12, 14, 16, 42, 314]
```

# Строки, str

Строки как массивы данных. Часть рассмотренной для
списков информации аналогична и для строки. Например, обращение к элементу
строки по индексу в квадратных скобках, срезы строк и т.п. При этом стоит помнить,
что строка неизменяема

## Работа со строками как с массивами

[ ] - доступ к элементу по индексу // срезы строк // реверс строк

count() - Подсчёт вхождения элемента

index() - Индекс первого вхождения элемента

find() - Индекс первого вхождения элемента

### Квадратные скобки [ ]

```py
text = 'Hello world!'
print(text[6])# найти элемент под индексом 6
print(text[3:7])# вывести элементы с 3-го по 7(не вкл) индекс 
new_txt = text.replace('l', 'L', 2)# создать переменную и сохранить в неё предыдущую, но найдя 2 первых элемента l и заменив их на L 
print(text, new_txt, sep='\n')
```

>w
>
>lo w
>
>Hello world!
>
>HeLLo world!

Индексы и срезы работают аналогично спискам.
Если необходимо заменить элемент новым, индексы не подойдут. Для этих целей
нужен метод replace

Первый аргумент — подстрока, которую нужно заменить.

Второй аргумент — подстрока, на которую нужно заменить.

Третий аргумент — максимальное количество замен. Если его не указывать, будут
заменены все совпадения

### Методы count, index, find

Как и у списка, строка поддерживает методы count для подсчёта вхождения и index
для поиска элемента. Но у строки появился и новый метод find. Он работает
аналогично index. Но если искомая подстрока отсутствует, вместо ошибки
возвращает -1

```py
text = 'Hello world!'
print(text.count('l'))# сколько раз встречается эл. l
print(text.index('l'))# индекс первого вхождения буквы l
print(text.find('l'))# индекс первого вхождения буквы l
print(text.find('z'))# попытка поиска буквы z
```

>3
>
>2
>
>2
>
>-1 #буквы нет в списке

### Реверс строк

Для разворота строки используется обратный срез, как и в случае со списком

```py
text = 'Hello world!'
print(text[::-1])
```

>!dlroe olleH

## Форматирование строк

% - старый способ, сохранился в некоторых модулях

format() - строковый метод, заменяющий фигурные скобки на переменные

f-строка - Сочетание неизменяемого текста и переменных в фигурных скобках

### Форматирование через %

Форматирование с использованием символа % является старым способом указания
формата.
В
настоящее время он используется лишь в некоторых модулях для задания формата
вывода данных

```py
name = 'Alex'
age = 12
text = 'Меня зовут %s и мне %d лет' % (name, age) #%s (str) %d(digit) - перечисляем в скобочках переменные, которые встанут вместо s и d
print(text)
```

> Меня зовут Alex и мне 12 лет

В строке текста используется знак % с символом типа после него. s —строка, d —
число и т.п. После строки указывается символ % и перечисляются переменные. Если
переменных больше одной, они заключаются в круглые скобки и разделяются
запятой —передаётся кортеж

### Метод format

Метод формат является строковым методом и позволяет соединять заранее
заготовленный текст с переменными. Долгое время был основным способом
форматирования. До версии Python 3.6, если быть точным.

```py
name = 'Alex'
age = 12
text = 'Меня зовут {} и мне {} лет'.format(name, age)# похож на метод %, но вместо типов, ставятся фигурные скобки
print(text)
```

> Меня зовут Alex и мне 12 лет

В строке используются фигурные скобки как место для подстановки значений.
Далее для строки вызывается метод format. В качестве аргументов метод получает
нужное количество переменных

### f-строка

Начиная с Python 3.7 для форматирования текста используют f-строки. Они
работают быстрее, чем старые способы форматирования. А некоторые
разработчики языка предлагают сделать их строками по умолчанию в одном из
будущих релизов.

f-строки похожи на более короткую и читаемую запись метода формат.

```py
name = 'Alex'
age = 12
text = f'Меня зовут {name} и мне {age} лет'
print(text)
```

> Меня зовут Alex и мне 12 лет

Перед открывающей кавычкой пишут f —указатель на отформатированную строку.
Текст внутри фигурных скобок воспринимается как переменная и на печать
выводятся из значения.

**!Важно! Для печати фигурных скобок используется две фигурные скобки
слитно.!**

```py
print(f'{{Фигурные скобки}} и {{name}}')
```

Помимо вывода содержимого переменной можно указать дополнительные
символы, влияющие на представление

### Уточнение формата

Существую различные способы уточнения способа вывода значения переменной

```py
pi = 3.1415
print(f'Число Пи с точностью два знака: {pi:.2f}')# выведет только 2 знака после запятой (.2f - float)

data = [3254, 4364314532, 43465474, 2342, 462256, 1747]

for item in data:
    print(f'{item:>10}')# выравнивание элементов по правому краю, ширина вывода 10 символов (^ - выравнивание по центру)

num = 2 * pi * data[1] #умножаем 2 на переменную pi и yf первый элемент списка data
print(f'{num = :_}') # вывод имени переменной со знаком = и число разделяется по три цифры символом _
```

>Число Пи с точностью два знака: 3.14

>3254
>
>                                              4364314532
>
>                                                43465474
>
>                                                    2342
>
>                                                  462256
>
>                                                    1747

>num = 27_420_988_204.556

После указания имени переменной в фигурных скобках ставится двоеточие —
указатель на символы задания формата далее

- :.2f —число пи выводим с точность два знака после запятой
- :>10 —элементы списка выводятся с выравниванием по правому краю и
общей шириной вывода в 10 символов
- = —выводим имя переменной, знак равенства с пробелами до и после него и
только потом значение.
- :_ —число разделяется символом подчёркивания для деления на блоки по 3
цифры.

# Методы строк

split() - разбивает строку на отдельные элементы

join() - формирует строку из отдельных элементов

upper() - верхний регистр

lower() - нижний регистр

title() - первый символ каждого слова (разделитель слов - пробел) приводится
к верхнему регистру, остальные символы к нижнему

capitalize() - первый символ строки в верхнем регистре, остальные в нижнем

startwith() - проверка на совпадение с началом

endswith() - проверка на совпадение с концом

## split()

Метод split позволяет разбить строку на отдельные элементы в соответствии с
разделителем и поместить результат в список. По умолчанию разделитель пробел.

```py
link = 'https://habr.com/ru/users/dzhoker1/posts/'
urls = link.split('/') # разбиение текста через /
print(urls)

a, b, c = input('Введите 3 числа через пробел: ').split()#вводим 1 2 345 (если ввести неправильно, будет ошибка)
print(c, b, a)

```

>[https:, '', habr.com, ru, users, dzhoker1, posts, '']

>[1, 2, 345]

В первом случае мы взяли ссылку и разделили её на отдельные компоненты по
символу “/”. Обратите внимание, что между двойным слешем мы получили пустую
строку. И вторую пустую строку после последнего слеша.

Во втором примере метод не получил на вход аргументы и деление происходит по
пробельным символам. Три переменные до знака равно примут по одному из
переданных значений

Один из способов избежать ошибки лишних (но не меньших) данных при
распаковке методом split — использовать символ распаковки

```py
a, b, c, *_ = input('Введите не менее трёх чисел через пробел:').split() # упаковка только валидных данных в переменные // вводим 1 2 3 4 5 // упакует только 1 2 3
```

>Process finished with exit code 0 # успешно упаковано

Переменная подчёркивание благодаря звёздочке, символу упаковки, превращается
в список, который заберет значения начиная с четвёртого

## Метод join

Метод join принимает на вход итерируемую последовательность и соединяет все её
элементы в строку, разделяя каждый текстом, к которому применён метод. В
некоторой степени join противоположен split

```py
data = ['https:', '', 'habr.com', 'ru', 'users', 'dzhoker1',
'posts']
url = '/'.join(data) # формируем строку соединяя элементы /
print(url)
```

>https:\/\/habr.com/ru/users/dzhoker1/posts

К строке “/” применили метод, т.е. каждый элемент списка будет разделён слешем.
При этом в начале и в конце получившейся строки слеша не будет

## Методы upper, lower, title, capitalize

При работе с текстом можно быстро менять строчные буквы на прописные и
наоборот

```py
text = 'однажды в СТУДЁНУЮ зИмнЮЮ ПоРУ'
print(text.upper()) # верхний регистр
print(text.lower()) # нижний регистр
print(text.title()) # каждое слово с большой буквы
print(text.capitalize()) # только первое слово с большой буквы
```

>ОДНАЖДЫ В СТУДЁННУЮ ЗИМНЮЮ ПОРУ
>
>однажды в студённую зимнюю пору
>
>Однажды В Студённую Зимнюю Пору
>
>Однажды в студённую зимнюю пору

- upper —все символы приводятся к верхнему регистру
- lower —все символы приводятся к нижнему регистру
- title —первый символ каждого слова (разделитель слов - пробел) приводится
к верхнему регистру, остальные символы к нижнему
- capitalize —первый символ строки в верхнем регистре, остальные в нижнем

## Методы startswith и endswith

startswith(str, start, stop) - поиск слова с индекса start до stop
endswith(str, start, stop) - поиск слова с индекса start до stop

Метод startswith проверяет начинается ли строка с заданной подстроки. Метод
возвращает истину или ложь. Метод endswith проверяет окончание строки
переданной в качестве аргумента подстрокой

```py
text = 'Однажды в студёную зимнюю пору'
print(text.startswith('Однажды')) # начинается ли текст со слова "Однажды"
print(text.endswith('зимнюю', 0, -5)) # заканчивается ли текст после -5 индекса словом "зимнюю"
```

>True
>
>True

Оба метода помимо подстроки могут принимать параметры start и stop. В этом
случае проверка начала либо конца будет проводиться в указанном диапазоне

# Применение строковых методов

```py
text = 'Привет, мир!'
print(text.find(' ')) # 7
print(text.title()) # Привет, Мир
print(text.split()) # ["Привет,", "мир!"]
print(f'{text = :>25}') #(выравнивание текста по правому краю) text =                       Привет, мир!
```

# Кортеж, tuple

Кортежи — это неизменяемые последовательности, обычно используемые для
хранения коллекций разнородных данных. Также используются в случаях, когда
требуется неизменяемая последовательность однородных данных. Как и строку
кортеж нельзя изменить после создания. При этом кортеж как и список является
массивом указателей на объекты любого типа

## Способы создания кортежа

Создать кортеж можно четырьмя способами.

```py
a = () # создание кортежа при помощи круглых скобок
b1 = 1, # элемент с замыкающей запятой
b2 = (1,) # элемент в круглых скобках с замыкающей запятой
c1 = 1, 2, 3, # несколько элементов с замыкающей запятой
c2 = (1, 2, 3) # несколько элементов в круглых скобках
d = tuple(range(3)) # обращение к функции tuple которой передаётся итерируемый объект (range(3) считает до 3-х (0,1,2))
print(a, b1, b2, c1, c2, d, sep='\n')
```

1. Пара круглых скобок создаёт пустой кортеж
2. Один элемент с замыкающей запятой в скобках или без них создаёт кортеж с
элементом
3. Несколько элементов разделенных запятыми с замыкающей запятой или в
круглых скобках
4. Функция tuple(), которой передаётся любой итерируемый объект

**!Важно! Обратите внимание, что на самом деле кортеж образует запятая,
а не круглые скобки. Круглые скобки необязательны, за исключением случая
пустого кортежа или когда они необходимы, чтобы избежать синтаксической
неоднозначности. Например, f(a, b, c) — это вызов функции с тремя
аргументами. f((a, b, c)) — вызов функции с кортежем в   качестве
единственного аргумента!**

## Работа с кортежем

- Обращение к элементу по индексу
- Срезы
- Методы, которые работают с последовательностью, но не меняют её: count,
index, а также функция len()

# Пример работы с кортежами

```py
my_tuple = (2, 4, 6, 2, 8, 10, 12, 14, 16, 18)
print(my_tuple[2:6:2]) # [6, 8]
print(my_tuple[-3]) # 14
print(my_tuple.count(2)) # 2
print(f'{my_tuple = }') # my_tuple = (2, 4, 6, 2, 8, 10, 12, 14, 16, 18)
print(my_tuple.index(2, 2)) # 3
print(type('text',)) # str (т.к. нет дополнительных скобок)
```

# Словарь, dict

В Python есть изменяемый тип данных словарь. В других языках аналогичная
структура данных может называться отображение, mapping, именованный массив,
ассоциативный массив, сопоставление и т.п. Словарь представляет набор пар
ключ-значение. Ключ —любой неизменяемый тип данных. Значение - любой тип
данных. Обращаясь к ключу словаря получают доступ к значению.

**!Важно! Ключ выступает источником для вычисления хеша. Полученный
хеш играет роль числового индекса и указывает на ячейку со значением. В
Python вычисление хеша возможно лишь у неизменяемых типов данных.
Следовательно, ключ словаря обязан быть неизменяемым объектом. Обычно
это строка, целое число (вещественные лучше не использовать, вы же помните
о точности округления), либо кортеж или неизменяемое множество!**

## Способы создания словаря

```py
dict(x) - создание словаря
{key: value} - создание словаря
```

```py
a = {'one': 42, 'two': 3.14, 'ten': 'Hello world!'} #набор ключ-значение в фигурных скобках
b = dict(one=42, two=3.14, ten='Hello world!') # знак раменства между ключём и значением (синтаксический сахар, но нельзя использовать зарезервированные слова)
c = dict([('one', 42), ('two', 3.14), ('ten', 'Hello world!')]) # последовательность где каждый элемент ключ-значение
print(a == b == c)
```

> True

- передать набор пар ключ-значение в фигурных скобках,
- использовать знак равенства между ключом и значением,
- передать любую последовательность, каждый элемент который пара ключ и
значение

**!Важно! Вариант b не допускает использования зарезервированных слов.
При этом ключи указываются без кавычек, но в словаре становятся ключами
типа str!**

## Добавление нового ключа

Для добавления в существующий словарь новой пары ключ-значение можно
использовать обычную операцию присваивания

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
my_dict['ten'] = 10 # добавление в конец словаря новую пару
print(my_dict)
```

> {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
x = 10
my_dict['ten'] = x
print(my_dict)
```

> {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}

## Доступ к значению словаря

Для добавления в существующий словарь новой пары ключ-значение можно
использовать обычную операцию присваивания

Через ключь можно получить доступ к значению, но через значение не возможно получить доступ к ключу.

dict[key] - доступ через квадратные скобки

dict.get(key[, default]) - доступ через метод get()

### Доступ через квадратные скобки [ ]

Для получения доступа к значению необходимо указать ключ в квадратных скобках
после или переменной.

```py
TEN = 'ten'
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}

print(my_dict['two']) # запрос значения по ключу two
print(my_dict[TEN]) # Запрос значения по ключу ten
print(my_dict[1]) # будет искать ключ 1 - KeyError: 1
```

>2
>
>10

Ключ может быть указан явно или передам как содержимое переменной,
константы. При попытке обратиться к несуществующему ключу получаем ошибку:
KeyError.
Доступ к ключу позволяет изменять значения. Для этого используем операцию
присваивания как и в случае с добавлением новой пары ключ-значение

### Доступ через метод get

Если ли мы хотим гарантировать отсутствие ошибки KeyError при обращении к
элементу словаря, можно обратиться к значению через метод get, а не квадратные
скобки

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}

print(my_dict.get('two')) # получение доступа к значению 2
print(my_dict.get('five')) # такого ключа нет, получим None
print(my_dict.get('five', 5)) # т.к. этого ключа со значением нет в словаре, то метод вернул значение по умолчанию 5
print(my_dict.get('ten', 5)) # этот ключь есть в словаре, поэтому вернётся его значение 10, а то значение, которое мы передали, будет игнорироваться. Оно актуально, только если ключа в словаре нет
```

>2
>
>None
>
>5
>
>10

При обращении к существующему ключу метод get работает аналогично доступу к
через квадратные скобки. Если обратиться к несуществующему ключу, get
возвращает None. Метод get принимает второй аргумент, значение по умолчанию.
Если ключ отсутствует в словаре, вместо None будет возвращено указанное
значение

## Часто используемые методы словарей

setdefault() - Возвращает значение и добавляет ключ в словарь

keys() - возвращает объект итератор dict_keys

values() - возвращает объект итератор dict_values

items() - возвращает объект итератор dict_items

popitem() - удаляет последнюю пару ключ-значение

pop() - удаляет пару ключ-значение по ключу

update() - расширяет исходный словарь новыми парами

### Метод setdefault()

Метод setdefault похож не get, но отсутствующий ключ добавляется в словарь

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}

spam = my_dict.setdefault('five') #ключь добавляем в словарь, значение записываем в переменную 
print(f'{spam = }\t{my_dict = }') 

eggs = my_dict.setdefault('six', 6) #ключь добавляем в словарь, значение записываем в переменную 
print(f'{eggs = }\t{my_dict = }')

new_spam = my_dict.setdefault('two') #такой ключь есть, поэтому его значение просто запишется в переменную
print(f'{new_spam = }\t{my_dict = }')

new_eggs = my_dict.setdefault('one', 1_000) #такой ключь есть, поэтому передаваемое значение будет игнорироваться, а в переменную запишется значение из списка
print(f'{new_eggs = }\t{my_dict = }')
```

>spam = None my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'five': None}
>
>eggs = 6 my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'five': None, 'six': 6}
>
>new_spam = 2 my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'five': None, 'six': 6}
>
>new_eggs = 1 my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'five': None, 'six': 6}

При вызове метода с одним аргументом отсутствующий ключ добавляется в
словарь. В качестве значения передаётся None. Если указать два аргумента и ключ
отсутствует, второй аргумент становится значением ключа и также добавляется в
словарь. При обращении к существующему ключу, словарь не изменяется
независимо от того указанные один или два аргумента

### Метод keys()

Метод keys возвращает объект-итератор dict_keys

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.keys())# выводит в списке все ключи словаря

for key in my_dict.keys(): # перебираем все ключи (for key in my_dict: - работает так же, т.к. по умолчанию словарь возвращает ключи для итерации в цикле)
print(key) # печатаем ключи

```

>dict_keys(['one', 'two', 'three', 'four', 'ten'])
>
>one
>
>two
>
>three
>
>four
>
>ten

Обычно объект не используют напрямую. Метод keys применяется в связке с
циклом for для перебора ключей словаря

**!Внимание! В отличии от списков, кортежей и строк доступ к
элементу-значению осуществляется не по индексу, а по ключу. При этом
начиная с версии Python 3.7 словарь сохраняет порядок добавления ключей. В каком порядке ключи были добавлены, в том порядке они будут возвращены в
случае итерации по словарю!**

### Метод values()

Метод values похож на keys, но возвращает значения в виде объекта итератора
dict_values, а не ключи

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.values()) #выведет список значений словаря

for value in my_dict.values(): #перебор значений словаря
print(value) # печать значений
```

>dict_values([1,2,3,4,10])
>
>1
>
>2
>
>3
>
>4
>
>10

### Метод items()

Если в цикле необходимо работать одновременно с ключами и значениями, как с
парами,  используют метод items.

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.items()) #выведет список всех пар ключ-значение

for tuple_data in my_dict.items(): # ПЛОХОЙ КОД преображаем полученное ключ-значение в кортеж
    print(tuple_data) # выводим кортеж
    print(f"{tuple_data[0] = } value before 100 - {100 - tuple_data[1]}") #выводим на печать первое значение кортежа и отнимаем от 100 второе значение из кортежа

for key, value in my_dict.items(): #хороший код/ перебираем одновременно ключ и значение
    print(f'{key = } value before 100 - {100 - value}') # выводим ключ и отнимаем от 100 значение ключа
```

Метод возвращает объект итератор dict_items. Если создать цикл for с одной
переменной между for и in, получим кортеж из пар элементов —ключа и значения.
Обычной используют две переменные в цикле: первая принимает ключ, а вторая
значение. Такой подход облегчает чтение кода и позволяют использовать ключ и
значение по-отдельности.

### Метод popitem()

Для удаления пары ключ значение из словаря используют метод popitem.

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
spam = my_dict.popitem() # удаляет последний элемент из словаря и записывает его в переменную
print(f'{spam = }\t{my_dict = }') # вывод значения переменной (в виде кортежа) и словаря
eggs = my_dict.popitem() # удаляет последний элемент из словаря и записывает его в переменную
print(f'{eggs = }\t{my_dict = }') # вывод значения переменной (в виде кортежа) и словаря
```

>spam = ('ten', 10) my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
>
>eggs = ('four', 4) my_dict = {'one': 1, 'two': 2, 'three': 3}

Так как словари сохраняют порядок добавления ключей, удаление происходит
справа налево, по методу LIFO. Элементы удаляются в обратном добавлению
порядке. Т.е. тот кто был добавлен в словарь первым, будет удалён последним.

**!Важно! Если измените значение у существующего ключа, положение
ключа в очереди не меняется, он не считается последним добавленным.!**

### Метод pop()

Метод pop удаляет пару ключ-значение по переданному ключу, либо

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
spam = my_dict.pop('two') #удаляет пару ключь-значение по ключу "two" и записывает значение ключа в переменную 
print(f'{spam = }\t{my_dict = }') # вывод переменной и словаря
err = my_dict.pop('six') # если ключа нет - KeyError: 'six'
err = my_dict.pop() # если не ввести значение в метод pop - TypeError: pop expected at least 1 argument, got 0
```

>spam = 2 my_dict = {'one': 1, 'three': 3, 'four': 4, 'ten': 10}

### Метод update()

Для расширение словаря новыми значениями используют метод update.

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
my_dict.update(dict(six=6)) # передаём в словарь ключ six со значением 6. Будет записан в конец словаря
print(my_dict)
my_dict.update(dict([('five', 5), ('two', 42)]))# передаём кортеж, который записываем в конец словаря. причём значение ключа two перезапишется на 42 и этот ключ остаётся на своей позиции
print(my_dict)
```

>{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'six': 6}
>
>{'one': 1, 'two': 42, 'three': 3, 'four': 4, 'ten': 10, 'six': 6, 'five': 5}

На вход метод получает другой словарь в любой из вариаций создания словаря.
Если передать существующий ключ, значение будет заменено новым.

Ещё один способ создать словари из нескольких других, который появился в новой
версии Python —вертикальная черта.

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
new_dict = my_dict | {'five': 5, 'two': 42} | dict(six=6) # создаём переменную в которую вкладываем основной словарь + словарь прописанный в ручную + словарь с парой ключь-значение
print(new_dict)
```

>{'one': 1, 'two': 42, 'three': 3, 'four': 4, 'ten': 10, 'five': 5, 'six': 6}

При перезаписи совпадающих ключей приоритет отдаётся словарю,
расположенному правее

# Пример работы со словарями

```py
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.setdefault('ten', 555))# 555 проигнорируется т.к. есть такой ключь со значением 10, поэтому в переменную запишется 10
print(my_dict.values()) # выведет 1 2 3 4 10
print(my_dict.pop('one')) # выведет 'one': 1 и удалит пару из словаря
my_dict['one'] = my_dict['four'] # создаст новый ключ one и добавит туда значение из ключа four
print(my_dict) # {'two': 2, 'three': 3, 'four': 4, 'ten': 10, 'one': 4}
```

# Множества set и frozenset

Ещё одна коллекция из коробки — множества. Множество — набор уникальных
неиндексированных элементов(значений). В Python есть два вида множеств:

**set** — { } изменяемое множество

**frozenset** — ( ) неизменяемое множество. Неизменяемое
множество позволяет вычислять хеш и может использоваться там, где разрешён лишь хешированный тип данных, например в качестве ключа словаря.

```py
my_set = {1, 2, 3, 4, 2, 5, 6, 7} # набор элементов сохранённые как множество
print(my_set) # 2-йка во второй раз не выведется, т.к. набор должен быть уникальным
my_f_set = frozenset((1, 2, 3, 4, 2, 5, 6, 7,)) # создание не изменяемого множества
print(my_f_set) # 2-йка во второй раз не выведется, т.к. набор должен быть уникальным
not_set = {1, 2, 3, 4, 2, 5, 6, 7, ['a', 'b']}# список изменяемый тип, поэтому будет ошибка - TypeError: unhashable type: 'list'
```

>{1, 2, 3, 4, 5, 6, 7}
>
>frozenset({1, 2, 3, 4, 2, 5, 6, 7})

Обратите внимание, что двойка передавалась в множества дважды, но хранится в
единственном экземпляре, как один из уникальных элементов

**!Важно! Элементом множества могут быть только неизменяемые типы
данных!**

## Методы множеств

add( ) - добавляет элемент

remove( ) - удаляет элемент

discard( ) - удаляет элемент

intersection( ) - пересечение множеств, &

union( ) - объединение множеств, |

difference( ) - разность множеств, -

### Метод add( )

Метод add работает аналогично методу списка append, т.е. добавляет один элемент
в коллекцию

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.add(9) # добавляет в конец множества элемент
print(my_set)
my_set.add(7) # игнорирует добавление т.к. элемент в множестве уже есть
print(my_set)
my_set.add(9, 10) # множество может добавлять только по 1-му элементу - TypeError: set.add() takes exactly one argument (2 given)
my_set.add((9, 10)) # добавляет элемент в начало множества в виде кортежа
print(my_set)
```

>{3, 4, 2, 5, 6, 1, 7, 9}
>
>{3, 4, 2, 5, 6, 1, 7}
>
>{(9, 10), 3, 4, 2, 5, 6, 1, 7}

Если попытаться добавить уже существующий элемент, множество не изменится.
При попытке добавить несколько элементов получим ошибку TypeError

**!Внимание! Если передать в метод add неизменяемую коллекцию,
например кортеж, коллекция будет добавлена как один целостный объект.!**

### Метод  remove

Для удаления элемента множества используют метод remove.

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.remove(5) # удаляет значение 5
print(my_set)
my_set.remove(10) # значение нет - KeyError: 10
```

>{1, 2, 3, 4, 6, 7}

При передаче несуществующего объекта получим ошибку KeyError

### Метод  discard

Метод discard работает аналогично remove — удаляет один элемент множества

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.discard(5)# удаляет значение 5
print(my_set)
my_set.discard(10) # проигнорирует команду т.к. нет элемента и не вызовет ошибку
```

>{1, 2, 3, 4, 6, 7}

В отличии от remove при попытке удалить несуществующий элемент discard не
вызывает ошибку. При этом множество не изменяется.

### Метод  intersection

Для получения пересечения множеств, т.е. множества с элементами, которые есть и
в левом и в правам множестве используют метод intersection

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.intersection(other_set)# ищем пересечения множеств и записываем в переменную
print(f'{my_set = }\n{other_set = }\n{new_set = }') # выводим оба множества и их песечения
```

> my_set = {1, 2, 3, 4, 5, 6, 7}
>
>other_set = {1, 42, 4, 314}
>
>new_set = {1, 4}

Новая версия Python позволяет получить пересечение множеств в следующей
записи c использованием символа &

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set & other_set # ищем пересечения множеств и записываем в переменную
print(f'{my_set = }\n{other_set = }\n{new_set = }')# выводим оба множества и их песечения
```

> my_set = {1, 2, 3, 4, 5, 6, 7}
>
>other_set = {1, 42, 4, 314}
>
>new_set = {1, 4}

**!Внимание! Исходные множества при пересечении не изменяются!**

### Метод  union

Для объединения множеств используется метод union

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.union(other_set)# в первом множестве вызываем метод union и передаём в аргументе второе множество
print(f'{my_set = }\n{other_set = }\n{new_set = }')# выводим оба множества и их объединение
```

> my_set = {1, 2, 3, 4, 5, 6, 7}
>
>other_set = {1, 42, 4, 314}
>
>new_set = {1, 2, 3, 4, 5, 6, 7, 42, 314}

Второй способ

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set_2 = my_set | other_set # объединям первое иножество И второе
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')# выводим оба множества и их объединение
```

> my_set = {1, 2, 3, 4, 5, 6, 7}
>
>other_set = {1, 42, 4, 314}
>
>new_set = {1, 2, 3, 4, 5, 6, 7, 42, 314}

На выходе получаем множество уникальных элементов из левого и правого
множеств. Более короткая запись объединения возможна при помощи
вертикальной черты.

### Метод  difference

Метод  difference удаляет из левого множества элементы правого.

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.difference(other_set)# берём первое множество, вызываем метод difference и в качестве аргумента передаём второе множество
print(f'{my_set = }\n{other_set = }\n{new_set = }')

# второй способ
new_set_2 = my_set - other_set # из первого множества отнимаем второе множество
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')
```

> my_set = {1, 2, 3, 4, 5, 6, 7}
>
>other_set = {1, 42, 4, 314}
>
>new_set = {2, 3, 5, 6, 7}

На выходе получаем множество элементов встречающихся только в левом
множестве. Более короткая запись возможно при помощи знака минус. Вычитаем
из левого элементы правого.

### Проверка на вхождение, in

Зарезервированное слово позволяет сделать проверку на вхождение элемента в коллекцию

Линейное время проверки (линейно движемся по элементам начиная с лева на право):

obj in list

obj in tuple

sub_str in str

Константное время проверки(проверка при помощи хеширования, т.е. быстро):

key in dict

obj in set

obj in frozenset

___

Для проверки входит ли элемент в множество используют зарезервированное
слово in

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
print(42 in my_set)# входит ли элемент 42 в множество
```

>False

**!Внимание! Слово in позволяет сделать проверку на вхождение и в других
коллекциях. Входит ли объект в list, tuple, является ли подстрока частью строки
str, встречается ли ключ в словаре. Для list, tuple, str проверка на вхождение
работает за линейное время O(n). Для dict, set, frozenset проверка работает за
константное время O(1).!**

# Проверка работы кода

```py
my_set = frozenset({3, 4, 1, 2, 5, 6, 1, 7, 2, 7})
print(len(my_set)) # длина 7 (есть повторяющиеся эл-ты)
print(my_set - {1, 2, 3}) # {4, 5, 6, 7}
print(my_set.union({2, 4, 6, 8})) # {1, 2, 3, 4, 5, 6, 7, 8}
print(my_set & {2, 4, 6, 8}) # {2, 4, 6}
print(my_set.discard(10)) # ошибка т.к. неизменяемое множество из которого нельзя удалять эелементы
```

### Классы bytes и bytearray

Неизменяемые байты и их изменяемой версии —
массив байт. Для отправки информации по каналам связи объекты не подойдут.
Даже текст не отправить. А вот пересылать байты — легко

#### метод encode()

Получение байт из строки

```py
text_en = 'Hello world!'
res = text_en.encode('utf-8') # записываем строку в виде кодировки utf-8
print(res, type(res))

text_ru = 'Привет, мир!'
res = text_ru.encode('utf-8')# записываем строку в виде кодировки utf-8
print(res, type(res))
```

>b'Hello world!'
>
>b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82,\xd0\xbc\xd0\xb8\xd1\x80!'

Строковой метод encode получает в качестве аргумента указание кодировки. На
выходе получаем строку байт. Функция print возвращает строковое представление
байт, сами ячейки памяти с электронами невозможно увидеть невооруженным
глазом

Префикс b говорит о том, что перед нами не строка, а байты. Если байт может быть
представлен как символ, т.е. он есть в семибитной кодировке ASCII. отображается
символ. В остальных случаях указывается приставка \x и слитно с ней
шестнадцатеричное представление байта

#### функция bytes() и bytearray()

bytes() - для получения набора не изменяемых байт

bytearray() - для получения набора изменяемых байт, которые можно модифицировать

```py
x = bytes(b'\xd0\x9f\xd1\x80\xd0\xb8')
y = bytearray(b'\xd0\x9f\xd1\x80\xd0\xb8')
print(f'{x = }\n{y = }')
```

>x = b'\xd0\x9f\xd1\x80\xd0\xb8'
>
>y = bytearray(b'\xd0\x9f\xd1\x80\xd0\xb8')

В качестве аргумента передаётся строковое представление нужным байт

Классы байт и массив байт обладают практически всеми методами строк. Кроме
того для массива байт доступны методы модификации списка list
