# Функции

Функция— фрагмент программного кода, к которому можно обратиться из другого
места программы. Функцию стоит представлять как чёрный ящик. В ящик попадают
данные, обрабатываются внутри (для пользователя функции не важно как они
обрабатываются) и ящик возвращает готовый результат. Подобные функции
обеспечивают простоту использования и возможности переносимости и
переиспользования в других частях проекта и даже в других проектах.
В Python можно создавать свои функции, использовать встроенные функции
интерпретатора, а также работать с функциями из модулей и пакетов стандартной
библиотеки и из устанавливаемых дополнений. На этой лекции подробно
поговорим про самописные функции и функции “из коробки”.

- Функциявпрограммировании,илиподпрограмма — фрагмент
программного кода, к которому можно обратиться из другого места
программы.
- Функциивысшегопорядка — это функции, которые работают с другими
функциями, либо принимая их в виде параметров, либо возвращая их

# Создание своих функций

Как и всё в Python функция является объектом. Можно сказать, что питоновская
функция это функция высшего порядка. Она может работать с другими функциями,
либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией
высшего порядка называется такая функция, которая принимает функцию-объект
как аргумент или возвращает функцию-объект в виде выходного значения.
Разберёмся в понятиях “вызываем” и “передаём” на уже знакомом примере кода

```py
a = 42
print(type(a), id(a)) #выводим тип и метонахождение в памяти
print(type(id)) # выводим тип id (не вызываем id, а передаём как объект)
```

><class 'int'> 1940719863312
>
><class 'builtin_function_or_method'>

Функция print вызывается с двумя аргументами - функциями. Каждая из
переданных в качестве аргументов функций: type и id так же вызываются с
переменной a в качестве аргумента.
Во втором случае функция type вызывается с функцией id в качестве аргумента.
При этом у id отсутствуют круглые скобки после имени. Мы не вызываем её, а
передаём как объект.
Ещё один пример передачи функции ниже.

```py
# плохой код
very_bad_programming_style = sum # вложили встроенную функцию сум в переменную как объект
print(very_bad_programming_style([1, 2, 3])) # передали аргументы и сложили их
```

>6

Передали в переменную встроенную функцию sum. Теперь переменную можно
вызывать как функцию суммирования.
Итого. Наличие круглых скобок после имени функции с аргументами или без них
внутри скобок — вызовфункции. Имя функции без скобок — передачафункции как
объекта.

# Определение функции

Для определения собственной функции используется зарезервированное слово def.
Далее указывается имя функции, круглые скобки с параметрами при
необходимости и двоеточием. Со следующей строки описывается тело функции как вложенный блок, т.е. с 4 отступами для каждой строки тела

```py
def my_func(): # определили функцию с пустыми параметрами
pass # зарезервированное слово которое ничего не делает
```

Определили функцию под именем my_func, которая не принимает аргументы и
ничего не делает.

**!PEP-8!Имена функций записываются в стиле snake_case как и имена
переменных!**

## Что такое pass

Похоже мы впервые встретили слово pass. Это зарезервированное слово, которое
ничего не делает. Используется в тех местах, где должен быть код для верной
работы программы, но его пока нет. Например мы не можем создать функцию без
тела. Нужна как минимум одна строка. В ней мы и написали pass

**!Внимание! Не злоупотребляйте использованием pass. Делать десятки
заготовок функций и классов с pass на будущее - не лучшая привычка.
Создавайте код по мере того как он вам нужен.!**

И сразу пару антипримеров использования pass которые выдают в программисте
новичка, радостно вставляющего новое слово повсюду в коде

```py
# плохой код
if a != 5:
    pass
else:
    a += 1
```

```py
# чуть лучше
if a == 5:
    a += 1
else:
    pass
```

```py
# хороший код
if a == 5:
a += 1
```

## Аргументы функции

Рассмотрим функцию с параметрами, т.е. принимающую на вход значения.
Вспомним как в школе решали квадратные уравнения. Заодно разберём
особенности создания функций в Python

```py
#вычисление дискриминанта
def quadratic_equations(a: int | float, b: int | float, c: int | float) -> tuple[float, float] | float | str: #определили функцию, где в параметры передали a,b,c которые будут цифрами (целыми или вещественными) и функция должна вернуть либо список с двумя вещественными числами или одно вещественное число или строку
    d = b ** 2 - 4 * a * c
    if d > 0:
        return (-b + d ** 0.5) / (2 * a), (-b - d ** 0.5) / (2 * a)
    elif d == 0:
        return -b / (2 * a)
    else:
        return 'Нет решений'


print(quadratic_equations(2, -3, -9))
```

> (3.0, -1.5)

При возвращении, указано, что может вернуться строка, но лучше сделать так

```py
def quadratic_equations(a: int | float, b: int | float, c: int |
float) -> tuple[float, float] | float | None:
```

А в последней строке вернём ничего:

```py
return None
```

Во первых воспользовались аннотацией типов. Указали, что на вход ожидаем три
значения целого или вещественного типа. Далее после стрелки указано, что
функция может вернуть кортеж с парой вещественных значений, т.е. два корня
уравнения, либо одно число когда дискриминант равен нулю, либо строку — фразу
нет решений

**!Внимание!Обратите внимание, что смешивать текст и числа в выводе —
не лучшая идея. Тот, кто будет использовать функцию будет вынужден делать
проверки на тип возвращаемого значения. Логичнее возвращать None, если
уравнение не имеет решений. !**

Без указания типов, функция выглядит так:

```py
def quadratic_equations(a, b, c):
```

**!PEP-8!Обратите внимание на пустые строки между функцией и её
вызовом. Рекомендуется оставлять по 2 пустых строки как после, так и до
функции!**

В нашем примере мы указали 3 позиционных параметра. При вызове функции
значения попадают в соответствующие позиции переменные. При попытке
передать отличное от указанного в описании функции число аргументов получим
ошибку TypeError.

```py
print(quadratic_equations(2, -3)) # TypeError:
quadratic_equations() missing 1 required positional argument: 'c'
```

## Изменяемые и неизменяемые аргументы

При передаче аргументов в функцию, стоит помнить изменяемого они типа или нет

**неизменяемый аргумент** - При изменении внутри функции остаётся прежним вне её

**изменяемый аргумент** - При изменении внутри функции изменяется и вне её

___

При передаче аргументов в функцию стоит помнить изменяемого типа объект или
нет. От этого зависит поменяем мы оригинал или он останется неизменным. Пример
работы с неизменяемыми переменными

```py
#не изменяемый аргумент
def no_mutable(a: int) -> int: #получает целое число и возвращает это число увеличенное на 1
    a += 1
    print(f'In func {a = }')
    return a


a = 42
print(f'In main {a = }')
z = no_mutable(a) # записываем в z результат работы функции
print(f'{a = }\t{z = }')
```

>In main a = 42
>
>In func a = 43
>
>a = 42 z = 43

Попытка изменить содержимое переменной внутри функции не привела к
изменению одноимённой переменной вне функции. Подробнее об областях
видимости далее в лекции.
А пока пример работы с изменяемыми объектами

```py
# изменяемые аргументы
def mutable(data: list[int]) -> list[int]: #получаем на вход список, где каждый элемент увеличиваем на 1
    for i, item in enumerate(data):
        data[i] = item + 1
    print(f'In func {data = }') 
    return data


my_list = [2, 4, 6, 8]
print(f'In main {my_list = }')
new_list = mutable(my_list) #записываем в переменную результат работы функции
print(f'{my_list = }\t{new_list = }')   
```

>In main my_list = [2, 4, 6, 8]
>
>In func data = [3, 5, 7, 9]
>
>my_list = [3, 5, 7, 9] new_list = [3, 5, 7, 9]

Изменение списка внутри функции привело к изменению списка вне функции.

**!Важно!В Python аргументы передаются внутри функции по ссылке на
объект. Следовательно изменяемый объект можно поменять. А при попытке
изменить неизменяемый создадим новый объект либо получим ошибку!**

### Возврат значения return

- Если указан один объект — возвращается именно этот объект.
- Если указано несколько значений через запятую, возвращается кортеж с
перечисленными значениями
- Если ничего не указано после return — возвращается None
- Если return отсутствует - автоматически возвращается None

После выполнения строки с командой return работа функции завершается, даже
если это не последняя строка в теле функции

```py
#высчитываение дискриминанта
def quadratic_equations(a, b, c):
    d = b ** 2 - 4 * a * c
    if d > 0:
        return (-b + d ** 0.5) / (2 * a), (-b - d ** 0.5) / (2 * a)
    if d == 0:
        return -b / (2 * a)
    return None


print(quadratic_equations(2, -3, -9))
```

>(3.0, -1.5)
Мы убрали else, т.к. последний возврат будет выполнен только в том случае, когда
не сработала ни одно условие выше и следовательно не получилось выйти из
функции через другой return. По этой же причине заменили elif на if.

### Неявный return

Иногда функции не возвращают значения. Точнее нет явного возврата. В этом
случае Python “мысленно” дописывает в качестве последней строки функции return
None. Немного изменим прошлый пример и посмотрим на новый результат

```py
def no_return(data: list[int]):# получаем на вход список целых чисел и увеличиваем на 1 каждое значение
    for i, item in enumerate(data):
        data[i] = item + 1
    print(f'In func {data = }') 


my_list = [2, 4, 6, 8]
print(f'In main {my_list = }')
new_list = no_return(my_list)#записываем в переменную результат работы функции
print(f'{my_list = }\t{new_list = }')
```

>In main my_list = [2, 4, 6, 8]
>
>In func data = [3, 5, 7, 9]
>
>my_list = [3, 5, 7, 9] new_list = None

Функция состоит из 4 строк кода. Можно представить, что в 5-й автоматически
дописался возврат None. Именно по этой причине в переменной new_list вместо
списка содержится None

**!Важно!Если функция ничего не возвращает, значит она возвращает
ничего — None.!**

### Значения по умолчанию

Функция может содержать значения по умолчанию для своих параметров.
Например:

```py
def quadratic_equations(a, b=0, c=0):
```

В качестве значения по умолчанию, нельзя использовать изменяемые типы: списки, словари, множества и т.п.

```py
def quadratic_equations(a, b=0, c=0):#в функцию небыла передан аргумент "с" поэтому по умолчанию подставился туда 0
    d = b ** 2 - 4 * a * c
    if d > 0:
        return (-b + d ** 0.5) / (2 * a), (-b - d ** 0.5) / (2 * a)
    if d == 0:
        return -b / (2 * a)


print(quadratic_equations(2, -9))
```

>(4.5, 0.0)

Переменная a должна быть передана в обязательном порядке. Если не передать 2-й
и/или 3-й аргумент, в переменные попадут нули как значения по умолчанию

**!PEP-8!Для указания значения по умолчанию используется знак
равенства. До и после такого равно пробелы не ставятся!**

ПЛОХО
**!В качестве значения по умолчанию нельзя указывать изменяемы типы: списки,
словари и т.п. Это приведёт к неожиданным результатам:!**

```py
def from_one_to_n(n, data=[]):# передаём в функцию по умолчанию изменяемый аргумент
    for i in range(1, n + 1):
        data.append(i)
    return data


new_list = from_one_to_n(5) #вызываем функцию и заполняем список цифрами от 1 до 5
print(f'{new_list = }')
other_list = from_one_to_n(7) # вызываем функцию ещё раз, что бы добавить в список числа от 1 до 7 (но функция сохранила в себе уже предыдущий вызов со списком и дополнит его)
print(f'{other_list = }')
```

>new_list = [1,2,3,4,5]
>
>other_list = [1,2,3,4,5,1,2,3,4,5,6,7]

other_list содержит в себе и новую последовательность и ту, которая была в списке
new_list. Связано это с тем, что значение по умолчанию задаётся один раз при
создании функции. Каждый вызов — работа со списком data и его очередное
изменение.
Если в качестве значения по умолчанию нужен изменяемый тип данных,
используют особый приём с None

```py
def from_one_to_n(n, data=None): #передаём в функцию по умолчанию None
    if data is None:
        data = []
    for i in range(1, n + 1):
        data.append(i)
    return data


new_list = from_one_to_n(5)#вызываем функцию и заполняем список цифрами от 1 до 5
print(f'{new_list = }')
other_list = from_one_to_n(7)# вызываем функцию ещё раз, что бы добавить в список числа от 1 до 7
print(f'{other_list = }')
```

>new_list = [1,2,3,4,5]
>
>other_list = [1,2,3,4,5,6,7]

Если изменяемый объект не передан, он создаётся по новой для каждого вызова
функции

### Позиционные ( / ) и ключевые ( * ) параметры

Косая черта / и звёздочка * разделяют позиционные и ключевые параметры

```py
def func(positional_only_parameters, /,positional_or_keyword_parameters, *, keyword_only_parameters):
    pass
```

Позиционные параметры - при передачи значения важна именно позиция. Т.е. в каком порядке через запятую перечислили переменные, в таком порядке и будут передаваться переменные

/ - символ разделитель, после которого начинается перечисление позиционнах параматров, в них могут входить и ключевые

\* - после звёздочки идут только ключевые параметры, которые принимаю значение только при явном указании ключа.

При указании параметров функции вначале идут позиционные параметры. При
вызове функции передаются значения без указания имени переменной-аргумента.
Косая черта не является переменной. Это символ разделитель. После неё могут
идти как позиционные, так и ключевые параметры. Далее символ разделитель
звёздочка указывает только на ключевые параметры.

**!Важно!Косая черта и звёздочка одновременно или по отдельности
могут отсутствовать при определении функции.!**

- Пример обычной функции:

```py
def standard_arg(arg):
    print(arg)

standard_arg(42) # позиционное значение (какое бы название аргумента не было в параметре функции, оно примет значение 42)
standard_arg(arg=42) # передча по ключу (значение попадёт только в параметр arg)
```

>42
>
>42

Функция может принимать значения по позиции и по ключу. Мы явно указали имя
переменной.

- Пример только позиционной функции

функция принимает только позиционные параметры

```py
def pos_only_arg(arg, /):
    print(arg) 

pos_only_arg(42) # позиционное значение
pos_only_arg(arg=42) # не позиционное значение, а ключевое, а они запрещены - TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'
```

>42

- Пример только ключевой функции:

 можем принимать только значения по ключу.

```py
def kwd_only_arg(*, arg):
    print(arg)


kwd_only_arg(42) # позиционное значения, они запрещены - выдаст ошибку
kwd_only_arg(arg=42)
```

>42

- Пример функции со всеми вариантами параметров

```py
def combined_example(pos_only, /, standard, *, kwd_only):
    print(pos_only, standard, kwd_only)

combined_example(1, 2, 3) #три переменные передаются как позиционные (ошибка говорит, что можем передать максимум только 2 как позиционные) - TypeError: combined_example() takes 2 positional arguments but 3 were given
combined_example(1, 2, kwd_only=3)# 2 переменные позиционные позиционные 1 ключевой
combined_example(1, standard=2, kwd_only=3) #1 позиционная, 2 ключевые
combined_example(pos_only=1, standard=2, kwd_only=3) # три переменные ключевые (ошибка говорит, что должен быть хотя бы один позиционный аргумент) - TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'
```

>1 2 3
>
>1 2 3

**!Важно!Если функция принимает несколько ключевых параметров,
порядок передачи аргументов может отличаться.!**

```py
def triangulation(*, x, y, z):
    pass


triangulation(y=5, z=2, x=11)
```

### Параметры *args и **kwargs

def func(*args): - принимает любое число позиционных аргументов

def func(**kwargs): - принимает любое число ключевых элементов

def func(\*args, \*\*kwargs): - принимает любое число позиционных и ключевых аргументов. При этом все позиционные аргументы передаются в \*args как кортеж, а в \*\*kwargs как словарь

**!Важно! Python в первую очередь смотрит на звёздочки, а не на имя переменной. Но
среди разработчиков приняты имена args и kwargs. Они делают код привычным, т.е.
повышают читаемость. Не используйте другие переменные!**

#### *args

```py
# вычисление средней арифметической
def mean(args): #специально без звёздочки
    return sum(args) / len(args)

print(mean([1, 2, 3]))
print(mean(1, 2, 3)) # попытка передать несколько значений подряд в один аргумент - TypeError: mean() takes 1 positional argument but 3 were given
```

>2.0

Функция может принять лишь один аргумент. В случае со списком проблем нет. Но
если перечислить элементы через запятую и не указать скобки - не передать
кортеж, получим ошибку

```py
def mean(*args): #теперь функция принимает любое число позиционных аргументов как кортеж
    return sum(args) / len(args)


print(mean(*[1, 2, 3]))# распаковка списка, каждый элемент передался отдельно
print(mean(1, 2, 3))# передача 3-х аргументов
```

>2.0
>
>2.0
>
>2.0

Теперь функция принимает любое число позиционных аргументов. Переменная args
превращается в кортеж. Можно сказать, что звёздочка упаковала все позиционные
аргументы в один кортеж

**!Внимание!При вызове функции со списком перед квадратными
скобками добавили звёздочку. Смыл её противоположный. Мы распаковали
список. Каждый элемент был передан в функцию по отдельности!**

#### **kwargs

принимает ключевые параметры и
возвращает словарь.

```py
def school_print(**kwargs): #может принять любое кол-во ключевых слов (пар ключ-значение)
    for key, value in kwargs.items(): #проходимся по ключам и словам в цикле
        print(f'По предмету "{key}" получена оценка {value}')

school_print(химия=5, физика=4, математика=5, физра=5) #передаём ключевые слова
```

>По предмету "химия" получена оценка 5
>
>По предмету "физика" получена оценка 4
>
>По предмету "математика" получена оценка 5
>
>По предмету "физра" получена оценка 5

**!Важно!Благодаря кодировке utf-8 мы смогли передать в функцию
переменные на русском языке!**

---
При написании своих функций стоит помнить о возможности сочетать позиционные
и ключевые переменные, специальные символы разделители / и *, а также
переменные*args и **kwargs

## Области видимости: global и nonlocal

Хорошая функция работает как чёрный ящик. Использует только переданные ей
значения и возвращает ответ. Но в Python функции могут обращаться к внешним
переменным без явной передачи в качестве аргумента

- локальная — код внутри самой функции, т.е. переменные заданные в теле
функции.
- глобальная — код модуля, т.е. переменные заданные в файле py содержащем
функцию.
- не локальная — код внешней функции, исключающий доступ к глобальным
переменным.

### Локальная область видимости

```py
def func(y: int) -> int:#принимает на вход целое число и возвращает целое число
    x = 100 # локальная переменная
    print(f'In func {x = }')#распечатываем "х" что бы убедиться, что она там есть 
    return y + 1 #увеличиваем принимаемое число на 1 и возвращаем


x = 42 #название переменной такое же, как и в функции (они разные)
print(f'In main {x = }') #выводим переменную
z = func(x) # вызываем функцию и передаём ей значение "х" и записываем в переменную z
print(f'{x = }\t{z = }')# выводим значения переменных "х" и "Z"
```

>In main x = 42
>
>In func x = 100
>
>x = 42 z = 43

```py
#демонстрация ошибки
def func(y: int) -> int:
    x += 100 # попытались взять внешнюю переменную "х" и увеличить на 100 - UnboundLocalError: local variable 'x' referenced before assignment.
    print(f'In func {x = }')
    return y + 1


x = 42
print(f'In main {x = }')
z = func(x)
print(f'{x = }\t{z = }')
```

Переменная x в теле функции и переменная x в основном коде - две разные
переменные. Локальная область видимости функции создала свою переменную.
Попробуем для эксперимента заменить строку с иксом на x += 100 В результате
получаем ошибку UnboundLocalError: local variable 'x' referenced before assignment.
Функция не смогла увеличить 42 на 100, т.к. переменные лишь для нас выглядят
одинаково. Чёрный ящик не увидел x без его явной передачи в функцию

### Глобальные переменные

```py
def func(y: int) -> int:
    global x #позволяет взять внешнюю переменную
    x += 100
    print(f'In func {x = }')
    return y + 1


x = 42
print(f'In main {x = }')
z = func(x)
print(f'{x = }\t{z = }')
```

>In main x = 42
>
>In func x = 142
>
>x = 142 z = 43

Теперь переменная x в теле функции объявлена как глобальная. Мы получили
доступ к внешнему иксу со значением 42 и смогли его увеличить. Изменение
затронуло как внешний, так и внутренний икс

**!Важно! Не стоит злоупотреблять командой global. В 9 из 10 случаев переменную
стоит передать как аргумент в функцию и вернуть ответ.!**

### Не локальные переменные

Выход на уровень выше, не доходя до глобальных переменных

```py
def main(a):#функция получила значение 42 и имеет внутри себя переменную и ещё одну функцию, которой передала аргумент 42
    x = 1

    def func(y): #получила аргумент 42 от функции main
        nonlocal x #получаем доступ к переменной "х" в функции main (на уровень выше)
        x += 100 # складываем 1 с 100
        print(f'In func {x = }') #
        return y + 1 # увеличиваем значение 42 на 1 и завершаем работу внутренней функции возвращая вместо себя 43

    return x + func(a) # 1 + 43 и завершение работы внешней функции возвращаея значение 44


x = 42
print(f'In main {x = }')
z = main(x)# вызываем функцию передавая значение 42
print(f'{x = }\t{z = }')
```

>In main x = 42
>
>In func x = 101
>
>x = 42 z = 44

Функция func вложена в функцию main. Благодаря команде nonlocal мы смогли
получить доступ к x = 1. В результат внутри func x увеличился до 101. В отличии от
команды global, мы не смогли увидеть внешний x = 42. nonlocal позволяет заглянуть
на верхний уровень вложенности, но не выходить на глобальные переменные
модуля

### Доступ к константам

Один из случаев когда обращение из тела функции к глобальной переменной
считается нормальным — доступ к константам.

```py
LIMIT = 1_000

def func(x, y):
    result = x ** y % LIMIT #обращение к констатнам допустимо
    return result

print(func(42, 73))
```

>112

Константа LIMIT является глобальной. При обращении к ней из функции
производится поиск в локальной области, т.е. в теле функции. Далее поиск
переходит на уровень выше, в глобальную область видимости модуля. Чтение
значений констант внутри функции будет работать без ошибок

# Анонимная функция lambda

Анонимные функции, они же лямбда функции — синтаксический сахар для обычных
питоновских функций с рядом ограничений. Они позволяют задать функцию в одну
строку кода без использования других ключевых слов.
Рассмотрим пример обычной функции и её аналог в виде лямбды

```py
def add_two_def(a, b): # стандартная функция
    return a + b


add_two_lambda = lambda a, b: a + b # лямбда функция делает тоже самое, что и стандартная


print(add_two_def(42, 3.14)) # вызов стандартной функции
print(add_two_lambda(42, 3.14)) # вызов лямбды функции
```

>45.14
>
>45.14

После зарезервированного слова lambda перечисляются параметры функции через
запятую. Далее ставят двоеточие и указывают значение, которое необходимо
вернуть без добавления return. Функция записывается в одну строку.

**!Важно!С точки зрения разработки присваивание анонимной функции
имени является неверным. Лямбды не должны использоваться для подобных
программных решений. Аналогичное предупреждение есть и в PEP-8.!**

Обычно лямбды используют там, где однократно нужна функция и нет смысла
заводить определение через def

```py
my_dict = {'two': 2, 'one': 1, 'four': 4, 'three': 3, 'ten': 10}
s_key = sorted(my_dict.items())#обычная сортировка, отсортирует по алфавиту ключей словаря
s_value = sorted(my_dict.items(), key=lambda x: x[1])#сортировака через лямбду может отсортировать по значению ключей
print(f'{s_key = }\n{s_value = }')
```

>s_key = [('four', 4), ('one', 1), ('ten', 10), ('three', 3), ('two', 2)]
>
>s_value = [('one', 1), ('two', 2), ('three', 3), ('four', 4), ('ten', 10)]

В первом случае словарь сортируется по ключам, т.е. по алфавиту. Во втором
благодаря лямбде указали сортировку по второму (индексация начинается с нуля)
элементу, т.е. по значению

# Документирование кода функций

документация
обычно пишется на английском языке, как универсальном для программистов из
любой страны. Вполне допустим и родной язык, если проект локальный. Но лучше
воспользоваться онлайн переводчиком и сразу привыкнуть к документированию на
английском.

Пояснения к однострочной строке документации

- Тройные кавычки используются, даже если строка помещается на одной
строке. Это позволяет легко расширить его позже.
- Закрывающие кавычки находятся на той же строке, что и открывающие. Это
выглядит лучше для однострочников.
- Нет пустой строки ни до, ни после строки документации.
- Строка документации — это фраза, заканчивающаяся точкой. Он описывает
действие функции или метода как команду
- Однострочная строка документации не должна повторять параметры
функции

```py
def max_before_hundred(*args): # функция ищет максимальное число не превышающая 100
"""Return the maximum number not exceeding 100."""
    m = float('-inf') #бесконечность
    for item in args:
        if m < item < 100:
            m = item
    return m


print(max_before_hundred(-42, 73, 256, 0))
```

> 73

**!Внимание!В программе использована переменная, а точнее константа
“минус бесконечность” float('-inf'). Это особая форма представления
бесконечности в памяти интерпретатора, аналогичная бесконечности из
модуля math!**

Если описание функции подразумевает больше подробностей, после первой строки
документации оставляют одну пустую. Далее в несколько строк даётся всё
необходимое описание. Закрывающие кавычки ставятся на отдельной строке, без
текста

```py
def max_before_hundred(*args):
    """Return the maximum number not exceeding 100.

    :param args: tuple of int or float numbers
    :return: int or float number from the tuple args
    """
    ...
```

Подобная запись автоматические помещает текст в переменную \*\*doc**. Описание
функции можно будет получить через вызов справки help с передачей функции в
качестве аргумента

```py
help(max_before_hundred)
```

# Функции “из коробки”

В Python есть ряд встроенных функций. Они доступны всегда, без импортов и
других подготовительных операций. Перечислим их в алфавитном порядке:

>abs(), aiter(), all(), any(), anext(), ascii(), bin(), bool(), breakpoint(), bytearray(), bytes(),
callable(), chr(), classmethod(), compile(), complex(), delattr(), dict(), dir(), divmod(),
enumerate(), eval(), exec(), filter(), float(), format(), frozenset(), getattr(), globals(),
hasattr(), hash(), help(), hex(), id(), input(), int(), isinstance(), issubclass(), iter(), len(),
list(), locals(), map(), max(), memoryview(), min(), next(), object(), oct(), open(), ord(),
pow(), print(), property(), range(), repr(), reversed(), round(), set(), setattr(), slice(),
sorted(), staticmethod(), str(), sum(), super(), tuple(), type(), vars(), zip().

**!Важно!Не используйте имена встроенных функций в качестве имён
переменных! PEP-8!Если очень хочется, добавляйте к имени переменной символ
подчёркивания. Не sum, a sum_. Не max, а max_!**

## map(), filter(), zip()

map(function,iterable) - принимает на вход функцию и последовательность.
Функция указанная в качестве второго параметра применяется к каждому элементу последовательности и возвращает map
итератор

filter(function,iterable)— принимает на вход функцию и последовательность, функция указанная в качестве второго параметра применяется на каждый элемент последовательности и возвращает True / False. Если
функция возвращает истину, элемент остаётся в последовательности. Как и map
возвращает объект итератор

zip(*iterables,strict=False)— принимает несколько последовательностей и итерируется по ним параллельно. В параметре strict по умолчанию значение False, если поставить True - то получим ошибку если в последовательностях разное число элементов. Если параметр не менять, то zip остановится когда кончится одна из последовательностей

### Функция map()

map(function,iterable) - принимает на вход функцию и последовательность.
Функция указанная в качестве второго параметра применяется к каждому элементу последовательности и возвращает map
итератор

```py
texts = ["Привет", "ЗДОРОВА", "привеТствую"]
res = map(lambda x: x.lower(), texts) #map принимает первый параметр лямбду с аргументом "х", и у этого аргумента будет вызывать метод lower() - приводить весь текст к нижнему регистру. во втором параметре map принимает список
print(*res) #распаковка из map - объекта
```

>привет здорова привет

В качестве функции использовали лямбду для вызова метода lower у каждого из
переданных объектов. Объект итератор res был распакован в функцию print через
символ “звёздочка”

### Функция filter()

filter(function,iterable)— принимает на вход функцию и последовательность, функция указанная в качестве второго параметра применяется на каждый элемент последовательности и возвращает True / False. Если
функция возвращает истину, элемент остаётся в последовательности. Как и map
возвращает объект итератор

```py
#для фильтра функция должна возвращать только истину или ложь
numbers = [42, -73, 1024]
res = tuple(filter(lambda x: x > 0, numbers)) #объявляем кортеж и в кортеже пишем функцию filter которая принимает 2 параметра: 1. лямбду которая проверяет, больше ли число 0. 2. список
print(res) #что бы не использовать звёздочку для распаковки, перед функцие filter сразу объявили кортеж
```

>(42, 1024)

```py
Лямбда фильтрует элементы больше нуля. Функция tuple преобразует итератор к
кортежу с положительными числами.
```

### Функция zip()

zip(*iterables,strict=False)— принимает несколько последовательностей и итерируется по ним параллельно. В параметре strict по умолчанию значение False, если поставить True - то получим ошибку если в последовательностях разное число элементов. Если параметр не менять, то zip остановится когда кончится одна из последовательностей

```py
names = ["Иван", "Николай", "Пётр"]
salaries = [125_000, 96_000, 109_000]
awards = [0.1, 0.25, 0.13, 0.99] #т.к. по умолчанию в zip стоит strict=False, то 4-е значение будет просто проигнорировано

for name, salary, award in zip(names, salaries, awards):#зип принимает 3 разных списка и параллельно друг другу итерирует их 
    print(f'{name} заработал {salary:.2f} денег и премию {salary * award:.2f}')
```

>Иван заработал 125000.00 денег и премию 12500.00
>
>Николай заработал 96000.00 денег и премию 24000.00
>
>Пётр заработал 109000.00 денег и премию 14170.00

Последовательно получаем имена, зарплату и процент премии из каждого списка.
Итерация идёт слева направо.

## Функции max(), min(), sum()

max(iterable, *[, key, default]) или max(arg1, arg2,*args[, key]) - функция принимает на вход итерируемую последовательность или несколько позиционных элементов и ищет максимальное из них.

min(iterable, *[, key, default]) или min(arg1, arg2,*args[, key]) - функция работает аналогично max, но ищет минимальный элемент

sum(iterable, /, start=0) - Функция принимает объект итератор и подсчитывает сумму всех элементов. Ключевой аргумент start задаёт начальное значение для суммирование

### Функция max()

max(iterable, *[, key, default]) или max(arg1, arg2,*args[, key])
Функция принимает на вход итерируемую последовательность или несколько
позиционных элементов и ищет максимальное из них. Ключевой параметр key
указывает на то, какие элементы необходимо сравнить, если объект является
сложной структурой. Отдельно параметр default используется для возврата
значения, если на вход передана пустой итератор

```py
lst_1 = []
lst_2 = [42, 256, 73]
lst_3 = [("Иван", 125_000), ("Николай", 96_000), ("Пётр",
109_000)]
print(max(lst_1, default='empty')) # передаём пустой список и что бы не выводилась ошибка, задаём default='empty' (вывод по умолчанию, можно указать что угодно)
print(max(*lst_2)) # распаковка списка и сразу вывод максимального числа
print(max(lst_3, key=lambda x: x[1]))# в функции задаём 2 параметра 1 - это список кортежей, 2-й - это лямбда. задаём лямбде поиск по второму элементу в кортеже
```

>empty
>
>256
>
>("Иван", 125_000)

В первом случае передана пустая последовательность и функция вернула строку
empty.
Во втором — распаковали список и нашли максимальное число
В третьем ищем максимальное среди трёх кортежей по элементу с индексом один,
т.е. по числу

### Функция min()

min(iterable, *[, key, default]) или min(arg1, arg2,*args[, key])
Функция работает аналогично max, но ищет минимальный элемент.

```py
lst_1 = []
lst_2 = [42, 256, 73]
lst_3 = [("Иван", 125_000), ("Николай", 96_000), ("Пётр",
109_000)]
print(min(lst_1, default='empty'))# передаём пустой список и что бы не выводилась ошибка, задаём default='empty' (вывод по умолчанию, можно указать что угодно)
print(min(*lst_2))# распаковка списка и сразу вывод минимального числа
print(min(lst_3, key=lambda x: x[1]))# в функции задаём 2 параметра 1 - это список кортежей, 2-й - это лямбда. задаём лямбде поиск по второму элементу в кортеже
```

>empty
>
>42
>
>("Николай", 96_000)

### Функция sum()

sum(iterable, /, start=0)
Функция принимает объект итератор и подсчитывает сумму всех элементов.
Ключевой аргумент start задаёт начальное значение для суммирования.

```py
my_list = [42, 256, 73]
print(sum(my_list)) # суммирует все элементы списка
print(sum(my_list, start=1024)) # суммирует все значения в списке и прибавляет к ним значение из start
```

>371
>
>1395

## Функции all(), any()

all(iterable) - Функция возвращает истину, если все элементы последовательности являются
истиной.

any(iterable) - Функция возвращает истину, если хотя бы один элемент последовательности
являются истиной

### Функции all()

all(iterable)
Функция возвращает истину, если все элементы последовательности являются
истиной.

```py
# как эта функция выглядит, если написать её самому
def all(iterable):
    for element in iterable: #перебираем каждый элемент
        if not element: # если элемент не итерабелен
            return False # вернуть false
    return True # иначе истину
```

Функция all обычно применяется с результатами каких-то вычислений, которые
должны быть истинными или ложными

```py
numbers = [42, -73, 1024]
if all(map(lambda x: x > 0, numbers)): #2 параметра: 1-лямбда в которой прописываем логику(если число больше нуля) и 2-список
    print('Все элементы положительные')
else:
    print('В последовательности есть отрицательные и/или нулевыеэлементы')
```

> последовательности есть отрицательные и/или нулевыеэлементы

Функция map заменила числа на True и False, далее all проверила все ли элементы
больше нуля или есть как минимум один не более нуля

### Функция any()

any(iterable)
Функция возвращает истину, если хотя бы один элемент последовательности
являются истиной. На Python создание функции any выглядело бы так:

```py
# как эта функция выглядит, если написать её самому
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
```

Функция any работает аналогично all. Но если all можно представить как if c
цепочкой and, то any — это if с цепочкой or

Функция map заменила числа на True и False, далее all проверила все ли элементы
больше нуля или есть как минимум один не более нуля

```py
numbers = [42, -73, 1024]
if any(map(lambda x: x > 0, numbers)):#2 параметра: 1-лямбда в которой прописываем логику(если число больше нуля) и 2-список
    print('Хотя бы один элемент положительный')
else:
    print('Все элементы не больше нуля')
```

>Хотя бы один элемент положительный

**!Важно!Все перечисленные выше функции имеют линейную асимптотику
O(n), т.е. функция проходит последовательность от начала до конца прежде чем
вернуть результат!**

## Функции chr(), ord()

chr(integer)
Функция возвращает строковой символ из таблицы Юникод по его номеру. Номер -
целое число от 0 до 1_114_111.

ord(char)
Функция принимает один символ и возвращает его код в таблице Юникод.

### Функция chr()

chr(integer)
Функция возвращает строковой символ из таблицы Юникод по его номеру. Номер -
целое число от 0 до 1_114_111.

```py
print(chr(97))
print(chr(1105))
print(chr(128521))
```

>a
>
>ё
>
>😉

### Функция ord()

ord(char)
Функция принимает один символ и возвращает его код в таблице Юникод

```py
print(ord('a'))#английская а
print(ord('а'))#русская а
print(ord('😉'))
```

>97
>
>1072
>
>128521

Функции ord и chr выполняют противоположные действия

## Функции locals(), globals(), vars()

locals()
Функция возвращает словарь переменных из локальной области видимости на
момент вызова функции

Функция globals()
Функция возвращает словарь переменных из глобальной области видимости, т.е. из
пространства модуля

Функция vars()
Функция без аргументов работает аналогично функции locals(). Если передать в vars
объект, функция возвращает его атрибут **dict**. А если такого атрибута нет у
объекта, вызывает ошибку TypeError

### Функция locals()

Функция возвращает словарь переменных из локальной области видимости на
момент вызова функции

```py
SIZE = 10 #находится за пределами ф. поэтому на момент вызова ф. локалс не выведется

def func(a, b, c): #при вызове ф. передаётся 3 параметра a,b,c
    x = a + b # создаётся переменная х в которую вкладываем сумму a и b
    print(locals()) # вызываем и печатаем функцию локалс
    z = x + c # z не попадает в распечатку ф. локалс т.к. создаётся после вызова ф.
    return z

func(1, 2, 3)
```

>{'a': 1, 'b': 2, 'c': 3, 'x': 3} - словарь нельзя изменять

Функция вернула словарь с переменными a, b, c, x и их значениями. Константа SIZE
не попала в вывод, т.к. не входит в локальную область функции. Так же в словаре
отсутствует переменная z. Она была впервые создана после вызова функции locals.

**!Важно!Python игнорирует попытки обновления словаря locals. Для
изменения значений переменных надо обращаться к ним напрямую!**

### Функция globals()

Функция возвращает словарь переменных из глобальной области видимости, т.е. из
пространства модуля

```py
SIZE = 10

def func(a, b, c): # все переменные внутри функции локальные
    x = a + b
    print(globals()) # выведет только глобальную переменную SIZE = 10
    z = x + c
    return z

print(globals())# выведет только глобальную переменную SIZE = 10
print(f'{func(1, 2, 3) = }')
```

>{''\_\_name__': '\_\_main__', '\_\_doc__': None, '\_\_package__': None, ... 'SIZE': 10 ...}
>
>{''\_\_name__': '\_\_main__', '\_\_doc__': None, '\_\_package__': None, ... 'SIZE': 10 ...}
>
>func(1, 2, 3) = 6

Функция не сохраняет в словаре локальные переменные функций, даже если будет
вызвана из тела функции.
В словаре от globals содержаться и дандер переменные модуля. Они нужны Python
для правильной работы кода

**!Внимание!Если вызвать функцию locals() из основного кода модуля, а не
из функции, результат будет аналогичен работе функции globals()!**

```py
x = 42 # создаём переменную "х" со значением 42
glob_dict = globals() # сохраняем словарь функции globals в переменную
glob_dict['x'] = 73 # обращаемся по ключу "х" и заменяем значение на 73
print(x)
```

> 73 - можем изменить значение в отличии от словаря локалс

В отличии от locals словарь globals позволяет изменить значение переменной

### Функция vars()

Функция без аргументов работает аналогично функции locals(). Если передать в vars
объект, функция возвращает его атрибут \_\_dict__. А если такого атрибута нет у
объекта, вызывает ошибку TypeError.

```py
print(vars(int)) # смотрим содержимое словаря int
```

>{'\_\_new__': <built-in method \_\_new__ of type object at 0x00007FF9444F6E30>, '\_\_repr__': <slot wrapper '\_\_repr__' of 'int' objects>, '\_\_hash__': <slot wrapper '\_\_hash__' of 'int' objects>, ... }
