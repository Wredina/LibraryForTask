# Итераторы и Генераторы

- Итератор— это объект, представляющий поток данных; объект возвращает
данные по одному элементу за раз. Итератор Python должен поддерживать
метод с именем \_\_next__ (), который не принимает аргументов и всегда
возвращает следующий элемент потока.
- Генератор— это объект, который сразу при создании не вычисляет значения
всех своих элементов. Он хранит в памяти только последний вычисленный
элемент, правило перехода к следующему и условие, при котором
выполнение прерывается. Вычисление следующего значения происходит
лишь при выполнении метода next(). Предыдущее значение при этом
теряется.
- Факториал— функция, определённая на множестве неотрицательных целых
чисел. Название происходит от лат. factorialis — действующий, производящий,
умножающий; обозначается n!, произносится эн факториал. Факториал
натурального числа n определяется как произведение всех натуральных
чисел от 1 до n включительно

# Однострочники

Python позволяет разработчикам решать задачи быстрее, чем с использованием
других языков. Одна из причин — возможность писать меньше кода для получения
результата.

## Полезные однострочники

- Обмен значения переменных

```py
a = 42
b = 73
a, b = b, a
print(f'{a = }\t{b = }')
```

>a = 73
>
>b = 42

Мы поменяли местами содержимое переменных без создания дополнительных, в
одну строку.

## Распаковка

Обычная распаковка

```py
a, b, c = последовательность
```

Распаковка с упаковкой (упаковка со звёздочкой)

```py
a, *b, c = последовательность
```

Распаковка со звёздочкой

```
*последовательность
```

### Обычная распаковка

```py
a, b, c = input("Три символа: ")# вводим 123 и сразу произойдёт распаковка строки на три элемента
print(f'{a = } { b = } {c = }')
```

>a = '1' b = '2' c = '3'

Как вы помните функция input возвращает строку str. Указав не одну переменную, а
три мы распаковываем строку из 3-х символов в три отдельные переменные.

```py
a, b, c = ("один", "два", "три",) #произойдёт распаковка кортежа на три элемента
print(f'{a=} {b=} {c=}')
```

> a="один" b="два" c="три"

Аналогичным образом можно распаковать кортеж из трёх элементов в три
переменные. Со списком list, множеством set и прочими коллекциями будет
работать аналогично

```py
a, b, c = {"один", "два", "три", "четыре", "пять"} #если ввести больше значений чем переменных
print(f'{a=} {b=} {c=}') # ValueError: too many values to unpack (expected 3)
```

Если количество переменных слева от равенства не совпадает с количеством
элементов последовательности Python вернёт ошибку

### Распаковка с упаковкой (упаковка со звёздочкой)

Для упаковки может применяться символ “звёздочка” перед именем переменной.
Такая переменная превратиться в список и соберёт в себя все значения, не
поместившиеся в остальные переменные.

```py
data = ["один", "два", "три", "четыре", "пять", "шесть", "семь",]

a, b, c, *d = data 
print(f'{a=} {b=} {c=} {d=}')# a="один" b="два" c="три" d=["четыре", "пять", "шесть", "семь"]

a, b, *c, d = data
print(f'{a=} {b=} {c=} {d=}')# a="один" b="два" c=["три", "четыре", "пять", "шесть"] d="семь"

a, *b, c, d = data
print(f'{a=} {b=} {c=} {d=}')# a="один" b=["два", "три", "четыре", "пять"] c="шесть" d="семь"

*a, b, c, d = data
print(f'{a=} {b=} {c=} {d=}') # a=["один", "два", "три", "четыре"] b="пять" c="шесть" d="семь"
```

Элементы коллекции попадают в переменные в зависимости от того, какая из
переменных отмечена звёздочкой

**!Важно!Звёздочкой можно отметить только одну переменную из
перечня.!**

Если нам нужна часть данных в переменных, а упакованный список в дальнейших
расчётах не участвует, в качестве переменной используют подчеркивание

```py
link =
'https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another'
prefix, *_, suffix = link.split('/') #при помощи сплита разделяем ссылку по разделителю /, в переменную префикс попадает самый первый элемент строки, в суффикс последний элемент, а в *_ - всё остальное ( _ - используется для значений, которыми не будем пользоваться)
print(f'{prefix = } {suffix = }')
```

>prefix = 'htpps' suffix = 'programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another'

### Распаковка со звёздочкой

Ещё один способ применения звёздочки — распаковка элементов коллекции.
Длинный вариант вывода элементов последовательности в одну строку с
разделителем табуляцией

```py
#пример обычной распаковки, без звёздочки
data = [2, 4, 6, 8, 10, ]
for item in data:
    print(item, end='\t') # что бы эл-ты не выводились в столбик, вместо переноса строки задан таб
```

>2  4   6   8   10

И аналогичная операция в одну строку с распаковкой:

```py
data = [2, 4, 6, 8, 10, ]
print(*data, sep='\t') # между элементами задан таб
```

>2  4   6   8   10

## Множественное присваивание и сравнение

Допустимо только для неизменяемых типов данных

Множественное присваивание

```a = b = c = 0```

```a, b, c = 1, 2, 3```

Множественное сравнение

```a == b == c```

```a < b < c```

### Множественное присваивание

Если несколько переменных должны получить одинаковые значение, можно
объединить несколько строк в одну

```py
a = b = c = 0
a += 42
print(f'{a=} {b=} {c=}')
```

>a=42 b=0 c=0

Подобная запись допустима только с неизменяемыми типами данных. В противном
случае изменение одной переменной приведёт к изменению и других.

```py
# ПЛОХО демонстрация с изменяемыми типами
a = b = c = {1, 2, 3} #т.к. множество - изменяемый тип, то изменения в одной переменной повлекут изменения во всех
a.add(42)
print(f'{a=} {b=} {c=}')
```

>a={1, 2, 3, 42} b={1, 2, 3, 42} c={1, 2, 3, 42}

Другой вариант множественного присваивания похож на обмен переменных
местами

```py
a, b, c = 1, 2, 3
print(f'{a=} {b=} {c=}')
```

>a=1 b=2 c=3

Число элементов в левой части должно совпадать с числом элементов справа от
равно.

А если в левой части указать лишь одну переменную, получим кортеж.

```py
t = 1, 2, 3 #если указать значения через запятую!
print(f'{t=}, {type(t)}') # значения сохранятся в переменную как кортеж
```

>t=(1,2,3), <class 'tuple'>

**!Важно!Тип объектов может отличаться. Не только целые числа, как в
примерах. Строки, любые коллекции. Ошибки это не вызовет. Но для
повышения читаемости рекомендуется не смешивать разные типы данных при
присваивании одной строкой.!**

### Множественное сравнение

Аналогично присваиванию можно сравнить несколько переменных внутри
конструкции if.

```py
a = b = c = 42
if a == b == c: # if a == b and b == c:
    print('Полное совпадение')
```

>Полное совпадение

Запись становится короче, т.к. исключается команда and внутри сравнения.
Работает подобная запись не только с проверкой на равенство, но и с другими
операциями

```py
a = b = c = 42

if a < b < c:
    print('b больше a и меньше c')
```

Проверяем, что b больше a и b меньше c

## Плохие однострочники

А теперь несколько примеров плохого кода. Да, он будет работать, т.к. Python
прощает ошибки. Но читать такой код будет сложно. И есть большая вероятность,
что коллеги по проекту не простят подобный код

```py
a = 12; b = 42; c = 73
if a < b < c: b = None; print('Ужасный код') # после двоеточия нет перехода на новую строку, стоит точка с запятой после None и сразу идёт принт
```

>Ужасный код

Перечислили несколько операций присваивания через точку с запятой в одной
строке. Такая запись противоречит PEP-8. Скорее это защита от поломки, если
разработчик пришёл из другого языка и привык ставить точку с запятой.
Во второй строке не перешли на новую строку с отступами после двоеточия. Так же
идёт против PEP-8. Кроме того подобные условия, циклы или функции не смогут
содержать более одной вложенной строки. Если конечно не начать добавлять точки
с запятой.

**!Оченьважно!Отсутствие перехода на новую строку после двоеточия и
запись нескольких строк кода в одну через точку с запятой — плохой стиль
программирования. Будьте готовы получить “неудовлетворительно” за
подобные антипаттерны во время учёбы и отказ в трудоустройстве во время
собеседования!!**

# Пример использования кода

```py
data = {10, 9, 8, 1, 6, 3}# т.к. это множество, произойдёт хэщирование
a, b, c, *d, e = data #все элементы множества расположатся по возрастанию и так и запишутся
print(a, b, c, d, e)
```

>1 2 3 (8,9) 10

# Итераторы

С итераторами мы уже знакомы. Любая Python коллекция будь то список, словарь,
строка и т.п. предоставляют интерфейс итератора. Если коллекцию можно передать
в цикл for in для последовательного перебора элементов, значит коллекция
итерируемая, поддерживает интерфейс итарации. При этом у каждой коллекции
может быть свой интерфейс. Списки, строки, кортежи возвращают элементы слева
направо, от нулевого индекса к последнему. Множества возвращают элементы в
случайном порядке.

**!Секрет!На самом деле порядок вывода элементов множества не
случаен. Он зависит от результата работы встроенного хэша. Хэш функция
определяет в какое место множества будет помещён элемент и возвращает их
в порядке возрастания хеша.!**

Просто этот порядок может не совпадать со значением элементов.
Что касается словарей, они поддерживают сразу три интерфейса итерации: по
ключам, по значениям и по парам ключ-значение. Вспомните методы keys, values и
items

## Функции iter() и next()

В Python объект является итерируемым, если поддерживает работу дандер методов
\_\_iter__(или \_\_getitem__) и \_\_next__. Первый метод должен возвращать объект
итератор. Второй, next —возвращает очередной элемент коллекции или
исключение StopIteration. Рассмотрим подробнее

iter(object[, sentinel]) - object является обязательным
аргументом. Если объект не реализует интерфейс итерации через методы \_\_iter__
или \_\_getitem__, получим ошибку TypeError

next(iterator[, default]) - На вход функция принимает
итератор, который вернула функция iter. Каждый вызов функции возвращает
очередной элемент итератора

### Функция iter

Функция iter имеет формат iter(object[, sentinel]).
Если объект не реализует интерфейс итерации через методы \_\_iter__
или \_\_getitem__, получим ошибку TypeError

```py
a = 42 # целое число
iter(a) #т.к одно целое число не может быть итерабельным, выдаст ошибку TypeError: 'int' object is not iterable
```

Получим итератор списка

```py
data = [2, 4, 6, 8] # создаёт список
list_iter = iter(data) # передаём список функции итер
print(list_iter) #выведет, что объект итеррируем
```

><list_iterator object at 0x0000025383D29400>

Напрямую извлечь данные из итератора не получится. Python сообщает, что
переменная list_iter указывает на <list_iterator object at 0x0000025383D29400>, т.е.
объект итератор списка. Для кортежа функция iter вернёт tuple_iterator, для
множеств set_iterator, а например для dict.items() вернётся dict_itemiterator.
Один из простейших способов получить элементы - распаковать итератор через
звёздочку.

```py
data = [2, 4, 6, 8] # создали список
list_iter = iter(data) # передали список в функцию итер
print(*list_iter) # выведет последовательно значения списка
print(*list_iter) # ничего не выведет
```

>2 4 6 8

**!Внимание!Обратите внимание, что итератор является одноразовым
объектом. Получив все элементы коллекции один раз он перестаёт работать.
Для повторного извлечения элементов необходимо создать новый итератор.!**

Второй параметр функции iter — sentinel передают для вызываемых
объектов-итераторов. Параметр указывает в какой момент должна быть завершена
итерация, при совпадении возвращаемого значения со значением sentinel

```py
# iter(object[, sentinel]
data = [2, 4, 6, 8]
list_iter = iter(data, 6) # список не яаляется функцией, его нельзя вызвать - TypeError: iter(v, w): v must be callable
```

Список не является функцией, его нельзя вызвать. Получили ошибку TypeError.
Один из вариантов работы функции iter с двумя параметрами — чтение бинарного
файла блоками фиксированного размера до тех пор, пока не будет достигнут конец
файла.

```py
import functools

f = open('mydata.bin', 'rb') #открытие файла 'mydata.bin' на чтение (в этом файле пара строк текста)
for block in iter(functools.partial(f.read, 16), b''): #для каждого блока в функции итер, которая в качестве первого аргумента получает функцию partial и использует чтение файла блоками по 16 байт, 2-й аргумент b'' - пустая бинарная строка
    print(block)
f.close()
```

>b'Hello world!\r\nHo'
>
>b'w are you&\r\nCall'

Открыли бинарный файл на чтение байт. В цикле считываем блоки по 16
байт и выводим их на печать. Чтение прекратиться после считывание пустого байта
b’’, окончания файла. После этого выходим из цикла и закрываем файл

### Функция next

Функция next имеет формат next(iterator[, default]). На вход функция принимает
итератор, который вернула функция iter. Каждый вызов функции возвращает
очередной элемент итератора

```py
#работа без default
data = [2, 4, 6, 8]
list_iter = iter(data)
print(next(list_iter))# получает первый объект из итератора и возвращает его
print(next(list_iter))# получает следующий элемент
print(next(list_iter))# ...
print(next(list_iter))
print(next(list_iter))# StopIteration
```

>2
>
>4
>
>6
>
>8

При завершении элементов выбрасывается исключение StopIteration. Данное
исключение служит указанием циклу for in о завершении работы. Каждый раз когда
происходит перебор коллекции в цикле создаётся исключение. Но цикл
обрабатывает его как сигнал для завершения итерации и перехода к следующему
блоку кода. Исключение не останавливает программу.
Второй параметр функции next нужен для возврата значения по умолчанию вместо
выброса исключения StopIteration

```py
# работа с default
data = [2, 4, 6, 8]
list_iter = iter(data)
print(next(list_iter, 42)) 
print(next(list_iter, 42))
print(next(list_iter, 42))
print(next(list_iter, 42))
print(next(list_iter, 42))#по окончанию списка, будет выводиться значение по дефолту
print(next(list_iter, 42))
```

>2
>
>4
>
>6
>
>8
>
>42
>
>42

Промежуточный итог. Любая коллекция в Python поддерживает интерфейс
итерации, т.е. перебор элементов в цикле for in. Для этого она возвращает итератор,
который последовательно возвращает следующий, next элемент. Отдельно
управлять итерацией позволяют функции iter и next. Кроме того при ООП можно
создавать свои классы, поддерживающие итерации. Подробнее об этом в рамках
соответствующей лекции.

# Пример работы кода

```py
data = {"один": 1, "два": 2, "три": 3}
x = iter(data.items()) 
print(x)#<dict_iterator object at 0x0000025383D29400>
y = next(x)
print(y)# (один, 1)
z = next(iter(y))
print(z) # один
```

# Генераторы

**!Важно!Генератор не обяз быть однострочником!**

Генераторы похожи на итераторы тем, что возвращают некую последовательность
значений. Отличие в том, что итераторы чаще всего возвращают коллекции. Т.е.
коллекция хранит все данные и тратит на хранение память. Далее коллекция
возвращает хранимые элементы через интерфейс итерации. Генераторы не хранят
данные в памяти, а вычисляют их по мере необходимости, чтобы вернуть очередное
значение

С одним из генераторов мы уже знакомы. Это объект, возвращаемый функцией
range. При создании генератора мы указываем диапазон перебираемых целых
чисел, но не сохраняем их в памяти. Каждое из значений генерируется на
очередном витке цикла

```py
# функция рэндж является функцией генератора
a = range(0, 10, 2) #итерируем от 0 до 10 в 2 шага
print(f'{a=}, {type(a)=}, {a.__sizeof__()=}, {len(a)}')# увидим, что это класс рэндж, и это занимает 48 байт и хранит 5 значений

b = range(-1_000_000, 1_000_000, 2)
print(f'{b=}, {type(b)=}, {b.__sizeof__()=}, {len(b)}')# увидим, что это класс рэндж, и это занимает тоже 48 байт и хранит 1000000 значений
```

>a=range(0, 10, 2), type(a)=<class 'range'>, a.\_\_sizeof__()=48, 5
>
>b=range(-1000000, 1000000, 2), type(b)=<class 'range'>, b.\_\_sizeof__()=48, 1000000

Генератор a на пять значений и генератор b на 1 млн. значений занимают
одинаковое место в памяти.

## Генераторные выражения

Генераторные выражения Python позволяют создать собственный генератор,
перебирающий значения.

Общий вид выражения:

```py
#используем круглые скобки, внутри скобок в качестве первого значения выражение, которое попадает в генератор и будем его возвращать. Потом последовательно указываем какой-то цикл перебирающий значения и логическую проверку для этого цикла (входит эл. в последовательность или нет), далее можно создавать циклы второго, третьего уровня и т.д.
gen = (exspression for expr in sequence1 if condition1
        for expr in sequence2 if condition2
        for expr in sequence3 if condition3
        ...
        for expr in sequenceN if conditionN)
```

Аналог

```py
# вложение циклов и проверок
for expr in sequense1:
    if not condition1:
        continue
        for expr in sequense2:
            if not condition2:
                continue
                ...
                for expr in sequenseN:
                    if not conditionN:
                        continue
```

Каждый следующий цикл вложен в предыдущий. Логическая проверка определяет
добавлять элемент в вывод или опустить его — continue. При этом логические
проверки могут отсутствовать для любых циклов в любом порядке.
При работе с генераторами стоит помнить, что для каждого витка внешнего цикла
внутренний перебирает все элементы от начала до конца.

```py
my_gen = (chr(i) for i in range(97, 123)) #перебор чисел от 97 до 123(искл)
print(my_gen) # выведет объект
for char in my_gen: # если использовать этот объект в цикле, он будет последовательно перебирать индексы от 97 до 123 и возвращает символы ASCII с соответствующими кодами
    print(char)
```

><generator object <genexpr> at0x000001ED58DD7D60>
>
>a
>
>b
>
>c ... и т.д.

Для создания генераторного выражения используют круглые скобки, внутри
которых прописывается логика выражения. В нашем примере циклический перебор
целых чисел от 97 до 122 и возврат символов из таблицы ASCII с
соответствующими кодами

### Комбинации for и if в генераторах и выражениях

```py
x = [1, 1, 2, 3, 5, 8, 13] 
y = [1, 2, 6, 24, 120, 720] 
print(f'{len(x)=}\t{len(y)=}')#выводим длины списков
mult = (i + j for i in x if i % 2 != 0 for j in y if j != 1)#возвращает сумму элементов i+j. перебираем все элементы "х" списка вкладывая их в переменную i и проводим проверку i % 2 != 0 (если отстаток от деления элемента не равен нулю, то он будет попадать в последовательность для суммирования. Такая же переборка для списка "y" только там проверяем j != 1)
res = list(mult)
print(f'{len(res)=}\n{res}')
```

>len(x)=7 len(y)=6
>
>len(res)=25
>
>[3, 7, 25, 121, 721, 3, 7, 25, 121, 721, 5, 9, 27, 123, 723, 7, 11, 29, 125, 725, 15, 19, 37, 133, 733]

Создаём генератор на основе двух списков x и y. 7 элементов в первом списке и 6 во
втором. Всего 13. Генератор считает сумму пар элементов.
Генератор перебирает все значения списка x и оставляет только нечётные.
Исключаем 2 и 8, т.е. оставляем 5 из 7 элементов списка для вычисления суммы. В
списке y исключаем единицу, т.е. оставляем 5 из 6 элементов. Новичок может
подумать, что на выходе получим 10 элементов - 5 из x и 5 из y. Но циклы вложены
друг в друга, следовательно количество элементов на выходе 5х5=25. А
асимптотика данного генератора квадратичная, O(NхM), где N и M - длина списков x
и y.

**!Важно!На асимптотическую сложность генератора влияют только
количество циклов. Наличие if проверок конечно же замедляет генерацию
значений. Но if воспринимается как константа в вычислении асимптотики. 4
вложенных цикла без проверок будут иметь асимптотику 4 степени, а 3 цикла с
3 проверками — асимптотику 3-й степени. Не стоит злоупотреблять
количеством вложенных циклов.!**

## Допустимые размеры односточника

PEP-8!Ограничение в 80 (120) символов на строку касается и генераторов. Если
ваш код выходит за границу, попробуйте его упростить. Если упрощение
невозможно, стоит перейти от однострочного генераторного выражения к функции
генератору.

## List comprehensions

```
list_comp = [exspression for expr in sequence1 if condition1
            for expr in sequence2 if condition2
            for expr in sequence3 if condition3
            ...
            for expr in sequenceN if conditionN]
```

Что будет, если генераторное выражение записать не в круглых скобках, а в
квадратных? Получим list comprehensions. Другие названия: list comp, генератор
списков, списковое включение. И нет, это не генераторное выражение. Генератор
списков полностью формирует список с элементами до его присваивания
переменной слева от знака равно

```py
#квадратные скобки
my_listcomp = [chr(i) for i in range(97, 123)] # перебор значений
print(my_listcomp) # создаст список из символов ASCII
for char in my_listcomp:
print(char)
```

>['a', 'b', 'c', 'd', ..., z]

Как и генераторные выражения списковые включения поддерживаю несколько
циклов и логические проверки для каждого из циклов. Можно воспринимать их как
синтаксический сахар, более короткую запись. Например выбираем все чётные
числа из исходного списка и складываем их в результирующий

```py
#обычный код
data = [2, 5, 1, 42, 65, 76, 24, 77]
res = [] 
for item in data:
    if item % 2 == 0:
        res.append(item)
print(f'{res = }')
```

>res = [2, 42, 76, 24]

Аналогичное решение, но с использованием синтаксического сахара listcomp

```py
data = [2, 5, 1, 42, 65, 76, 24, 77]
res = [item for item in data if item % 2 == 0]# перебираем элементы, если элемент делится на 2 без остатка, вставляем в последовательность
print(f'{res = }')
```

>res = [2, 42, 76, 24]

1. Не создаём пустой список в начале.
2. Не пишем двоеточия после цикла и логической проверки.
3. Исключаем метод append.

Итого вместо 4 строк кода получаем одну.
15

## Генераторные выражения или генерация списка

Если на выходе нужен
готовый список, оптимальным будет следующий код:

```py
#если нужен готовый список, используем квадратные скобки
x = [1, 1, 2, 3, 5, 8, 13]
y = [1, 2, 6, 24, 120, 720]
print(f'{len(x)=}\t{len(y)=}')
res = [i + j for i in x if i % 2 != 0 for j in y if j != 1]
print(f'{len(res)=}\n{res}')
```

>len(x)=7        len(y)=6
>
>len(res)=25
>
>[3, 7, 25, 121, 721, 3, 7, 25, 121, 721, 5, 9, 27, 123, 723, 7, 11, 29, 125, 725, 15, 19, 37, 133, 733]

А если нам не нужны все элементы разом. Например мы в дальнейшем хотим
перебирать значения по одному в цикле. В этом случае подойдет генераторное
выражение без преобразования в список

```py
# если не нужны все элементы разом, используем круглые скобки
x = [1, 1, 2, 3, 5, 8, 13]
y = [1, 2, 6, 24, 120, 720]
print(f'{len(x)=}\t{len(y)=}')
mult = (i + j for i in x if i % 2 != 0 for j in y if j != 1)
for item in mult:
    print(f'{item = }')
```

>len(x)=7        len(y)=6
>
>item = 3
>
>item = 7
>
>item = 25 ... и т.д.

**!Важно!При написании кода заранее решите нужна вам сгенерированная
коллекция целиком или нет. Не стоит тратить память на хранение всех
элементов, если вы ими не пользуетесь одновременно!**

## Set и Dict comprehensions

Используются фигурные скобки для выражения

```
set_comp = {exspression for expr in sequence1 if condition1 ...}
```

словарь подставляет ключь и значение через двоеточие

```
dict_comp = {key:value for expr in sequence1 if condition1 ...}
```

### Set comprehensions

Кроме синтаксического сахара для генерации списков можно создавать множества
в одну строку. Синтаксис аналогичен примерам выше. Изменяются лишь скобки.
Для множеств используются фигурные

```py
my_setcomp = {chr(i) for i in range(97, 123)}
print(my_setcomp) # {'f', 'g', 'b', 'j', 'e',... }
for char in my_setcomp:
    print(char)
```

> {'a', 'x', 'v', 'q', 'u', 'f', 'p', 'z', 'i', 'o', 'k', 'n', 's', 'g', 'h', 'j', 'e', 'l', 't', 'd', 'm', 'b', 'w', 'c', 'r', 'y'}
>
>a
>
>x
>
>v ... и т.д.

Мы также перебираем элементы в цикле. Также можно использовать вложенные
циклы. Также для каждого цикла может быть проверка на включение элемента в
множество

Стоит обратить внимание на следующие особенности:

- порядок элементов внутри множества может не совпадать с порядком
добавления элементов.
- множество хранит только уникальные значения

```py
x = [1, 1, 2, 3, 5, 8, 13]
y = [1, 2, 6, 24, 120, 720]
print(f'{len(x)=}\t{len(y)=}')
res = {i + j for i in x if i % 2 != 0 for j in y if j != 1}
print(f'{len(res)=}\n{res}') #множества хранят только уникальные значения
```

>len(x)=7        len(y)=6
>
>len(res)=19
>
>{3, 5, 133, 7, 9, 11, 15, 19, 25, 27, 29, 37, 721, 723, 725, 733, 121, 123, 125}

Как и в примерах выше для генерации множества перебрали все возможные
комбинации пар x и y списков. Но в итоге осталось не 25 элементов, а 19
уникальных. 6 дублирующих элементов не были добавлены в множество, но время
на их обработку было затрачено. Асимптотика не улучшилась.

### Dict comprehensions

Ещё один вариант синтаксического сахара — генерация словаря.

```py
my_dictcomp = {i: chr(i) for i in range(97, 123)}
print(my_dictcomp) # {97: 'a', 98: 'b', 99: 'c',... }
for number, char in my_dictcomp.items(): #ключ ставим как номер, а значение - буква
    print(f'dict[{number}] = {char}')
```

>{97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', ... и т.д.}
>
>dict[97] = a
>
>dict[98] = b
>
>dict[99] = c ... и т.д.

Запись похожа на создание множества, но в качестве выражения для добавления
указываются две переменные через двоеточие: key: value. Благодаря такой записи
Python понимает, что надо создать словарь

**!Важно!Стоит помнить, что ключи словаря должны быть объектами
неизменяемого типа.!**

Во всём остальном для генерации словарей в одну строку действуют те же правила,
что и для других типов данных.

# Проверка работы кода

```py
data = {2, 4, 4, 6, 8, 10, 12}
res1 = {None: item for item in data if item > 4}# двоеточие говорит о том, что формируем словарь, где None это ключ. Т.к. проверка на > 4, у нас есть 6,8,10,12 и т.к. мы записываем значение в переменную item, при этом ключ не меняется, то мы 4 раза перезаписываем значение
res2 = (item for item in data if item > 4)# круглые скобки - генераторное выражение которое выводит информацию об объекте
res3 = [[item] for item in data if item > 4]#квадратные скобки - список. переменная итем помещена в ещё одни квадратные скобки.
print(res1, res2, res3)
```

>{None: 12} <generator object <genexpr> at 0x00000296470E8040> [[6], [8], [10], [12]]
>
## Создание функции генератора

Рассмотрим создание генератора не в одну строку, а как отдельную функцию.
Например нам надо посчитать факториал чисел от одного до n.
Прежде чем создавать генератор, создадим обычную функцию, которая вернёт
список чисел

```py
# подсчёт факториала числа
def factorial(n):
    number = 1
    result = []
    for i in range(1, n + 1):# перебираем числа от 1 до 10 (вкл (поэтому n+1, что бы 10 было включено))
        number *= i #number умножаем на число и перезаписываем
        result.append(number) #перезаписанную переменную number сохраняем в список
    return result # возвращаем список как только i = 10

for i, num in enumerate(factorial(10), start=1):# старт=1 - благодаря функции enumerate будет вести счёт от 1 и автоматически запишется в переменную i
    print(f'{i}! = {num}')
```

>1! = 1
>
>2! = 2
>
>...
>
>10! = 3628800

Внутри функции создали переменную для хранения очередного числа и
результирующий список. Далее в цикле перебираем числа от одного до n
включительно. Число number умножается на очередное число, вычисляется
следующий по порядку факториал. Результат помещается в список. По завершении
цикла возвращаем список ответов.

Получив нужное количество значений в цикле выводим факториалы и их значения.
Код отлично работает, но есть но. Мы не используем все факториалы сразу, а
последовательно выводим их на печать. Если бы у нас был однострочный listcomp,
достаточно было бы поменять квадратные скобки на круглы и получить
генераторное выражение. В нашем примере также заменим функцию на генератор

### Команда yield

Команда yield работает аналогично return. Но вместо завершения функции запоминает её состояние. Повторный вызов продолжает код после yield

```py
def gen(*args, **kwargs):
    ...
    yield result
```

Зарезервированное слово yield превращает функцию в
генератор. Значение после yield возвращается из функции. Сама функция
запоминает своё состояние: строку, на которой остановилось выполнение, значения
локальных переменных. Повторный вызов функции продолжает работу с момента
остановки

Изменим функцию для получения факториала чисел, превратив её в генератор

```py
# благодаря yield не нужна переменная накапливающая все результаты т.к. функция будет перевызываться пока не закончит свою работу
def factorial(n): 
    number = 1
    for i in range(1, n + 1):# перебираем числа от 1 до 10 (вкл)
        number *= i # умножаем и перезаписываем
        yield number # возвращаем число и запоминает значение, которое хранит number и i.

for i, num in enumerate(factorial(10), start=1):
    print(f'{i}! = {num}')
```

>1! = 1
>
>2! = 2
>
>...
>
>10! = 3628800

Теперь внутри функции не создаётся пустой список для результатов. В цикле
вычисляется факториал очередного числа. Далее команда yield возвращает
значение. Следующий вызов вернёт функцию к циклу for для вычисления
очередного числа

Как вы помните, если в функции отсутствует команда return Python в конце тела
функции добавляет return None. Явная или неявная, как в нашем примере, команда
return завершает работу генератора вызовом исключения StopIteration.

## Функции iter и next для генераторов

Функции iter и next одинаково работают с генераторами "из коробки" и с созданными самостоятельно

```py
def factorial(n):
    number = 1
    for i in range(1, n + 1):
        number *= i
        yield number

my_iter = iter(factorial(4))
print(my_iter)#<generator object factorial at 0x000001C3C6D51120>
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter)) # StopIteration
```

><generator object factorial at 0x000001C3C6D51120>
>
>2
>
>6
>
>24
>
>StopIteration

# Проверка работы кода

```py
def gen(a: int, b: int) -> str: # a = 10 b = 1
    if a > b: # 10 > 1 (сравнение только один раз, состояние запомнится)
        a, b = b, a # a = 1 b = 10 (перезапись переменных только один раз, состояние запомнится)
    for i in range(a, b + 1): # от 1 до 10(вкл) итерация будет повторяться
        yield str(i) #вернуть строку

for item in gen(10, 1):
    print(f'{item = }')
```

>item = '1'
>
>item = '2'
>
>...
>
>item = '10'
