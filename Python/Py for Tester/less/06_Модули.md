# Модули

Стандартная библиотека Python. Документация
<https://docs.python.org/3/library/index.html>

- Модуль — это файл, содержащий определения и операторы Python. Во время
исполнения же модуль представлен соответствующим объектом, атрибутами
которого являются объявления, присутствующие в файле и объекты,
импортированные в этот модуль откуда-либо.
- Пакет — это набор взаимосвязанных модулей (при этом стоит уточнить, что
сам пакет тоже является модулем), предназначенных для решения задач
определенного класса некоторой предметной области. Пакеты — это способ
структурирования пространства имен модулей Python с помощью «точечных
имен модулей». Пакет представляет собой папку, в которой содержатся
модули и другие пакеты и обязательный файл \_\_init__.py, отвечающий за
инициализацию пакета.

# import

**!PEP-8! Строки импорта рекомендуется писать в самом начале файла,
оставляя 1-2 пустые строки после него.!**

```py
import sys

print(sys) # можуль sys
print(sys.builtin_module_names) # вывод всех списков модулей
print(*sys.path, sep='\n') # поиск файла модуля по некоторым дерикториям (первым делом ищет в папке проекта)
```

><module 'sys' (built-in)>
>
>('_abc', '_ast', '_bisect', '_blake2', '_codecs', '_codecs_cn', ... , 'sys', ...)
>
>d:\программирование\MyBibliotecForTask\Python\Py for Tester\task - ещё куча путей поиска файла модуля

Мы импортировали модуль sys из стандартной библиотеки Python. Механизм
импорта выполняет поиск указанного имени (в нашем примере — “sys”) в
нескольких местах. В первую очередь проверяется список встроенных модулей,
который хранится в sys.builtin_module_names. Если имя модуля не найдено,
проверка ведётся в каталогах файловой системы, которые перечислены в sys.path

**!Важно! Обычно (но не всегда) имя модуля заканчивается расширением
.py. При импорте расширение не указывается.!**

В результате импорта имя sys было добавлено в текущую, глобальную область
видимости. Для того, чтобы получить доступ к переменным, функциям, классам и
т.п. содержимому модуля используется точечная нотация:
имя_модуля<точка>имя_объекта

Обратиться к объекту внутри модуля напрямую при “обычном” импорте не
получится. Подобный подход защищает от конфликта имён. Если и в вашем файле и
в импортируемом модуле есть функция func(), конфликта имён не будет. Свою
функцию вызываете как func(), а функцию из модуля как module_name.func()

## Переменная sys.path

Содержимое переменной sys.path формируется динамически. В качестве первого
адреса указывается путь до основного файла. Например если вы используете Unix
подобную ОС и ваш скрипт расположен по адресу /home/user/project, именно этот
путь будет первым в списке поиска модулей.

Далее в sys.path перечислены пути из PYTHONPATH и пути, указанные при
установке Python и создании виртуального окружения. Таким образом Python ищет
импортируемый модуль практически во всех местах, где этот модуль мог быть
установлен.

**!Важно! Если создать собственный файл с именем аналогичным имени
модуля, Python импортирует ваш файл, а не модуль. Строго не рекомендуется
использовать для своих файлов имена встроенных модулей. В редких
исключительных ситуациях стоит добавлять символ подчёркивания в конце
имени, чтобы избежать двойного именования.!**

## Антипримеры импорта

создали файл random.py со следующим кодом

```py
# ф-я ничего не делает а лишь возвращает строку
def randint(*args):
    return 'Не то, что вы искали!'
```

Создаём другой файл
импортируем модуль random и попробуем
сгенерировать случайное число от 1 до 6.

```py
import random

print(random.randint(1, 6)) #сначала пайтон будет искать наличие модуля в папке проекта, а потом перейдёт в свои системные
```

> Не то, что вы искали!

Если надо использовать встроенный модуль random вместо написанного, название написанного пишут с нижним подчёркиванием в конце random_.py

В результате работы получим “Не то, что вы искали!”.

**!PEP-8! При импорте нескольких модулей каждый указывается с новой
строки.!**

Правильно:

```py
import sys
import random
```

Неправильно:

```py
import sys, random
```

## Использование from и as

from sys import builtin_module_names - импорт функции из модуля sys

import numpy as np - позволяет создать псевдоним (т.е. назвать по своему)

Помимо обычного импорта можно использовать более подробную форму записи.
Зарезервированное слово from указывает на имя модуля или пакета, далее import и
имена импортируемых объектов

```py
from sys import builtin_module_names, path

print(builtin_module_names)
print(*path, sep='\n')
```

>('_abc', '_ast', '_bisect', '_blake2', ... )
>
>d:\программирование\MyBibliotecForTask\Python\Py for Tester\task

Теперь при обращении к импортированным объектам не нужно указывать имя
модуля. Мы явно добавили их в наш код, включили имена в область видимости

**!PEP-8! Конструкция from import допускает перечисление импортируемых
имён объектов через запятую в одной строке. После from всегда указывается
один модуль.!**

Кроме выборочного импорта можно создавать псевдонимы для объектов через
зарезервированное слово as. При этом доступ к объекту будет возможен только
через псевдоним. Один объект — одно имя.

```py
# импорт сразу двух модулей и задаём свои псевдонимы
import random as rnd
from sys import builtin_module_names as bmn, path as p

print(bmn)
print(*p, sep='\n')
print(rnd.randint(1, 6))
print(path) # NameError: name 'path' is not defined
print(sys.path) # NameError: name 'sys' is not defined
```

В первой строке импортировали модуль random и присвоили ему имя rnd внутри
текущей области видимости. Во второй строке импортировали переменную
builtin_module_names под именем bmn и переменную path под именем p. Последние
две строки вызывают ошибку имени. Мы не можем обратиться к переменной path,
потому что дали ей другое имя — p. И обращение к модулю sys не работает, ведь мы
его не импортировали. Только объекты из модуля.

**!Важно! Не стоит давать переменным короткие понятные лишь вам
имена. Код должен легко читаться другими разработчиками. Исключения —
общепризнанные сокращения, например import numpy as np.!**

## Плохой import * (импорт звёздочка)

Ещё один вариант импорта: from имя_модуля import *
Подобная запись импортирует из модуля все глобальные объекты за исключением
тех, чьи имена начинаются с символа подчёркивания

Создаём файл super_module.py

```py
from random import randint

SIZE = 100
_secret = 'qwerty' # защищённая переменная
__top_secret = '1q2w3e4r5t6y' # приватная переменная

def func(a: int, b: int) -> str:
    z = f'В диапазоне от {a} до {b} получили {randint(a, b)}'
    return z

result = func(1, 6)
```

**!Внимание! Если название объекта (переменной, функции и т.п.)
начинается с символа подчёркивания, объект становится защищённым. Если
имя начинается с двух подчёркиваний, объект становится приватным. Объекты
без подчёркивания в начале имени — публичные. Подробнее разберём на
лекциях по ООП!**

Импортируем модуль в основной файл программы через звёздочку и попробуем
выполнить несколько операций

Создаём файл main.py

```py
from super_module import *

SIZE = 49.5 #определили свою константу, поэтому константа из модуля перезаписалась

print(f'{SIZE = }\n{result = }') #переменная result подтянулась из super_module
print(f'{z = }') # попытка обратиться к локальной переменной - NameError: name 'z' is not defined
print(f'{_secret = }') #защищённые эл-ты не импортируются через звёздочку - NameError: name '_secret' is not defined
print(f'{func(100, 200) = }\n{randint(10, 20) = }')

def func(a: int, b: int) -> int: # перезапись импортированной функции
    return a + b

print(f'{func(100, 200) = }')
```

>SIZE = 49.5
>
>result = 'В диапазоне от 1 до 6 получили 4'
>
>func(100, 200) = 'В диапазоне от 100 до 200 получили 195'
>
>randint(10, 20) = 14
>
>func(100, 200) = 300

Первая строка импортирует в файл все глобальные публичные объекты. Далее мы
определяем константу SIZE. В этот момент значение константы из модуля
затирается новым значением. Возник конфликт имён и Python разрешил его в
пользу нового значения константы. При этом содержимое переменной result
берётся из модуля super_module, т.к. других определений переменной нет в файле.
При попытке обратиться к локальной и защищённой переменным получаем ошибки.
Они не были импортированы “звёздочкой”

Далее мы вызываем функции func и randint. Они верно отрабатывают код, т.к. обе
были импортированы из внешнего модуля

В финале создаём свою функцию func. Возникает очередной конфликт имён,
который Python разрешает в пользу новой функции. В результате вызов func() после
её определения возвращает совсем другой результат, чем вызовом ранее

Промежуточный итог. Использование стиля from module import * зачастую приводит
к неожиданным результатам, затрудняет отладку кода и мешает верному
пониманию работы программы. Использовать подобный приём стоит в редких
особенных случаях. Кроме того импорт всех доступных объектов может
значительно замедлить работы программы, если таких объектов очень много

## Переменная \_\_all__

При необходимости разработчик модуля может явно указать какие объекты нужно
импортировать при использовании стиля from module import *. Для этого
используется магическая переменная \_\_all__(два нижних подчёркивания до, слово
all и два нижних подчёркивания после). Изменим код модуля super_module.py,
добавив строку с \_\_all__

\_\_all__ = ['func', '_secret'] - список имён объектов, заключённых в кавычки, т.е. строки для импорта через звёздочку

Файл super_module.py

```py
from random import randint

__all__ = ['func', '_secret'] #в переменную вкладываем функцию и переменную _secret

SIZE = 100
_secret = 'qwerty' #переменная будет доступна в другом файле при вызове этого модуля через *
__top_secret = '1q2w3e4r5t6y'

def func(a: int, b: int) -> str: #функция будет доступна в другом файле при вызове этого модуля через *
    z = f'В диапазоне от {a} до {b} получили {randint(a, b)}'
    return z

result = func(1, 6)
```

Переменной \_\_all__ присваивается список имён объектов, заключённых в кавычки,
т.е. str типа. В основной модуль попадут только указанные в списке имена,
независимо от того являются они публичными, защищёнными или приватными. При
этом объект должен быть глобальным. Если указать в списке имя локального
объекта, например переменную z — локальную переменную функции func, получим
ошибку

Список \_\_all__в приведённом примере используется для формирования списка
импортируемых объектов модуля. Кроме этого \_\_all__ применяется для импорта
модулей из пакета. Рассмотрим вариант импорта модулей из пакета далее на
лекции.

# Виды модулей

Попробуем добавить некоторую системность в модули. В Python есть:

- встроенные модули,
- установленные внешние модули,
- модули, созданные разработчиком, свои.
Кроме того каждый вид модулей может быть внутри пакета, сгруппированной
коллекции модулей. Разберём подробнее.

## Встроенные модули

Один из плюсов языка Python — его батарейки. Так принято называть стандартную
библиотеку языка. По сути библиотека представляет обширный набор пакетов и
модулей для решения широкого спектра задач.
Некоторые модули стандартной библиотеки мы уже использовали. С другими будем
знакомится в рамках последующих уроков. Финальный урок курса целиком
посвятим разговору о стандартной библиотеке. А пока определимся с несколькими
вещами:

1. Стандартная библиотека устанавливается вместе с интерпретатором.
Дополнительные манипуляции по установке не требуются. Всё работает “из
коробки”. (Установщики Python для платформы Windows обычно включают в себя всю стандартную
библиотеку, а также множество дополнительных компонентов. Для Unix-подобных операционных
систем Python обычно предоставляется в виде набора пакетов, поэтому может потребоваться
использование инструментов упаковки, поставляемых с операционной системой, для получения
некоторых или всех дополнительных компонентов.)
2. Для использования модуля стандартной библиотеки достаточно его
импортировать в ваш код.
3. Большинство частых задач легко решаются средствами стандартной
библиотеки. Достаточно обратиться к справке и найти нужный модуль.
4. Некоторые модули стандартной библиотеки разрабатывались настолько
давно, что не отвечают современным требованиям решения задач. В таком
случае на помощь приходят внешние решения. И наоборот. Каждое
обновление Python вносит улучшения в библиотеку, зачастую более
эффективные, чем внешние решения.

**!PEP-8! Импорт модулей стандартной библиотеки пишется в начале
файла, до импорта внешних и своих модулей. После импорта оставляют пустую
строку, даже если далее идёт импорт модулей не из библиотеки.!**

### Свои модули

создаём
файл с расширением py, пишем в нём код и сохраняем результат. Готово! Вы создали
свой модуль. Ранее на лекции мы создали файл super_module.py и импортировали
его в main.py, т.е. работали с файлом как с модулем.
Обычно модуль должен решать одну задачу или несколько однотипных задач.

Стандартная структура любого модуля следующая:

- документация по модулю в виде многострочного комментария (три пары
двойных кавычек),
- импорт необходимых пакетов, модулей, классов, функций и т.п. объектов,
- определение констант уровня модуля,
- создание классов модуля при ООП подходе,
- создание функций модуля,
- определение переменных модуля,
- покрытие тестами, если оно не вынесено в отдельный пакет,
- main код

В зависимости от решаемой задачи некоторые пункты могут отсутствовать.
Учебный пример модуля ниже:

Файл base_math.py

```py
#base_math.py
"""Four basic mathematical operations.
Addition, subtraction, multiplication and division as functions.
"""
# Защищённые переменные
_START_SUM = 0
_START_MULT = 1
_BEGINNING = 0
_CONTINUATION = 1

def add(*args):
    res = _START_SUM
    for item in args:
        res += item
    return res

def sub(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res -= item
    return res

def mul(*args):
    res = _START_MULT
    for item in args:
        res *= item
    return res

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res /= item
    return res

# ниже тестирование функций
print(f'{add(2, 4) = }')# add(2, 4) = 6
print(f'{add(2, 4, 6, 8) = }')# add(2, 4, 6, 8) = 20
print(f'{sub(10, 2) = }')# sub(10, 2) = 8
print(f'{mul(2, 2, 2, 2, 2) = }')# mul(2, 2, 2, 2, 2) = 32
print(f'{div(-100, 5, -2) = }')# div(-100, 5, -2) = 10.0
```

в файле нет классов, только функции. Так же нам не
понадобились переменные уровня модуля.

### свой модуль: \_\_name__== '\_\_main__'

файл task_module.py

```py
# task_module.py
import base_math #из-за импорта файла, принты из него распечатаются и тут

x = base_math.mul # Плохой приём. Передача имени функции из импортируемого файла в другую переменную
y = base_math._START_MULT # Очень плохой приём. Обращение к защищённой или приватной переменной из импортируемого файла
z = base_math.sub(73, 42)

print(x(2, 3)) # 6
print(y) # 1
print(z) # 31
```

>add(2, 4) = 6
>
>add(2, 4, 6, 8) = 20
>
>sub(10, 2) = 8
>
>mul(2, 2, 2, 2, 2) = 32
>
>div(-100, 5, -2) = 10.0
>
>6
>
>1
>
>31

Запускаем файл и наблюдаем вывод “принтов” из файла base_math раньше наших
расчётов в task_module. Дело в том, что команда import запускает импортируемый
модуль. В результате лишние вызовы функций, а следовательно более медленное
выполнение кода. Для решения проблемы необходимо внести правки в файл
base_math.py

```py
#base_math.py
#дописываем в этот файл if __name__ == '__main__':
"""Four basic mathematical operations.
Addition, subtraction, multiplication and division as functions.
"""
_START_SUM = 0
_START_MULT = 1
_BEGINNING = 0
_CONTINUATION = 1

def add(*args):
    res = _START_SUM
    for item in args:
        res += item
    return res

def sub(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res -= item
    return res

def mul(*args):
    res = _START_MULT
    for item in args:
        res *= item
    return res

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res /= item
    return res

if __name__ == '__main__': #благодаря этой конструкции, при импорте этого файла, всё что ниже выводиться не будет
    print(f'{add(2, 4) = }')# add(2, 4) = 6
    print(f'{add(2, 4, 6, 8) = }')# add(2, 4, 6, 8) = 20
    print(f'{sub(10, 2) = }')# sub(10, 2) = 8
    print(f'{mul(2, 2, 2, 2, 2) = }')# mul(2, 2, 2, 2, 2) = 32
    print(f'{div(-100, 5, -2) = }')# div(-100, 5, -2) = 10.0
```

```py
# task_module.py
import base_math

x = base_math.mul # Плохой приём
y = base_math._START_MULT # Очень плохой приём
z = base_math.sub(73, 42)

print(x(2, 3)) # 6
print(y) # 1
print(z) # 31
```

>6
>
>1
>
>31

Работа конструкции ```if __name__ == '__main__':```

```py
...
if __name__ == '__main__':
    print(f'{add(2, 4) = }')
    ...
```

После определения функций, но перед вызовом print добавили логическую
проверку. Строки с print после проверки и до конца файла сдвинули на 4 пробела,
поместили внутрь блока проверки.
Магическая переменная \_\_main__содержит полное имя модуля. Это имя
используется для уникальной идентификации модуля в системе импорта.
Когда мы запускаем сам модуль base_math, в переменную \_\_name__ попадает имя
“\_\_main__”. Оно указывает, что файл запущен, а не импортирован. Никакой
разницы в работе модуля не произошло.
Когда модуль импортируется в другой файл, в переменную \_\_name__попадает его
имя, название файла без расширения. import base_math также выполняет код в
файле. Присваиваются значения константам, инициализируются функции. Но
логическая проверка if \_\_name__== '\_\_main__ ': возвращает ложь и дальнейший
код пропускается.
Отличной. Добавление “мейн” проверки позволило завершить создание модуля.
Теперь запуск main.py работает так, как мы ожидаем.

### Создание пакетов и их импорт

```__init__.py``` - директория с ```__init__.py``` превращается в пакет. Но он так же является модулем и его можно импортировать в другие файлы

Создаём файл advanced_math.py целочисленное деление и возведение в степень.

```py
# advanced_math.py
"""Two advanced mathematical operations.
Integer division and exponentiation."""

__all__ = ['div', 'exp']
_BEGINNING = 0
_CONTINUATION = 1

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res //= item
    return res
def exp(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res **= item
    return res

if __name__ == '__main__':
    print(f'{div(42, 4) = }')
    print(f'{exp(2, 4, 6, 8) = }')
```

Создаём директорию
mathematical и переносим в неё оба файла: base_math,py и advanced_math.py. Далее
создаём в каталоге пустой файл ```__init__.py.``` Пакет mathematical готов.

В Python любая директория с файлом ```__init__.py.``` автоматически становится
пакетом. При этом полезный функционал содержится в других питоновских файлах,
а не в “инит”

## Разница между модулем и пакетом

Пакет — директория с ```__init__.py.``` файлом и другими py файлами — модулями. В
Python любой пакет является одновременно и модулем. Это означает, что пакет
можно импортировать в проект как и модуль. Так же это означает, что пакет может
хранить в себе другие пакеты — директории с “инит” файлом. Глубина вложенности
ограничена лишь здравым смыслом

Пример пакета sound, содержащего пакеты formats, effects и filters, содержащие
различные модули из официальной документации. Обратите внимание, что в
проекте четыре директории и четыре файла ```__init__.py.```, по одному на пакет.

<img src = ''>
