# Модули

Стандартная библиотека Python. Документация
<https://docs.python.org/3/library/index.html>

- Модуль — это файл, содержащий определения и операторы Python. Во время
исполнения же модуль представлен соответствующим объектом, атрибутами
которого являются объявления, присутствующие в файле и объекты,
импортированные в этот модуль откуда-либо.
- Пакет — это набор взаимосвязанных модулей (при этом стоит уточнить, что
сам пакет тоже является модулем), предназначенных для решения задач
определенного класса некоторой предметной области. Пакеты — это способ
структурирования пространства имен модулей Python с помощью «точечных
имен модулей». Пакет представляет собой папку, в которой содержатся
модули и другие пакеты и обязательный файл \_\_init__.py, отвечающий за
инициализацию пакета.

# import

**!PEP-8! Строки импорта рекомендуется писать в самом начале файла,
оставляя 1-2 пустые строки после него.!**

```py
import sys

print(sys) # можуль sys
print(sys.builtin_module_names) # вывод всех списков модулей
print(*sys.path, sep='\n') # поиск файла модуля по некоторым дерикториям (первым делом ищет в папке проекта)
```

><module 'sys' (built-in)>
>
>('_abc', '_ast', '_bisect', '_blake2', '_codecs', '_codecs_cn', ... , 'sys', ...)
>
>d:\программирование\MyBibliotecForTask\Python\Py for Tester\task - ещё куча путей поиска файла модуля

Мы импортировали модуль sys из стандартной библиотеки Python. Механизм
импорта выполняет поиск указанного имени (в нашем примере — “sys”) в
нескольких местах. В первую очередь проверяется список встроенных модулей,
который хранится в sys.builtin_module_names. Если имя модуля не найдено,
проверка ведётся в каталогах файловой системы, которые перечислены в sys.path

**!Важно! Обычно (но не всегда) имя модуля заканчивается расширением
.py. При импорте расширение не указывается.!**

В результате импорта имя sys было добавлено в текущую, глобальную область
видимости. Для того, чтобы получить доступ к переменным, функциям, классам и
т.п. содержимому модуля используется точечная нотация:
имя_модуля<точка>имя_объекта

Обратиться к объекту внутри модуля напрямую при “обычном” импорте не
получится. Подобный подход защищает от конфликта имён. Если и в вашем файле и
в импортируемом модуле есть функция func(), конфликта имён не будет. Свою
функцию вызываете как func(), а функцию из модуля как module_name.func()

## Переменная sys.path

Содержимое переменной sys.path формируется динамически. В качестве первого
адреса указывается путь до основного файла. Например если вы используете Unix
подобную ОС и ваш скрипт расположен по адресу /home/user/project, именно этот
путь будет первым в списке поиска модулей.

Далее в sys.path перечислены пути из PYTHONPATH и пути, указанные при
установке Python и создании виртуального окружения. Таким образом Python ищет
импортируемый модуль практически во всех местах, где этот модуль мог быть
установлен.

**!Важно! Если создать собственный файл с именем аналогичным имени
модуля, Python импортирует ваш файл, а не модуль. Строго не рекомендуется
использовать для своих файлов имена встроенных модулей. В редких
исключительных ситуациях стоит добавлять символ подчёркивания в конце
имени, чтобы избежать двойного именования.!**

## Антипримеры импорта

создали файл random.py со следующим кодом

```py
# ф-я ничего не делает а лишь возвращает строку
def randint(*args):
    return 'Не то, что вы искали!'
```

Создаём другой файл
импортируем модуль random и попробуем
сгенерировать случайное число от 1 до 6.

```py
import random

print(random.randint(1, 6)) #сначала пайтон будет искать наличие модуля в папке проекта, а потом перейдёт в свои системные
```

> Не то, что вы искали!

Если надо использовать встроенный модуль random вместо написанного, название написанного пишут с нижним подчёркиванием в конце random_.py

В результате работы получим “Не то, что вы искали!”.

**!PEP-8! При импорте нескольких модулей каждый указывается с новой
строки.!**

Правильно:

```py
import sys
import random
```

Неправильно:

```py
import sys, random
```

## Использование from и as

from sys import builtin_module_names - импорт функции из модуля sys

import numpy as np - позволяет создать псевдоним (т.е. назвать по своему)

Помимо обычного импорта можно использовать более подробную форму записи.
Зарезервированное слово from указывает на имя модуля или пакета, далее import и
имена импортируемых объектов

```py
from sys import builtin_module_names, path

print(builtin_module_names)
print(*path, sep='\n')
```

>('_abc', '_ast', '_bisect', '_blake2', ... )
>
>d:\программирование\MyBibliotecForTask\Python\Py for Tester\task

Теперь при обращении к импортированным объектам не нужно указывать имя
модуля. Мы явно добавили их в наш код, включили имена в область видимости

**!PEP-8! Конструкция from import допускает перечисление импортируемых
имён объектов через запятую в одной строке. После from всегда указывается
один модуль.!**

Кроме выборочного импорта можно создавать псевдонимы для объектов через
зарезервированное слово as. При этом доступ к объекту будет возможен только
через псевдоним. Один объект — одно имя.

```py
# импорт сразу двух модулей и задаём свои псевдонимы
import random as rnd
from sys import builtin_module_names as bmn, path as p

print(bmn)
print(*p, sep='\n')
print(rnd.randint(1, 6))
print(path) # NameError: name 'path' is not defined
print(sys.path) # NameError: name 'sys' is not defined
```

В первой строке импортировали модуль random и присвоили ему имя rnd внутри
текущей области видимости. Во второй строке импортировали переменную
builtin_module_names под именем bmn и переменную path под именем p. Последние
две строки вызывают ошибку имени. Мы не можем обратиться к переменной path,
потому что дали ей другое имя — p. И обращение к модулю sys не работает, ведь мы
его не импортировали. Только объекты из модуля.

**!Важно! Не стоит давать переменным короткие понятные лишь вам
имена. Код должен легко читаться другими разработчиками. Исключения —
общепризнанные сокращения, например import numpy as np.!**

## Плохой import * (импорт звёздочка)

Ещё один вариант импорта: from имя_модуля import *
Подобная запись импортирует из модуля все глобальные объекты за исключением
тех, чьи имена начинаются с символа подчёркивания

Создаём файл super_module.py

```py
from random import randint

SIZE = 100
_secret = 'qwerty' # защищённая переменная
__top_secret = '1q2w3e4r5t6y' # приватная переменная

def func(a: int, b: int) -> str:
    z = f'В диапазоне от {a} до {b} получили {randint(a, b)}'
    return z

result = func(1, 6)
```

**!Внимание! Если название объекта (переменной, функции и т.п.)
начинается с символа подчёркивания, объект становится защищённым. Если
имя начинается с двух подчёркиваний, объект становится приватным. Объекты
без подчёркивания в начале имени — публичные. Подробнее разберём на
лекциях по ООП!**

Импортируем модуль в основной файл программы через звёздочку и попробуем
выполнить несколько операций

Создаём файл main.py

```py
from super_module import *

SIZE = 49.5 #определили свою константу, поэтому константа из модуля перезаписалась

print(f'{SIZE = }\n{result = }') #переменная result подтянулась из super_module
print(f'{z = }') # попытка обратиться к локальной переменной - NameError: name 'z' is not defined
print(f'{_secret = }') #защищённые эл-ты не импортируются через звёздочку - NameError: name '_secret' is not defined
print(f'{func(100, 200) = }\n{randint(10, 20) = }')

def func(a: int, b: int) -> int: # перезапись импортированной функции
    return a + b

print(f'{func(100, 200) = }')
```

>SIZE = 49.5
>
>result = 'В диапазоне от 1 до 6 получили 4'
>
>func(100, 200) = 'В диапазоне от 100 до 200 получили 195'
>
>randint(10, 20) = 14
>
>func(100, 200) = 300

Первая строка импортирует в файл все глобальные публичные объекты. Далее мы
определяем константу SIZE. В этот момент значение константы из модуля
затирается новым значением. Возник конфликт имён и Python разрешил его в
пользу нового значения константы. При этом содержимое переменной result
берётся из модуля super_module, т.к. других определений переменной нет в файле.
При попытке обратиться к локальной и защищённой переменным получаем ошибки.
Они не были импортированы “звёздочкой”

Далее мы вызываем функции func и randint. Они верно отрабатывают код, т.к. обе
были импортированы из внешнего модуля

В финале создаём свою функцию func. Возникает очередной конфликт имён,
который Python разрешает в пользу новой функции. В результате вызов func() после
её определения возвращает совсем другой результат, чем вызовом ранее

Промежуточный итог. Использование стиля from module import * зачастую приводит
к неожиданным результатам, затрудняет отладку кода и мешает верному
пониманию работы программы. Использовать подобный приём стоит в редких
особенных случаях. Кроме того импорт всех доступных объектов может
значительно замедлить работы программы, если таких объектов очень много

## Переменная \_\_all__

При необходимости разработчик модуля может явно указать какие объекты нужно
импортировать при использовании стиля from module import *. Для этого
используется магическая переменная \_\_all__(два нижних подчёркивания до, слово
all и два нижних подчёркивания после). Изменим код модуля super_module.py,
добавив строку с \_\_all__

\_\_all__ = ['func', '_secret'] - список имён объектов, заключённых в кавычки, т.е. строки для импорта через звёздочку

Файл super_module.py

```py
from random import randint

__all__ = ['func', '_secret'] #в переменную вкладываем функцию и переменную _secret

SIZE = 100
_secret = 'qwerty' #переменная будет доступна в другом файле при вызове этого модуля через *
__top_secret = '1q2w3e4r5t6y'

def func(a: int, b: int) -> str: #функция будет доступна в другом файле при вызове этого модуля через *
    z = f'В диапазоне от {a} до {b} получили {randint(a, b)}'
    return z

result = func(1, 6)
```

Переменной \_\_all__ присваивается список имён объектов, заключённых в кавычки,
т.е. str типа. В основной модуль попадут только указанные в списке имена,
независимо от того являются они публичными, защищёнными или приватными. При
этом объект должен быть глобальным. Если указать в списке имя локального
объекта, например переменную z — локальную переменную функции func, получим
ошибку

Список \_\_all__в приведённом примере используется для формирования списка
импортируемых объектов модуля. Кроме этого \_\_all__ применяется для импорта
модулей из пакета. Рассмотрим вариант импорта модулей из пакета далее на
лекции.

# Виды модулей

Попробуем добавить некоторую системность в модули. В Python есть:

- встроенные модули,
- установленные внешние модули,
- модули, созданные разработчиком, свои.
Кроме того каждый вид модулей может быть внутри пакета, сгруппированной
коллекции модулей. Разберём подробнее.

## Встроенные модули

Один из плюсов языка Python — его батарейки. Так принято называть стандартную
библиотеку языка. По сути библиотека представляет обширный набор пакетов и
модулей для решения широкого спектра задач.
Некоторые модули стандартной библиотеки мы уже использовали. С другими будем
знакомится в рамках последующих уроков. Финальный урок курса целиком
посвятим разговору о стандартной библиотеке. А пока определимся с несколькими
вещами:

1. Стандартная библиотека устанавливается вместе с интерпретатором.
Дополнительные манипуляции по установке не требуются. Всё работает “из
коробки”. (Установщики Python для платформы Windows обычно включают в себя всю стандартную
библиотеку, а также множество дополнительных компонентов. Для Unix-подобных операционных
систем Python обычно предоставляется в виде набора пакетов, поэтому может потребоваться
использование инструментов упаковки, поставляемых с операционной системой, для получения
некоторых или всех дополнительных компонентов.)
2. Для использования модуля стандартной библиотеки достаточно его
импортировать в ваш код.
3. Большинство частых задач легко решаются средствами стандартной
библиотеки. Достаточно обратиться к справке и найти нужный модуль.
4. Некоторые модули стандартной библиотеки разрабатывались настолько
давно, что не отвечают современным требованиям решения задач. В таком
случае на помощь приходят внешние решения. И наоборот. Каждое
обновление Python вносит улучшения в библиотеку, зачастую более
эффективные, чем внешние решения.

**!PEP-8! Импорт модулей стандартной библиотеки пишется в начале
файла, до импорта внешних и своих модулей. После импорта оставляют пустую
строку, даже если далее идёт импорт модулей не из библиотеки.!**

### Свои модули

создаём
файл с расширением py, пишем в нём код и сохраняем результат. Готово! Вы создали
свой модуль. Ранее на лекции мы создали файл super_module.py и импортировали
его в main.py, т.е. работали с файлом как с модулем.
Обычно модуль должен решать одну задачу или несколько однотипных задач.

Стандартная структура любого модуля следующая:

- документация по модулю в виде многострочного комментария (три пары
двойных кавычек),
- импорт необходимых пакетов, модулей, классов, функций и т.п. объектов,
- определение констант уровня модуля,
- создание классов модуля при ООП подходе,
- создание функций модуля,
- определение переменных модуля,
- покрытие тестами, если оно не вынесено в отдельный пакет,
- main код

В зависимости от решаемой задачи некоторые пункты могут отсутствовать.
Учебный пример модуля ниже:

Файл base_math.py

```py
#base_math.py
"""Four basic mathematical operations.
Addition, subtraction, multiplication and division as functions.
"""
# Защищённые переменные
_START_SUM = 0
_START_MULT = 1
_BEGINNING = 0
_CONTINUATION = 1

def add(*args):
    res = _START_SUM
    for item in args:
        res += item
    return res

def sub(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res -= item
    return res

def mul(*args):
    res = _START_MULT
    for item in args:
        res *= item
    return res

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res /= item
    return res

# ниже тестирование функций
print(f'{add(2, 4) = }')# add(2, 4) = 6
print(f'{add(2, 4, 6, 8) = }')# add(2, 4, 6, 8) = 20
print(f'{sub(10, 2) = }')# sub(10, 2) = 8
print(f'{mul(2, 2, 2, 2, 2) = }')# mul(2, 2, 2, 2, 2) = 32
print(f'{div(-100, 5, -2) = }')# div(-100, 5, -2) = 10.0
```

в файле нет классов, только функции. Так же нам не
понадобились переменные уровня модуля.

### свой модуль: \_\_name__== '\_\_main__'

файл task_module.py

```py
# task_module.py
import base_math #из-за импорта файла, принты из него распечатаются и тут

x = base_math.mul # Плохой приём. Передача имени функции из импортируемого файла в другую переменную
y = base_math._START_MULT # Очень плохой приём. Обращение к защищённой или приватной переменной из импортируемого файла
z = base_math.sub(73, 42)

print(x(2, 3)) # 6
print(y) # 1
print(z) # 31
```

>add(2, 4) = 6
>
>add(2, 4, 6, 8) = 20
>
>sub(10, 2) = 8
>
>mul(2, 2, 2, 2, 2) = 32
>
>div(-100, 5, -2) = 10.0
>
>6
>
>1
>
>31

Запускаем файл и наблюдаем вывод “принтов” из файла base_math раньше наших
расчётов в task_module. Дело в том, что команда import запускает импортируемый
модуль. В результате лишние вызовы функций, а следовательно более медленное
выполнение кода. Для решения проблемы необходимо внести правки в файл
base_math.py

```py
#base_math.py
#дописываем в этот файл if __name__ == '__main__':
"""Four basic mathematical operations.
Addition, subtraction, multiplication and division as functions.
"""
_START_SUM = 0
_START_MULT = 1
_BEGINNING = 0
_CONTINUATION = 1

def add(*args):
    res = _START_SUM
    for item in args:
        res += item
    return res

def sub(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res -= item
    return res

def mul(*args):
    res = _START_MULT
    for item in args:
        res *= item
    return res

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res /= item
    return res

if __name__ == '__main__': #благодаря этой конструкции, при импорте этого файла, всё что ниже выводиться не будет
    print(f'{add(2, 4) = }')# add(2, 4) = 6
    print(f'{add(2, 4, 6, 8) = }')# add(2, 4, 6, 8) = 20
    print(f'{sub(10, 2) = }')# sub(10, 2) = 8
    print(f'{mul(2, 2, 2, 2, 2) = }')# mul(2, 2, 2, 2, 2) = 32
    print(f'{div(-100, 5, -2) = }')# div(-100, 5, -2) = 10.0
```

```py
# task_module.py
import base_math

x = base_math.mul # Плохой приём
y = base_math._START_MULT # Очень плохой приём
z = base_math.sub(73, 42)

print(x(2, 3)) # 6
print(y) # 1
print(z) # 31
```

>6
>
>1
>
>31

Работа конструкции ```if __name__ == '__main__':```

```py
...
if __name__ == '__main__':
    print(f'{add(2, 4) = }')
    ...
```

После определения функций, но перед вызовом print добавили логическую
проверку. Строки с print после проверки и до конца файла сдвинули на 4 пробела,
поместили внутрь блока проверки.
Магическая переменная \_\_main__содержит полное имя модуля. Это имя
используется для уникальной идентификации модуля в системе импорта.
Когда мы запускаем сам модуль base_math, в переменную \_\_name__ попадает имя
“\_\_main__”. Оно указывает, что файл запущен, а не импортирован. Никакой
разницы в работе модуля не произошло.
Когда модуль импортируется в другой файл, в переменную \_\_name__попадает его
имя, название файла без расширения. import base_math также выполняет код в
файле. Присваиваются значения константам, инициализируются функции. Но
логическая проверка if \_\_name__== '\_\_main__ ': возвращает ложь и дальнейший
код пропускается.
Отличной. Добавление “мейн” проверки позволило завершить создание модуля.
Теперь запуск main.py работает так, как мы ожидаем.

### Создание пакетов и их импорт

```__init__.py``` - директория с ```__init__.py``` превращается в пакет. Но он так же является модулем и его можно импортировать в другие файлы

Создаём файл advanced_math.py целочисленное деление и возведение в степень.

```py
# advanced_math.py
"""Two advanced mathematical operations.
Integer division and exponentiation."""

__all__ = ['div', 'exp']
_BEGINNING = 0
_CONTINUATION = 1

def div(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res //= item
    return res
def exp(*args):
    res = args[_BEGINNING]
    for item in args[_CONTINUATION:]:
        res **= item
    return res

if __name__ == '__main__':
    print(f'{div(42, 4) = }')
    print(f'{exp(2, 4, 6, 8) = }')
```

Создаём директорию
mathematical и переносим в неё оба файла: base_math,py и advanced_math.py. Далее
создаём в каталоге пустой файл ```__init__.py.``` Пакет mathematical готов.

В Python любая директория с файлом ```__init__.py.``` автоматически становится
пакетом. При этом полезный функционал содержится в других питоновских файлах,
а не в “инит”

## Разница между модулем и пакетом

Пакет — директория с ```__init__.py.``` файлом и другими py файлами — модулями. В
Python любой пакет является одновременно и модулем. Это означает, что пакет
можно импортировать в проект как и модуль. Так же это означает, что пакет может
хранить в себе другие пакеты — директории с “инит” файлом. Глубина вложенности
ограничена лишь здравым смыслом

Пример пакета sound, содержащего пакеты formats, effects и filters, содержащие
различные модули из официальной документации. Обратите внимание, что в
проекте четыре директории и четыре файла ```__init__.py.```, по одному на пакет.

<img src = 'https://github.com/Wredina/LibraryForTask/blob/main/Python/Py%20for%20Tester/less/img_for_less/01.jpg?raw=true'>

- Пакет - дирректория с ```__init__.py.``` файлом

- Пакет можно импортировать как модуль

- Внутри файла ```__init__.py.``` можно писать код, который будет выполняться при импорте пакета. Кроме того, в файл можно добавить переменную ```__all__``` с именами
всех модулей пакета. Например мы добавим в учебный проект следующую строку

```py
__all__ = ['base_math', 'advanced_math']
```

**!Важно! При добавлении или удалении модулей в пакет важно вносить
изменения в список ```__all__``` для корректной работы импорта.!**

## Варианты импорта

- Простой импорт

```py
import mathematical

x = mathematical.base_math.div(12, 5) #прописывается имя пакета, имя модуля, имя объекта
```

Если импортировать пакет верхнего уровня, для работы с функциями необходимо
указать всю цепочку через точечную нотацию: имя пакета, имя модуля, имя
объекта.

- Абсолютный импорт

```py
# импортировали модуль base_math под именем bm
from mathematical import base_math as bm

x = bm.div(12, 5)
```

Для сокращения объема кода обычно импортируют нужные модули или объекты
модуля через точечную нотацию после import

```py
# импортировали функцию exp из модуля advanced_math пакета mathematical
from mathematical.advanced_math import ex

z = exp(2, 3)
```

- Относительный импорт
импорт модуля other_module в другой модуль того же пакета можно осуществить
через относительный импорт:

```py
from . import other_module
```

А если модулю надо выйти из своего пакета в пакет верхнего уровня

```py
from .. import other_module
```

Или

```py
from ..other_package import other_module
```

**!Важно! Модуль, который является основным в вашем проекте должен
использовать только абсолютные имена пакетов и модулей. Связано это с тем,
что у запускаемого модуля в переменной \_\_name__ хранится значение
“\_\_main__”, а не имя модуля.
!**

# модули “из коробки”

## Модуль sys

Модуль обеспечивает доступ к некоторым переменным, используемым или поддерживаемым интерпритатором, а так же функциям, тесно взаимодействующим с интерпритатором

Он относится к группе служебных в Python.
Модуль sys обеспечивает доступ к некоторым переменным, используемым или
поддерживаемым интерпретатором, а также к функциям, тесно
взаимодействующим с интерпретатором. Изучать все переменные и функции не
имеет смысла. Даже опытные разработчики не пользуются всеми, а их в модуле
около сотни. При необходимости вы всегда сможете найти описание той или иной
функции или переменной в официальной документации.

### Запуск скрипта с параметрами

Python позволяет запускать скрипты с параметрами. Для этого после имени
исполняемого файла указываются ключи и/или значения через пробел

Например создадим файл script.py со следующим кодом.

```py
# script.py

print('start')
print('stop')
```

Открываем консоль операционный системы и вводим команду на запуск
```python3 script.py```

**!Важно! Для UNIX ОС используем команду python3. В Windows — python.!**

**!Важно! Не перепутайте консоль ОС и терминал интерпретатора Python.
Терминал выдаёт в начале строки приветствие на ввод — тройную стрелку >>>!**

Скрипт вывел текст в консоль и завершил работу. Научим его принимать значения
из командной строки.

```py
# script.py
from sys import argv

print('start')
print(argv)
print('stop')
```

Переменная argv содержит список. В нулевой ячейке имя запускаемого скрипта. В
последующих ячейках переданные значения

Например при запуске следующей строки
```python script.py -d 42 -s "Hello world!" -k 100```

получим следующий список:
>['script.py', '-d', '42', '-s', 'Hello world!', '-k', '100']

все значения переданы как строки даже числовые. Строка
“Hello world!” передана как один объект, потому что при вызове скрипта была
заключена в двойные кавычки.

Переменная argv позволяет решать простые задачи работы с командной строкой.
Если ваш будущий проект будет требовать более сложной обработки переданных в
скрипт параметров, обратите внимание на встроенный в Python модуль argparse.

## Модуль random

Модуль используется для генерации псевдослучайных чисел. Почти все функции
модуля зависят от работы функции random(), которая генерирует псевдослучайные
числа в диапазоне от нуля включительно до единицы исключительно — [0, 1).

**!Важно! Генераторы псевдослучайных чисел модуля не должны
использоваться в целях безопасности. Для обеспечения безопасности или
криптографии необходимо использовать модуль secrets.!**

Для управления состоянием используют следующие 3 функции:

- seed(a=None, version=2) — инициализирует генератор. Если значение a не
указано, для инициализации используется текущее время ПК. Версия 2
используется со времён Python 3.2 как основная. Не стоит менять её.
- getstate() — возвращает объект с текущим состоянием генератора.
- setstate(state) — устанавливает новое состоянии генератора, принимая на
вход объект, возвращаемый функцией getstate.

несколько часто используемых функции генерации чисел.

- randint(a, b) — генерация случайного целого числа в диапазоне от a
включительно до b включительно — [a, b].
- uniform(a, b) — генерация случайного вещественного числа в диапазоне от a
до b. Правая граница может как входить, так и не входить в возвращаемый
диапазон. Зависит от способа округления.
- choice(seq) — возвращает случайный элемент из непустой
последовательности.
- randrange(stop) или randrange(start, stop[, step]) работает как вложение
функции range в функцию choice, т.е. choice(range(start, stop, step)).
Возвращает случайное число от start до stop с шагом step.
- shuffle(x) — перемешивает случайным образом изменяемую
последовательность in place, т.е. не создавая новую.
- sample(population, k, *, counts=None) — выбирает k уникальных элементов из
последовательности population и возвращает их в новой последовательности.
Параметр counts позволяет указать количество повторов элемента.

Все описанные функции представлены в листинге ниже

```py
import random as rnd

START = -100
STOP = 1_000
STEP = 10
data = [2, 4, 6, 8, 42, 73]

print(rnd.random()) #0.476637596044714
rnd.seed(42) # задана отправная точка для генератора случайных чисел (что бы не угадывать числа в рандоме, рекомендуется ничего не передавать)
state = rnd.getstate() # получаем статус о состоянии функции
print(state) # (3, (2147483648, 3564348608, 1266698288, 4212342371, 3595291661, ...) - определяет как в дальнейшем будет работать генерация
print(rnd.random()) # 0.6394267984578837
rnd.setstate(state) # восстанавливаю предыдущее значение рандома
print(rnd.random()) # 0.6394267984578837

print(rnd.randint(START, STOP)) #-49
print(rnd.uniform(START, STOP)) #715.7055497358161
print(rnd.choice(data)) # выбор рандомного числа из списка - 4
print(rnd.randrange(START, STOP, STEP)) #180

print(data) # [2, 4, 6, 8, 42, 73]
rnd.shuffle(data) # перемешивает набор данных
print(data) # [8, 73, 6, 42, 2, 4]

print(rnd.sample(data, 2)) # выбираем 2 случайных числа [8, 4]
print(rnd.sample(data, 2, counts=[1, 1, 1, 1, 1, 100])) #counts должен содержать столько же элементов, сколько и в списке и обозначаем, что нужно вернуть все элименты в количестве, котором мы указали для каждого в списке count (т.е. в списке все элементы содержатся по одному разу, кроме 4, которой 100 шт.) и всего в списке получается 105 и теперь из списка 105-ти элементов нужно выбрать 2 рандомных числа - [4, 4]
```

# Проверка работы кода

```py
#test.py
import random
from sys import argv

# в индексе [0] лежит имя файла test.py
print(random.uniform(int(argv[1]), int(argv[2]))) # 510.5800034574085
print(random.randrange(int(argv[1]), int(argv[2]), int(argv[1]))) # 760
print(random.sample(range(int(argv[1]), int(argv[2]), int(argv[1])), 10)) # [330, 80, 200, 220, 840, 20, 400, 790, 340, 290]
```
