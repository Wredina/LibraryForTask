# Файлы и файловая система

- Файл(англ.file)— именованная область данных на носителе информации,
используемая как базовый объект взаимодействия с данными в
операционных системах.
- Файловаясистема(англ.filesystem)— порядок, определяющий способ
организации, хранения и именования данных на носителях информации.

# Файлы

Файл — это область данных на носителе информации (диске, флешке и т.п.). Файл
используется как базовый объект взаимодействия с данными. Операционная
система обращается к файлу по имени.

## Функция open()

В Python для получения доступа файлу используют функцию open()

```py
open(file, mode='r', buffering=-1, encoding=None, errors=None,
newline=None, closefd=True, opener=None)
```

Функция open имеет один обязательный параметр — file. Обычно file — это объект
типа str или bytes, который представляет абсолютный или относительный путь к
файлу. Относительный путь считается от каталога запуска программы. Функция
возвращает файловый объект или вызывает ошибку OSError, если не получилось
вернуть объект.

пример

```py
f = open('text_data.txt') # относительный путь и не указали кодировку, поэтому русский язык будет выводиться символьно
print(f)
print(list(f)) #полностью выведет весь текст из файла в виде списка
```

><_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
>
>['text in file\n', 'big text, very big text!\n', 'РџСЂРёРІРμС‚, РјРёСЂ!']

Файловый объект для операций текстового ввода выводу файла text_data.txt в
режиме чтения в кодировке cp1251.
Для вывода информации воспользовались превращением файлового объекта в
список: list(f). Подобный приём удобен для получения всего текстового файла
целиком в виде элементов списка. Каждая строка лежит в новой ячейке. Но если
файл имеет большие размеры, его сохранение в список может занять много
времени. Кроме того будет потрачена оперативная память. Учитывайте это при
открытии файлов больше, чем свободная ОЗУ.
Если не указывать режим открытия, файл открывается для чтения текста. При этом
в качестве кодировки по умолчанию используется кодировка ОС. И если с режимом
чтения понятно, то с кодировкой могут быть проблемы. Вот так выглядит “Привет,
мир!”, сохранённый в utf-8, но открытый в cp1251 - РџСЂРёРІРμС‚, РјРёСЂ!
Чтобы избежать проблем при работе с файлами рекомендуется при открытии
указывать как минимум три параметра: название файла, режим и кодировку

```py
# работа с text_data.txt
f = open('text_data.txt', 'r', encoding='utf-8')
print(f)
print(list(f))
```

><_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
>
>['text in file\n', 'big text, very big text!\n', 'Привет,', 'мир!\n']

**!Важно!Кодировка UTF-8 является современным стандартом для
хранения и передачи текстовой информации. Если вы явно не планируете работать с другой кодировкой, всегда указывайте encoding='utf-8' при открытии
текстовых файлов. Это обеспечит переносимость вашего кода между
различными платформами!**

## Режимы работы с файлами

- 'r' — открыть для чтения (по умолчанию)
- 'w' — открыть для записи, предварительно очистив файл
- 'x' — открыть для эксклюзивного создания. Вернёт ошибку, если файл уже
существует
- 'a' — открыть для записи в конец файла, если он существует
- 'b' — двоичный режим, работает с каким либо другм режимом, который позволяет записывать информацию при помощи набора байт
- 't' — текстовый режим (по умолчанию)
- '+' — открыты для обновления (чтение и запись)
- w+ - перезапись + чтение
  - позволяет открыть файл для записи(перезаписывания) и читать из него
  - если файла не существует - создаст

- r+ - запись + чтение
  - Позволяет открывать файл для чтения и читать из него
  - если файла не существует - будет ошибка

По умолчанию используется режим чтения текста — “rt”. Если не указать режим “t”,
он автоматически добавляется к r, w, x или a. Для чтения файла побайтно указывать
режим “b” обязательно. Режимы 'w+' и 'w+b' открывают файл для чтения и записи и
удаляют старое содержимое. Режимы 'r+' и 'r+b' открывают на чтение и запись без
удаления старой информации.

**!Важно!При открытии файла в режиме “b” информация предаётся в виде
байт. Указывать кодировку encoding при этом режиме не нужно, т.к. данные не
декодируются!**

## Метод close()

После завершения работы с файлом необходимо освободить ресурсы. Для этого
вызывается метод close().

```py
# запись в конец текста файла text_data.txt 
f = open('text_data.txt', 'a', encoding='utf-8')
f.write('Окончание файла\n')
f.close()
```

>Окончание файла

Закрытие файла гарантирует сохранение информации на носителе.

**!Важно!Если в коде отсутствует метод close(), то даже при успешном
завершении программы не гарантируется сохранение всех данных в файле!**

После закрытия файла происходит высвобождение ресурсов и переменная
файловый объект (в наших примерах — f) становится недоступна для манипуляций с
файлом

## Прочие необязательные параметры функции open

buffering — определяет режим буферизации. При работе с бинарными файлами
можно передать 0 — отключить буферизацию. В текстовом режиме можно передать
1 — использовать буферизацию строк. Число больше единицы определяет размер
буфера в байтах для двоичных файлов. По умолчанию размер буфера
подстраивается под файловую систему и обычно равен 4096 или 8192 байта

```py
# создание файла bin_data для записи бинарных данных
f = open('bin_data', 'wb', buffering=64)# буфер в 64 мб
f.write(b'X' * 1200) # набор байт которые являются символом Х
f.close()
```

>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...

errors — используется только в текстовом режиме и определяет поведение в случае
ошибок кодирования или декодирования. Рассмотрим несколько возможных
вариантов параметра:

- 'buffering' - определяет режим буферизации
- 'strict' — вызывает исключение ValueError в случае ошибки. Работает как
значение по умолчанию.
- 'ignore' — игнорирует ошибки кодирования. При этом игнорирование ошибок
может привести к потере данных.
- 'replace' — вставляет маркер замены (например, '?') там, где есть
некодируемые данные.
- 'namereplace' — при записи заменяет неподдерживаемые символы
последовательностями \N{...}

```py
f = open('data.txt', 'wb')
f.write('Привет, '.encode('utf-8') + 'мир!'.encode('cp1251'))
f.close()

f = open('data.txt', 'r', encoding='utf-8')
print(list(f)) # UnicodeDecodeError: 'utf-8' codec can't decode
byte 0xec in position 14: invalid continuation byte
f.close()

f = open('data.txt', 'r', encoding='utf-8', errors='replace')
print(list(f))
f.close()
```
