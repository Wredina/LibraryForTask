import numpy as np
from pprint import pprint

# работая с numpy нужно, что бы элементы в списке были одного типа, иначе numpy приведет все элементы к одному типу
a.ndim - размерность массива - выводит 1
a.shape -размеры массива(число строк, столбцов и т.д) - выведет (3,) т.е 3 столбца
a.size - общее количество элементов - выводит 3
a.reshape(3,2) - изменение размера массива, делает 3 строки и 2 столбца
a.transponse() - поменяет количество строк на количество столбцов и количество столбцов на количество строк.
т.е размер станет 2 строки и 3 столбца
a.ravel() - делает из многомерного массива одномерный
np.log(a) - выведет логарифмы чисел, для более удобной визуализации данных на графике

#                   1. Одномерные массивы
a = [1, 2, 3]
b = np.array(a, dtype='float64') # b у нас получится тип numpy.ndarray = [1. 2. 3.], мы указали тип данных переменной float64
print(type(b), type(a))
print(b)

# смотрим на все методы класса ndarray
pprint(set(dir(b)) - set(dir(object))) # мы взяли все методы переменой b (тип numpy.ndarray) и вычли методы объекта - тем самым оставив только методы .ndarray

# Для поиска функции в документации есть метод np.lookfor
np.lookfor('mean value of')
#Для того, что бы почитать документацию на функцию, можно поставить в начале вопросительный знак
#?np.ma.mean - НЕРАБОТАЕТ В Pycharm
# np.con*? - НЕРАБОТАЕТ В Pycharm
print()
print('Многомерный массив')
arr = np.array([[[1, 2, 3, 4],
                 [2, 3, 4, 3],
                 [1, 1, 1, 1]],
                [[1, 2, 3, 4],
                 [2, 3, 4, 3],
                 [1, 1, 1, 1]]])
print(arr)
print('len:', len(arr), '-- колчиество элементов по первой оси. Т.е количество элементов основного массива',
      '\nsize:', arr.size, '-- всего элементов в матрице.',
      '\nndim:', arr.ndim, '-- размерность матрицы. - трехмерный массив, значит равно 3',
      '\nshape:', arr.shape, '-- количество элементов по каждой оси. Т.е количество элементов в каждом массиве')
print()

# Индексы
a = np.array([1, 2, 3, 4]) # индексация как и везде
print(a[0], a[3])
a[2] = 8 # изменение элемента по индексу
print(a)
print()
# np-массивы можно использовать внутри цикла, но при этом теряется его преимущество - быстродействие

# Задача - создайте np-массив состоящий из 4 простых чисел, выведете его тип и размер

np_list = np.array([2, 3, 5, 7])
print(np_list)
print(type(np_list))
print(np_list.dtype)
print(np_list.size)
print(np_list.shape)
print()


#           Создание массивов
x = np.array([1,2,3]) - создание одномерного массива
a1 = np.zeros(7) # создаст массив из 7 нулей, по умолчанию тип элементов float64
a2 = np.zeros((3, 4)) # создаст массив из нулей 3x4, по умолчанию тип элементов float64
b1 = np.ones(7, dtype=np.int16) # создает массив из 7 единиц, мы указали тип элементов int16
b2 = np.ones((5, 7), dtype=np.int16) # создает массив из единиц  3x4, мы указали тип элементов int16
c = np.zeros_like(b2) # создает массив из нулей, размер и тип данных массива будет точно таким же как у массива b
d = np.eye(3) # создает квадратный массив из нулей с единицами по главной диагонали
# 100
# 010
# 001

# функция arange подобна функции range
a = np.arange(1, 16, 4) # создаст np-массив с элементами от 1(включительно) до 16(не включительно) с шагом 4, т.е [ 1  5  9 13]
print(a)
b = np.arange(5) # создаст np-массив с элементами от 0(включительно) до 5(не включительно) с шагом 1(по умолчанию), т.е [0 1 2 3 4]
print(b)
c = np.arange(5., 21, 2) # создаст np-массив с вещественными числами
print(c)
print()
a=arange(12).reshape(4,3) - сделает двумерный массив с 4 строками и 3мя столбцами
# выводит -
# [[0 1 2]
#  [3 4 5]
#  [6 7 8]
#  [9 10 11]]

# функция linspace

a = np.linspace(1, 15, 2) # создаст np-массив с элементами от 1(включительно) до 15(включительно), с количеством элементов =2
b = np.linspace(5, 12, 10) # создаст np-массив с элементами от 5(включительно) до 12(включительно), с количеством элементов =10
print(a)
print(b)

# Задача создать и вывести последовательность чисел от 10 до 32 с постоянным шагом, длина последовательности --12. Чему равен шаг?
c = np.linspace(10, 32, 12)
print(c)
print(c[1]-c[0])

# Последовательность чисел с постоянным шагом по логарифмической шкале от 10 в нулевой до 10 в третьей степени
b = np.logspace(0, 3, 12)
print(b)
print()

# Последовательность чисел по логарифмической шкале
n = np.logspace(0, 3, 12)  # передается показатель степени, основание по умолчанию 10, от 10 в нулевой степени до 10 в 3 степени, элементов 12
print(n)
print()

#               2. Операции над одномерными массивами
a = np.linspace(3, 33, 11)
b = np.linspace(-2, -22, 11)

print('Операции над одномерными массивами')
print(a)
print(b)
print()

print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a*5)
print(b + 10)
print('Степени')
print((a+b)**2)
print(2**(a+b))
print()

# Если типы элементов разные, то идет каст к большему
print(a + np.arange(11, dtype='int16'))
print(type(a[0]))
print()

# В numpy есть элементарные функции, которые тоже применяются к массивам поэлементно. Они называются универсальными функциями (ufunc)
print('Универсальные функции')
print(type(np.cos))
print(np.cos(a)) # косинус всех элементов массива а
# print(np.log(b)) # выведет везед nan, т.к. массив b состоит только из отрицальных чисел, а логорифм отрицательного числа - неопределен

# логические операции выполняются поэлементно
print(a > b) # [ True  True  True  True  True  True  True  True  True  True  True]
print()

# Кванторы всeобщности и существования
# Квантор существования - хотя бы для одного элемента массива выполняется условие - np.any
# Квантор всеобщности - для всех элементов массива выполняется условие - np.all
print('Кванторы всобщности и существования')
c = np.arange(0., 20)
print(c, '\n', type(c[0]))
print(np.any(c==0.), np.all(c)) # запись np.all(c)) эквивалентна np.all(c != 0))
print()

#           inplace операции - операции которые не создают какой-то объект, а меняют существующий
c += np.sin(4)
print(c)
c *= 2
print(c)
print()

# при делении на ноль в numpy не выводит ошибку
# print(np.array([0, 0, 1, -1]) / np.array([1, 0, 0, 0]))
# выведет [  0.  nan  inf -inf] это 0/1=0, 0/0=nan, 1/0=inf, -1/0=-inf,  inf - это бесконечность

#           констаты np
print(np.e, np.pi)
print()

# cumsum - в каждой ячейке элемента записывает сумму элементов от начала до этой ячейки включительно
print(a)
print(a.cumsum())
print()

#           сортировка np-массива
# 1 способ
a = np.array([1, 5, 6, 20, -4, 0, 18])
print(np.sort(a)) # сортирует np-массив но не изменяет его
print(a)

# 2 способ
a.sort() # этот метод меняет сам объект
print(a)
print()

#           Объединение np-массивов
b = np.ones(5)
c = np.hstack((a, b, 5*b)) # сделали объединенный массив, сначала у нас идут элементы массива a, затем элементы массива b, затем элементы массива b*5
print(c)
print()

#           Разделение np-массива
x1, x2, x3, x4 = np.hsplit(a, [3, 5, 6]) # исходный массив а остается без изменения, создаются новые массивы x1, x2, x3, x4 ,
# np.hsplit(a, [3, 5, 6]) - разделяется массив а до индекса 3(невключительно), затем до индекса 5(невключительно и до индекса 6(невключительно)
print(a)
print(x1)
print(x2)
print(x3)
print(x4)
print()

# функции append delete insert - не inplace функции.
print(np.delete(a, [2, 4, 1])) # выводит на экран массив а без элементов по индексам 2, 4, 1 - при этом в массиве а ничего не меняется
print(a)

print(np.insert(a, 2, [-1, -1])) # выводит на экран массив а - до индекса 2 вставляем элементы [-1, -1] - при этом в массиве а ничего не меняется
print(a)

print(np.append(a, [2.2, 2.1])) # выводит на экран массив а - элементы [2.2, 2.1] вставляются в конец массива - при этом в массиве а ничего не меняется
print(a)

# Индексирование массивов и срезы
a[::-1], a[2: 5: 2] # работает так же как и с обычными списками

b = a[0:6] # копия не создается, поэтому если поменять массив b, то поменяется и массив a
b[1] = -1000
print(a)
print()

a[1:6:3] = 0 # элементы от 1 до 6(не включительно) с шагом 3 поменяются на 0
print(a)

b = a.copy() # в этом случае создается копия массива а и при изменении массива b массив а меняться не будет

print(a[[5, 3, 1]]) # массив индексов - выведет [18  5  0] - т.е 5 индекс, 3 и 1
print()

#           Задача 3 создать массив чисел от -4пи до 4 пи количество точек 100
#           подсчитать сумму поэлементных квадратов синуса и косинуса для данного массива
#           С помощью np.all проверить, что все элементы равны единице.
print('Задача 3')
np_array = np.linspace(-4*np.pi, 4*np.pi, 100)
print(np_array)
np_array_sc = np.sin(np_array)**2 + np.cos(np_array)**2
print(np.all(np_array_sc.round() == 1))


#           3. ДВУМЕРНЫЕ МАССИВЫ

a = np.array([[1, 2], [3, 4]])
print(a)
print(a.ndim) # количество осей(размерность) =2 - двумерный массив
print(a.shape) # 2х2 - 2 строки и 2 столбца
print(len(a)) # длина элементов по первой оси =2
print(a.size) # количество элементов - 4
print()

# Обращение по индексу
a[1][1], a[1,1] # два эквивалентных варианта

# Поменять размерность данных np-массива не меняя сами данные
# 1 способ - присвоить атрибуту shape новое значение -- кортеж рамеров по всем координатам. Получится новый загловок массива, его данные не изменятся

b = np.arange(0, 20)
b.shape = (4, 5) # Меняет наш массив с одномерного на двумерный, при этом кол-во элементов должно оставаться не изменным, в нашем случае выведет - 4 массива по 5 элементов
print(b)

print(b.ravel()) # Многомерный массив складывает в одномерный
print()

a = np.ones((3, 3)) # создаст матрицу из единиц - 3х3
print(a)
b = np.zeros((3, 4)) # создаст матрицу из нулей - 3х4
print(b)
print()

c = np.eye(3) # создаст единичную матрицу 3x3
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]
print(c)

d = np.diag(np.array([1, 2, 3, 4, 6])) # создаст матрицу с диагональю 1, 2, 3, 4, 6, остальные элементы будут нулевыми
print(d)
print()

#   Задача 4
# Создать квадратную матрицу размера 8, на главной диаг. арифметическая прогрессия с шагом 3(начиная с 3)б а пообоной -1

m = np.diag(np.arange(3, 27, 3)) - np.eye(8)[::-1]
print(m)
print()

# сумма всех четных чисел по главной диагонали
result = np.trace(a*(a%2==0)) # Функция trace() вычисляет cумму диагональных элементов матрицы.
# (a%2==0) - условие дает в результате либо 1 либо 0, а умноженное на а, при 0*а=0, при 1*а=а


#       Умножение матриц

print('Умножение матриц')
a = 5*np.ones((5, 5)) # создание матрицы из любых чисел = матрица из единиц * на любое число
b = np.eye(5)+1 # создание матрицы из любых чисел с диагональю +1
print(a, '\n')
print(b)
print()
print(a*b, '\n') # поэлементное умножение
print(a @ b, '\n') # матричное умножение
print(a.dot(b)) # матричное умножение

# Двумерные массивы, зависящие только от одного индекса

u = np.linspace(1, 2, 2)
v = np.linspace(4, 8, 3)
print(u)
print(v)

x, y = np.meshgrid(u, v)
print(x, '\n')
print(y)
print()

print(x.reshape(6)) # то же самое, что и shape - делает из двумерного массива одномерный

#  Задача 5  - Отобразить вектор размера 100, в котором вычеркивается х, если х --- составное (т.е не является простым)
print('Задача 5')
is_prime = np.ones(100, dtype=bool) # создает одномерный массив со значениями True
print(is_prime)
is_prime[:2] = False
print(is_prime)
N_max = int(np.sqrt(len(is_prime))) # корень из длины массива
print(N_max)
for i in range(2, N_max):
    is_prime[2*i::i] = False # начинаем с 2i с шагом i

print(is_prime)

print(is_prime[17])
print(is_prime[25])
print()


#       Маски  - это массив булевских переменных - True или False таких же размеров, как и исходный массив
print('Маски')
a =np.arange(20) # создаем одномерный массив от 0 до 19 включительно
print(a)
print(a % 3 ==0) # выводится либо True либо False
print(a[a % 3 ==0]) # выводятся элементы соответствующие этим условиям a % 3 ==0

#       След(trace) - сумма диагональных элементов
b = np.diag(a[a >= 10]) # берется массив с диагональю из элементов массива а, которые больше 10(при этом остальные элементы матрицы равны 0)
print(b)
print(np.trace(b)) # выводится сумма диагонали массива
print()


#           4 Тензоры(многомерные массивы)
print('Тензоры')
X = np.arange(64).reshape(8, 2, 4) # содаем  многомерный массив от 0 до 64(не включительно), метод reshape делает 8 двумерных массивов,
# в которых по 2 массива , в которых по 4 элемента
print(X)

print(X.shape) # выведет (8, 2, 4) - в массиве Х 8 массивов, в каждом из которых 2 массива, в каждом из которых по 4 элемента
print(len(X)) # выведет 8, т.к количество элементов(массивов) в массиве Х по главной оси = 8
print(X.size) # выведет 64, т.к всего элементов 64
print(X.ndim) # выведет 3, т.к это размерность - у нас трехмерный массив
print(np.sum(X)) # выведет сумму всех элементов массива
print()

# Различные операции мы можем применять не только ко всему массиву целиком, а к разным его осям по отдельности

# Суммы по разным осям
print(np.sum(X, axis=0), '\n')
print(np.sum(X, axis=1), '\n')
print(np.sum(X, axis=2), '\n')

# суммируем только элементы с индесками (i, *, *)
print(np.sum(X, axis=(1, 2))) # суммируем по двум осям сразу, то есть для фиксированной i


#                5. Линейная алгебра

a = np.array([[2, 1], [2, 3]])
print(a)
print()

# Определитель
print(np.linalg.det(a)) # выведет определитель матрицы =4
print()

# Нахождение обратной матрицы
# Обратная матрица - та матрица, которая при умножении на исходную либо справа либо слева дает единичную матрицу
print('Обратная матрица')
print('Обратная матрица')
b = np.linalg.inv(a) # обратная матрица
print(b) # обратная матрица

print('Проверка Обратной матрицы')
print(a.dot(b)) # перемножение а на b
print(b.dot(a)) # перемножение b на a
print()

# Случай когда матрица не обратима
z = np.array([[2, 1],[6, 3]]) # создаем двумерную матрицу
print(z)
print(np.linalg.det(z)) # выведет определитель матрицы
# print(np.linalg.inv(z)) - пайчарм выводит ошибку, т.к. обратной матрицы для такой матрицы не существует
print()

# Решение НЛУ(неоднородные линейные уравнения)
# А - матрица
# х - столбец переменных
# v - столбец свободных членов
# A*x=v

# если v=0 такие системы называются однородными, в противном случае это неоднородные системы

v = np.array([5, -10])
print(v)
print(np.linalg.solve(a, v)) # передается сначала матрица .linalg потом столбец свободных членов - .solve(a, v)
print(b.dot(v)) # перемножаем матрицу b на v
print()

# Нахождение собственных векторов матрицы A
# A*x = лямбда * x

l, u = np.linalg.eig(a) #считаем собственный вектор - сам не понимаю как и что
print(l)
print(u)

# Собственные значения матриц А и А.Т совпадают

l, u = np.linalg.eig(a.T)
print(l)
print(u)

l, u = np.linalg.eig(np.eye(3))
print(l)
print(u)
print()

# Производительность
# %%time
sum_value = np.sum(np.arange(10**7))
print(sum_value)
# %%time
arr = 5*np.arange(10**7)
print(arr)

# Разбираем пример из МФТИ:
print('Разбираем пример из МФТИ')
X = np.array([[1,3,4],[2,4,3]])
a = 5
print(X)
X1 = np.zeros_like(X)  # создаем такой же массив, только из нулей
X1[:, ::2] = X[:, ::2] ** 3  # по всем строчкам и четным столбцам
print(X1)
X1[:, 1::2] = a  # по всем строчкам и нечетным столбцам
print(X1)
res = np.concatenate((X, X1[:, ::-1]), axis=1)  # складываем X и перевернутый X1
X[:, 0::2]=0
print(X)

                    # Условия для матриц
# 1)
a = np.array([
    [15, 23, 52],
    [68, 34, 20]
])
b = a >= 16 # будет равен
array([
    [False, True, True],
    [True, True, True]
])
# 2)
x = (a > 18) & (a < 50) # будет равен
array([
    [False, True, False],
    [False, True, True]
])
# 3)
y = (a < 18) | (a > 50) # будет равен
array([
    [True, False, True],
    [True, False, False]
])
# 4)
a[(a >= 16) & (a < 50)]

                    # Изменение размера массива
a = np.array([3,5,7,9,8,10])
print(a.ndim) # выведет размер 1 - глубина вложенности
b = a.reshape(3,2) # выведет
# array([[3, 5],
#        [7, 9],
#        [8, 10]])
x = b.transpose() # выведет
# array([[3, 7, 8],
#        [5, 9, 10]])
y = x.ravel() # выведет array([3,5,7,9,8,10])

                    # Применение функций math и др. в NumPy
a.round(4)
np.sqrt(a)
np.arange(1,10, 2) # - матрица с диапазоном от 1 до 10 с шагом 2
np.floor(a)
np.ceil(a)
np.add(a, 2) # - прибавит 2 к каждому элементу в матрице а
np.subtract(a, 1) # - вычтет 1 из каждого элемента в матрице а
np.sum(a) # - получит сумму всех элементов в массиве а
np.prod(a) # - получит произведение всех элементов в массиве а
np.datetime64('2019-02-25') # изменит дату в формат времени, с которым уже можно работать как с величиной времени

                    # СТРУКТУРИРОВАННЫЙ МАССИВ -пример создания массива с разными типами данных в нём -
info = np.array([('Anna', 19, 168), ('Sam', 33, 175.5), ('Pam', 23, 180)],
                dtype=[('name', 'U10'),('age', int),('height', float)]) # - U10 - тип данных строки записываются
# как юникодные строки, поэтому обозначается как U и 10 - это максимальное число символов в этой строке
info['name'] # выведется array(['Anna', 'Sam', 'Pam'])
info['age'] # выведется array([19, 33, 23])
info['height'] # выведется array([168., 175.5, 180.])
info[['age', 'height']] # выведется array([(19, 168.), (33, 175.5), (23, 180.)])
info['age'][0] # выведется 19

                    # Импортирование\экспортирование файлов в питон
np.save('info.npy', info) #'info.npy' - ,будущее название файла, info - нужная нам переменная с массивом который нужно сохранить
np.savetxt('info.txt', info) # сохраняет файл в тхт формат
new = np.load('info.npy') # -загружает массив из файла в наш код
np.array2string(info) # превратит массив в строку
info.tolist() # превратит в список