# Множества, set и frozenset

set - изменяемое множество

frozenset - не изменяемое множество. позволяет вычислять хеш и может использоваться там, где разрешён лишь хешированный тип данных, например в качестве ключа словаря.

Занимает большой объём в памяти, но работают быстрее

Все элементы множества уникальны, они не повторяются и не упорядочены, поэтому **не возможно**:

- обращаться по индексу

- делать срезы

- не поддерживают конкантенацию

- не поддерживают повторение

Множества включают в себя только неизменяемые типы:

- int

- float

- bool

- в set может входить frozenset

- string

- tuple

Множества поддерживают математические операции (set и frozenset):

- пересечение

- объединение

- дополнение

- резность

- симметрическую разность

**Создание множеств**

- set() - пустое множество

- {el1, el2, el3} - перечисление в фигурных скобках

- frozenset((el1, el2, el3)) - создание неизменяемого множества

- set('text') - создаст множество {'t', 'e', 'x', 't'}

- set('text1 text2 text3'.split()) - создаст множество {'text1', 'text2', 'text3'}

- set([el1, el2, el3]) - создаст множество из списка

- set((el1, el2, el3)) - создаст множество из кортежа

- set({key1: value1, key2: value2}) - создаст множество из словаря (будут доступны только ключи)

- set(str(num)) - число нельзя на прямую преобразовать в множество. Для этого его нужно перевести в строку

- List Comprehension - генератор

**методы и функции**

- add() - добавляет элемент в множество, может добавить только один элемент. если передать неизменяемую коллекцию, например кортеж, коллекция будет добавлена как один целостный объект.

- remove() - удаляет элемент, если этого элемента нет, будет ошибка

- discard() - удаляет элемент, если этого элемента нет, ошибки не будет

- intersection() - & - создаёт **новое** множество из пересечения множеств set_1 и set_2. исходные множества не меняются

- union() - создаёт **новое** множество из объединения множеств, |

- difference() - создаёт **новое** множество из разности множеств, -

- in / not in - проверка на вхождение (True/False)

- min() - минимальное значение элементов

- max() - максимальное значение элементов

- sum() - суммва элементов

- len() - длина множества

- sorted() - сортировка множества, выдаст список

- == и != - сравнение множеств

- \> и < - определение, является ли множество под или над множеством (множество_1 считается *подмножеством* множества_2 в том случае, если все элементы множества_1 входят в множество_2. В этом случае множество_2 считается *надмножеством* множества_1. При этом любое множество считается подмножеством самого себя, или *нестрогим множеством*)

  - set_1.issuperset(set_2) - set_1 <= set_2 (нестрогое подмножество) - set_1 < set_2 (строгое подмножество) - возвращает True, если set_1 является подмножеством set_2 и False если нет

  - set_1.issubset(set_2) - set_1 => set_2 (нестрогое надмножество) - set_1 > set_2 (строгое надмножество) - возвращает True, если set_1 является надмножеством set_2 и False если нет

- pop () - удаляет случайный элемент и возвращает его

- clear() - удаляет все элементы множества сразу

- symmetric_difference() - ^ - симметрическая разность (множество, состоящее из элементов, которые не входят в первое и второе множество одновременно)

- update() - |= - изменяет исходное множество по объединению

- intersection_update() - &= - изменяет исходное множество по пересечению

- difference_update() - -= - изменяет исходное множество по разности

- symmetric_difference_update() - ^= - изменяет исходное множество по симметрической разности

- isdisjoint() - возвращает True, если множества не имеют общих элементов, и False, если такие элементы есть

## Примеры

- создание множеств

```py
my_set = {1, 2, 3, 4, 2, 5, 6, 7}
print(my_set)
# {1, 2, 3, 4, 2, 5, 6, 7}

my_f_set = frozenset((1, 2, 3, 4, 2, 5, 6, 7,))
print(my_f_set)
# frozenset({1, 2, 3, 4, 2, 5, 6, 7})

not_set = {1, 2, 3, 4, 2, 5, 6, 7, ['a', 'b']} # TypeError - множество не принимают изменяемый объект - тут список

print(set('абырвалг'))
# {'р', 'в', 'л', 'г', 'б', 'а', 'ы'}

print(set('Множества в Python'.split()))
# {'Множества', 'в', 'Python'}
```

- создание множества из списка

```py
print(set([3, 6, 4, 5, 5]))
# {3, 4, 5, 6}
```

- создание множества из кортежа

```py
print(set(('красный', 'синий', 'зеленый')))
# {'зеленый', 'красный', 'синий'}
```

- создание множества из словаря

```py
print(set({'артикул': 'А123', 'цвет': 'черный'}))
# {'артикул', 'цвет'}
```

- преобразование числа во множество

```py
print(set(123))
# TypeError - число нельзя преобразовать во множество

print(set(str(1812))) # что бы преобразовать число во множество, его нужно преобразовать в строку
# {'8', '2', '1'}
```

- вхождение frozenset в set

```py
set_a = {1, 2, 3}
set_b = frozenset({4, 5, 6})
set_c = {7, 8, 9, set_a} # в set вложили set
# TypeError: unhashable type: 'set'

set_c = {7, 8, 9, set_b}
print(set_c) # в set вложили frozenset
# {8, 9, frozenset({4, 5, 6}), 7}
```

- игнорирование повторения

```py
my_set = {2, 2, 2}
print(my_set)
# {2}
```

- List Comprehension - генератор

```py
print({i ** 2 for i in range(15)}) # генератор в фигурных скобках
# {0, 1, 64, 121, 4, 36, 100, 196, 9, 169, 16, 49, 81, 144, 25}

print({int(i) for i in '3в2о7ыр3р74ртрчфрежр4рфф23468795323' if i.isdigit() and int(i) < 7}) # вывести из строки все цифры меньше 7-ми
# {2, 3, 4, 5, 6}

print({ord(i) for i in input() if i.isalpha()}) # ввели в инпут строку ewr73694yrhf897349ugg05fhshcvnaWQXXldoaxsd, ord() - возвращает числовой код символа
# {81, 87, 88, 97, 99, 100, 101, 102, 103, 104, 108, 110, 111, 114, 115, 117, 118, 119, 120, 121}

set_a = {i ** 2 if i % 2 == 0 else i ** 3 for i in (map(int, input().split()))} # если число кратно 2-м - умножить на 2, иначе умножить на 3
# в инпут ввели 2 5 12 13 4 56 71 33 9 10
print(set_a)
#{3136, 35937, 4, 100, 144, 16, 2197, 357911, 729, 125}
```

- min(), max(), sum(), len()

```py
set_a = {2, 4, 5, 6, 1, 9, 7, 12}
print(f'Количество элементов: {len(set_a)}, сумма элементов: {sum(set_a)}')
# Количество элементов: 8, сумма элементов: 46

print(f'Минимальный элемент: {min(set_a)}, максимальный элемент: {max(set_a)}')
# Минимальный элемент: 1, максимальный элемент: 12
```

- in

```py
my_set = {'математика', 'физика', 'химия'}
print('математика' in my_set)
# True

print('биология' not in my_set)
# True
```

- add()

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.add(9)
print(my_set)
# {1, 2, 3, 4, 5, 6, 7, 9}

my_set.add(7) # такое значение уже есть, поэтому оно проигнорируется
print(my_set)
# {1, 2, 3, 4, 5, 6, 7, 9}

my_set.add(9, 10) # TypeError - множество может добавлять элементы по одному
my_set.add((9, 10)) # добавление кортежа как одного элемента
print(my_set)
# {(9, 10), 1, 2, 3, 4, 5, 6, 7, 9}
```

- remove()

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.remove(5)
print(my_set)
# {3, 4, 2, 6, 1, 7}

my_set.remove(10) # KeyError - такого элемента во множестве нет
```

- discard()

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.discard(5)
print(my_set)
# {3, 4, 2, 6, 1, 7}

my_set.discard(10) # элемента нет, но и ошибки нет
```

- intersection(), & - пересечение

```py
my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.intersection(other_set)
print(f'{my_set = }\n{other_set = }\n{new_set = }')
# my_set = {3, 4, 2, 5, 6, 1, 7}
# other_set = {1, 4, 42, 314}
# new_set = {1, 4}

my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set & other_set # вместо intersection() используем &
print(f'{my_set = }\n{other_set = }\n{new_set = }') # вывод такой же
# my_set = {3, 4, 2, 5, 6, 1, 7}
# other_set = {1, 4, 42, 314}
# new_set = {1, 4}

friends = {'vasya': ('спальник', 'чайник', 'кастрюля'),
           'ilya': ('спальник', 'вилка', 'нож'),
           'katya': ('спальник', 'ложка', 'нож')}

all_items = set.intersection(*[set(i) for i in friends.values()])
print(f'Какие вещи взяли все три друга {all_items}')
# Какие вещи взяли все три друга {'спальник'}
```

- union(), | - объединение

```py
my_set = {1, 2, 3, 4, 5, 6, 7}
other_set = {1, 42, 4, 314}
new_set = my_set.union(other_set)
print(f'{my_set = }\n{other_set = }\n{new_set = }')
# my_set = {1, 2, 3, 4, 5, 6, 7}
# other_set = {1, 42, 4, 314}
# new_set = {1, 2, 3, 4, 5, 6, 7, 42, 314}

new_set_2 = my_set | other_set # вместо union() используем |
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')
# my_set = {1, 2, 3, 4, 5, 6, 7}
# other_set = {1, 42, 4, 314}
# new_set = {1, 2, 3, 4, 5, 6, 7, 42, 314}

friends = {'vasya': ('спальник', 'чайник', 'кастрюля'),
           'ilya': ('спальник', 'вилка', 'нож'),
           'katya': ('спальник', 'ложка', 'нож')}

items_uni = set.union(*[set(i) for i in friends.values()])
print(f'Какие вещи уникальны, есть только у одного друга {items_uni}')
# Какие вещи уникальны, есть только у одного друга {'спальник', 'кастрюля', 'вилка', 'чайник', 'нож', 'ложка'}
```

- difference(), - - разность

```py
my_set = {1, 2, 3, 4, 5, 6, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.difference(other_set)
print(f'{my_set = }\n{other_set = }\n{new_set = }')
# my_set = {1, 2, 3, 4, 5, 6, 7}
# other_set = {1, 42, 4, 314}
# new_set = {2, 3, 5, 6, 7}

new_set_2 = my_set - other_set # вместо difference() используем -
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')
# my_set = {1, 2, 3, 4, 5, 6, 7}
# other_set = {1, 42, 4, 314}
# new_set = {2, 3, 5, 6, 7}
```

- sorted()

```py
numbers = {25, 15, 7, 8, 19, 34, 52, 0, 12, 59, 91, 4}
print(sorted(numbers))
# [0, 4, 7, 8, 12, 15, 19, 25, 34, 52, 59, 91]

print(sorted(numbers, reverse=True))
# [91, 59, 52, 34, 25, 19, 15, 12, 8, 7, 4, 0]
```

- == и != - сравнение множеств

```py
set_a = {5, 1, 4, 8, 6, 9}
set_b = {6, 2, 5, 9, 7, 10}
print(set_b != set_a)
# True
```

- pop()

```py
my_set = {2, 4, 6, 1, 12}
print(my_set.pop())
# 1
```

- clear()

```py
my_set = {6, 2, 9, 0}
my_set.clear()
print(my_set)
# set()
```

- symmetric_difference(), ^

```py
set_a = {1, 2, 3, 4}
set_b = {6, 8, 4, 3}
print(set_a.symmetric_difference(set_b))
# {1, 2, 6, 8}

set_a = {'h', 'v', 'a', 'w', 'q'}
set_b = {'v', 'h', 'u', 'f', 'o'}
print(set_a ^ set_b) # использование символа ^ работает так же
# {'u', 'w', 'f', 'q', 'a', 'o'}
```

- update(), |=

```py
set_a = {1, 2, 3}
set_b = {4, 5, 6}
set_a.update(set_b)
print(set_a) # добавили в первое множество второе
# {1, 2, 3, 4, 5, 6}

set_a = {'a', 'b', 'd'}
set_b = {'c', 'e', 'f'}
set_a |= set_b # |= работает так же
print(set_a)
# {'b', 'c', 'f', 'a', 'e', 'd'}
```

- intersection_update(), &=

```py
set_a = {1, 2, 3}
set_b = {3, 4, 5}
set_a.intersection_update(set_b) # перезаписали первое множество внеся только то, что есть в первом и втором множестве
print(set_a) 
# {3}

set_a = {'a', 'b', 'd', 'q'}
set_b = {'h', 'f', 'b', 'a'}
set_a &= set_b # &= работает так же
print(set_a)
# {'a', 'b'}
```

- difference_update(), -=

```py
set_a = {3, 2, 7, 8, 0}
set_b = {4, 5, 6, 3, 8}
set_a.difference_update(set_b) # перезаписали первое множество, внеся в него то, что есть в первом множестве, но нет во втором
print(set_a)
# {0, 2, 7}

set_a = {'v', 's', 'a', 'q', 'r'}
set_b = {'d', 's', 'a', 'f', 'e'}
set_a -= set_b # -= работает так же
print(set_a)
# {'q', 'r', 'v'}
```

- symmetric_difference_update(), ^=

```py
set_a = {1, 2, 3, 4, 5}
set_b = {8, 2, 4, 6, 1}
set_a.symmetric_difference_update(set_b) # перезапись первого множества, внеся в него разность первого и второго множества
print(set_a)
# {3, 5, 6, 8}

set_a = {'a', 'k', 'r', 'o', 'p'}
set_b = {'d', 'a', '$', 'o', '@'}
set_a ^= set_b # ^= работает так же
print(set_a)
# {'@', 'p', 'd', 'k', 'r', '$'}
```

- issuperset(), < , <=

```py
set_a = {1, 2, 3}
set_b = {4, 5, 1, 2, 3}
print(set_a.issubset(set_b)) # первое множество является подмножеством второго множества
# True

print(set_a <= set_b) # нестрогое подмножество (любое множество считается подмножеством самого себя)
# True

print(set_a < set_b) # строгое подмножество
# True
```

- issubset(), >, >=

```py
set_a = {'XS', 'S', 'M', 'L', 'XL', 'XXL'}
set_b = {'S', 'M', 'L'}
print(set_a.issuperset(set_b)) # первое множество является надмножеством второго
# True

print(set_a > set_b) # строгое надмножество
# True

print(set_a >= set_b) # нестрогое надмножество
# True
```

- isdisjoint()

```py
set_a = {1, 2, 3}
set_b = {4, 5, 6}
set_c = {1, 3, 5}
print(set_a.isdisjoint(set_b)) # первое множество не имеет общих эл-тов со вторым
# True

print(set_c.isdisjoint(set_b)) # третье множество имеет общие эл-ты со вторым
# False
```
