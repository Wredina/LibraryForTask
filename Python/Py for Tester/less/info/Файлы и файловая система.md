# Файловая система

**открытие и закрытие файла**

- with - менеджер контекста. гарантирует закрытие файла и сохранения информации даже если будут ошибки. Используется вместе с open(). with open(faile, mode, encoding='utf-8') as f: - открыть файл под именем f. Может открывать несколько файлов одновременно.

- open() - используется для доступа к файлу, по умолчанию на чтение. Имеет обязательный параметр file. Может быть вложен в переменную. f = open(file)

  - open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) - параметр file - это объект типа str или bytes, который представляет абсолютный или относительный путь к файлу

    - encoding - используемая кодировка. по умолчанию cp1251. Рекомендуется использовать utf-8. При работе с бинарными данными никакая кодировка не прописывается

      - encode() - при записи можно использовать разные кодировки. f.write('Привет, '.encode('utf-8') + 'мир!'.encode('cp1251')). Можно использовать для бинарной информации.

    - buffering — определяет режим буферизации (при работе с бинарным кодом)

      - 0 — отключить буферизацию

      - 1 — использовать буферизацию строк.

      - Число больше единицы определяет размер буфера в байтах для двоичных файлов. По умолчанию размер буфера подстраивается под файловую систему и обычно равен 4096 или 8192 байта.

    - errors — используется только в текстовом режиме и определяет поведение в случае ошибок кодирования или декодирования

      - 'strict' — вызывает исключение ValueError в случае ошибки. Работает как значение по умолчанию.

      - 'ignore' — игнорирует ошибки кодирования. При этом игнорирование ошибок может привести к потере данных.

      - 'replace' — вставляет маркер замены (например, '?') там, где есть некодируемые данные.

      - 'namereplace' — при записи заменяет неподдерживаемые символы последовательностями \N{...}.

    - newline — отвечает за преобразование окончания строки

    - closefd — указывает оставлять ли файловый дескриптор открытым при закрытии файла

    - opener — позволяет передать пользовательскую функцию для открытия файла.

- close() - завершение работы с файлом. Это гарантирует сохранение всех изменений в файле

**Режимы работы c файлами (моды)**

- 'r' — (read) - открыть для чтения (по умолчанию)

  - если файла нет, то программа выдаст ошибку

- 'w' — открыть для записи, предварительно очистив файл

  - если файла не существует - создаст

- 'x' — открыть для эксклюзивного создания.

  - если файла не существует, то он создаться и туда начнётся запись

  - Вернёт ошибку, если файл уже существует

- 'a' — (append) - открыть для записи в конец файла, если он существует

  - если файла не существует, то он создаться и туда начнётся запись

- 'b' — двоичный режим

- 't' — текстовый режим (по умолчанию 'rt')

- '+' — открыты для обновления (чтение и запись) (для чтения и записи в двоичном режиме нужно явно указывать режим 'b')

  - 'w+' - перезапись + чтение. позволяет открыть файл для записи(перезаписывания) и читать из него. если файла не существует - создаст

  - 'r+' - запись + чтение. Позволяет открывать файл для записи и читать из него. если файла не существует - будет ошибка

  - 'w+b' - открывают файл для чтения и записи и удаляют старое содержимое для побайтного файла

  - 'r+b' - открывают на чтение и запись без удаления старой информации для побайтного файла

**Чтение и запись файла**

- list() - чтение файла в списке

- read() - читает весь файл. Не добавляются символы переноса в конце

  - read(n = -1) - читает n символов или n байт информации. Если n отрицательное или не указана, читает весь файл. Попытка чтения будет даже в том случае, когда файл больше оперативной памяти.

- readline() - чтение файла построчно. При чтении readline возвращает строку с символом переноса на конце.

- for line in file - построчное чтение файла при помощи цикла for. будет присутствовать символ переноса.

- write() - запись. принимает строку или набор байт. После записи возвращает количество записанной информации. Не добавляет в конец символ переноса. Для переноса нужно его явно указывать.

- writelines() - принимает последовательность и записывает каждый элемент в файл. Элементы последовательности должны быть строками или байтами. Метод ничего не возвращает. Записывает всё в одну большую строчку

- print(line, file=f) - печать в файл. Добавляет перенос строки. Можно явно изменить параметр end в функции

**Перемещения в фале**

- tell() - возвращает текущую позицию курсора в файле

- seek(offset, whence=0) - изменение положения курсора

  - offset - число, положительное или отрицательное. смещение относительно опорной точки

  - whence - способ выбора опорной точки

    - whence=0 - отсчёт от начала файла

    - whence=1 - отсчёт от текущей позиции в файле

    - whence=2 - отсчёт от конца файла

- truncate(size=None) - изменяет размер файла. Если не передать значение в параметр size будет удалена часть файла от текущей позиции до конца. Метод возвращает позицию после изменения файла.

**Каталоги**

- os.getcwd() - получение информации о текущем каталоге (import os) - старый вариант

  - os.chdir('../..') - изменение дирректории

  - os.mkdir('new') - создание дирректории

    - os.makedirs('dir/other_dir/new_os_dir') - создание несколько вложенных друг в друга дирректорий

  - os.rmdir('dir') - удаление каталога (удалять можно только пустые каталоги)

    - os.rmdir('dir/other_dir/new_os_dir') - удаление последнего каталога из цепочки (удалять можно только пустые каталоги)

  - file = os.path.join(os.getcwd(), 'dir', 'new_file.txt') - формирование нового пути для файла

  - os.listdir() - получение списка с информацией о дирректориях и файлах в текущей папке

    - isdir(obj) - возвращает True/False если папка/не папка

    - isfile(obj) - возвращает True/False если файл/не файл

    - islink(obj) - возвращает True/False если ссылка/не ссылка

  - os.walk() - выведет информацию о каталоге, который ей передать, включаю всю информацию о содержимых всех каталогах внутри. Т.е. функция пройдёт по всем папкам и всем файлам. (возвращает три значения: абсолютный путь до каталога, список с названиями всех каталогов внутри каталога и список названий всех файлов)

  - os.rename('name.py', 'new_name.py') - переименовывание файла

  - os.replace() - перенос файла в другую дирректорию

  - os.remove() - удалит файл

- pathlib.Path.cwd() - получение информации о текущем каталоге (import pathlib from Path) - современный вариант

  - Path('new').mkdir() - создание дирректории

    - Path('some_dir/dir/new_path_dir').mkdir(parents=True) - создание несколько вложенных друг в друга дирректорий

  - Path('some_dir').rmdir() - удаление каталога (удалять можно только пустые каталоги)

    - Path('some_dir/dir/new_path_dir').rmdir() - удаление последнего каталога из цепочки (удалять можно только пустые каталоги)

  - file_2 = Path().cwd() / 'dir' / 'new_file.txt' - формирование нового пути для файла

  - iterdir() - генератор который в цикле возвращает объекты из выбранной дирректории

    - is_dir() - возвращает True/False если папка/не папка

    - is_file() - возвращает True/False если файл/не файл

    - is_symlink() - возвращает True/False если ссылка/не ссылка

  - Path('name.py').rename('new_name.py') - переименовывание файла

  - replace() - перенос файла в другую дирректорию

  - unlink() - удаление файла

- shutil.rmtree('some_dir') - удаление каталога вместе с его содержимым (import shutil)

  - shutil.rmtree('dir/other_dir') - удалит последний каталог из цепочки вместе со всем содержимым

  - shutil.rmtree('dir') - удаление всег

- shutil.copy() - копирование файлов игнорируя метаданные (доп. информация о файле, где, когда и как создан и т.д.)

  - shutil.copy2() - копирование файла с попыткой сохранить и метаданные

  - shutil.copytree() - копирование каталога со всем содержимым в новое место (со всеми каталогами и файлами)

**Примеры**

- open()

```py
# создали текстовый файл text.txt с английским текстом внутри, в конце которого по русски "Привет мир!". и что бы файл открыть используем функцию open()

f = open('text_data.txt') # файл находится в одной папке с питоновским
print(f)
print(list(f))
# <_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'РџСЂРёРІРµС‚, РјРёСЂ!\n']

# По умолчанию используется кодировка cp1251, поэтому русский текст выглядит - 'РџСЂРёРІРµС‚, РјРёСЂ!\n'
```

- open(file, encoding=None)

```py
# создали текстовый файл text.txt с английским текстом внутри, в конце которого по русски "Привет мир!". и что бы файл открыть, используем функцию open()

f = open('text_data.txt', encoding='utf-8') # задаём кодировку
print(f)
print(list(f))
# <_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'Привет мир!\n']
```

- 'a' — (append), close()

```py
# создали текстовый файл text.txt
f = open('text_data.txt', 'a', encoding='utf-8')
f.write('Окончание файла\n') # запись в конец файла
f.close() # закрытие файла

# если перезапусить код, фраза "Окончание файла" добавится ещё раз
```

- buffering

```py
f = open('bin_data', 'wb', buffering=64) # создание файла bin_data для записиси бинарных данных 
f.write(b'X' * 1200) # передаём бинарный символ X. умножение на 1200 говорит о том, что этих Х должно быть на 1200 байт
f.close()

```

- encoding, encode(), errors, r

```py
f = open('data.txt', 'wb') # создали файл для бинарной информации
f.write('Привет, '.encode('utf-8') + 'мир!'.encode('cp1251')) # записываем Привет в кодировке utf-8, и мир в кодировке cp1251
f.close()


f = open('data.txt', 'r', encoding='utf-8') # открытие того же файла для чтения
print(list(f)) # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xec in position 14: invalid continuation byte (из-за того, что было записано в документ 2 разные кодировки, он не смог прочесть ср1251)
f.close()


f = open('data.txt', 'r', encoding='utf-8', errors='replace') # обработка ошибки, файл прочитается, но на месте, где будет кодировка ср1251 будут ???.
print(list(f))
f.close()
# ['Привет, ???!']
```

- with

```py
# открытие и печать одного файла
with open('text_data.txt', 'r+', encoding='utf-8') as f:
  print(list(f))

# открытие и печать нескольких файлов одновременно
with open('text_data.txt', 'r+', encoding='utf-8') as f1, \
  #тут просто текстовый файл 
  open('bin_data', 'rb') as f2, \
  # файл с бинарной информацией в котором много Х
  open('data.txt', 'r', encoding='utf-8', errors='backslashreplace') as f3: \
  # текст 'Привет,' - в кодировке utf-8 и текст 'мир!' в кодировке ср1251. Обработка ошибки при помощи обратного слэша - символов экранирования
  print(list(f1))
  print(list(f2))
  print(list(f3))
# ['text1 for test1\n', 'text2 for test1\n']
# [b'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX']
# ['Привет, \\xec\\xe8\\xf0!']

#пример как выше, только при помощи круглых скобок
with (
      open('text_data.txt', 'r+', encoding='utf-8') as f1,
      open('bin_data', 'rb') as f2,
      open('data.txt', 'r', encoding='utf-8', errors='backslashreplace') as f3
):
    print(list(f1))
    print(list(f2))
    print(list(f3))
```

- list()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  print(list(f))
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'Привет мир!\n']
```

- read()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  res = f.read()
  print(f'Читаем первый раз\n{res}')
  res = f.read() # попытка прочесть файл второй раз вернёт пустую строку.
  print(f'Читаем второй раз\n{res}') 
# Читаем первый раз
# text for tests
# text2 for tests2.
# ......
# Привет мир!
#
# Читаем второй раз
#

SIZE = 100 # выставляем ограничения на 100 символов
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.read(SIZE): # Считает по 100 символов
    print(res)
# text for tests
# text2 for tests2.
# ......

# text50 for tests50
# text51 for tests51
# ......

# ......
# Привет мир!
```

- readline()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.readline(): # метод передаёт переход строки на новый
    print(res) # тоже даёт символ перехода на новую строку, поэтому будет выводиться через строку (два переноса)
# text for tests
#
# text2 for tests2.
#
# ......
#
# Привет мир!

# т.к. текст у меня короткий, буду показывать на нём
SIZE = 100 # ограничения в 100 символов
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.readline(SIZE): # ограничение в 100 символос строки
    print(res) # если строка длинее 100 символов, будет один перенос строки, т.к. в месте ограничения нет символа переноса.
# text for tests
#
# text2 for te
# sts2.
#
# .......
# .......
# ...
#
# Привет мир!
```

- for line in file

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  for line in f:
    print(line, end='') # убираем из принт переносы т.к. в строке есть свои символы переноса
# text for tests
# text2 for tests2.
# ......
# Привет мир!

# для работы без переноса строки
with open('text_data.txt', 'r', encoding='utf-8') as f:
  for line in f:
    print(line[:-1]) # отрезает два последних символа
    print(line.replace('\n', '')) # заменяет символ переноса на пустую строку
# text for tests
# text for tests
# text2 for tests2.
# text2 for tests2.
# ......
# ......
# Привет мир!
# Привет мир!
```

- write()

```py
text = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'
with open('new_data.txt', 'a', encoding='utf-8') as f: # открывается файл для записи
  res = f.write(text)
  print(f'{res = }\n{len(text) = }') # сколько символов записано
# res = 57
# len(text) = 57


text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f: # открывается файл для записи
  for line in text: # для каждой строки с текстом
    res = f.write(line) # записываем информацию
    print(f'{res = }\n{len(line) = }') # сколько символов было записано
# res = 57
# len(text) = 57
# res = 73
# len(text) = 73
# res = 72
# len(text) = 72
#
# в файл всё запишется одной строкой т.к. write не добавляет символа переноса строки

# делаем с переносом строки
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    res = f.write(f'{line}\n') # добавляем символ переноса в конец
    print(f'{res = }\n{len(line) = }') # длина res стала на 1 больше из-за символа переноса
# res = 58
# len(text) = 57
# res = 74
# len(text) = 73
# res = 73
# len(text) = 72
# 
# в файле каждая строчка перенесётся на новую
```

- writelines()

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  f.writelines('\n'.join(text)) # запись в одну строчку, join между каждой строчкой добавляет символ переноса
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?
```

- print(line, file=f), end=''

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    print(line, file=f) # не вывела в консоль а записала всё в файл

# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?

# но если в файле будет уже какая-то информация, принт сконкатенирует предыдущую строку со следующей, будет примерно так:

# text for tests
# text2 for tests2.Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?


text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    print(line, end='***\n##', file=f)
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.***
# ##Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?***
# ##Accusantium alias amet fugit iste neque non odit quia saepe totam velit?***
# ##
```

- tell()

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  print(f.tell()) # файл открыт, но ещё ничего не записано, находимся в самом начале файла
  for line in text:
    f.write(f'{line}\n')
    print(f.tell()) # печатаем местоположение курсора после каждой записи
  print(f.tell()) # положение курсора после завершения цикла
print(f.tell()) # ValueError: т.к. вышли из тела with и файл закрылся
# 0
# 59
# 134
# 208
# 208
```

- seek(offset, whence=0), r+

```py
last = before = 0 # хранят позиции двух последних прочитанных строк
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'r+', encoding='utf-8') as f: # открываем для чтнения и записи
  while line := f.readline():
    last, before = f.tell(), last # в last помещаем значение текущего положения курсора, а в before - предыдущее значение last
    print(f'{last = }, {before = }') # выводим позиции после каждой итерации
  print(f'{last = }, {before = }') # выыодим значения после цикла
  print(f'{f.seek(before, 0) = }') # устанавливаем позицию курсора на позицию 134 (before), и 0 - отсчёт идёт от начала файла
  f.write('\n'.join(text)) # записываем в файл ещё текст
# last = 59, before = 0
# last = 59, before = 59
# last = 208, before = 134
# last = 208, before = 134
# f.seek(before, 0) = 134

# при помощи цикла запишется 3 строчки текста, потом перемещаем курсор на конец второй строчки и перезаписываем информацию(ещё три строчки)

# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?
```

- truncate(size=None)

```py
last = before = 0
with open('new_data.txt', 'r+', encoding='utf-8') as f:
  while line := f.readline():
    last, before = f.tell(), last # в last помещаем значение текущего положения курсора, а в before - предыдущее значение last
  print(f.seek(before, 0)) # перемещаем курсор на положение предпоследнего местоположения
  print(f.truncate()) # обрезаем текст в файле от текущего положения курсора до конца
# 268
# 268



size = 64
with open('new_data.txt', 'r+', encoding='utf-8') as f:
  print(f.truncate(size)) # обрезать файл по значению size (оставит 64 символа)

# 64
```

- os.getcwd(), pathlib.Path.cwd() / from pathlib import Path

```py
import os
from pathlib import Path


print(os.getcwd())
print(Path.cwd())
# D:\программирование\MyBibliotecForTask
# D:\программирование\MyBibliotecForTask
```

- os.chdir('../..')

```py
import os
from pathlib import Path


print(os.getcwd())
print(Path.cwd())
os.chdir('../..')
print(os.getcwd())
print(Path.cwd())
# D:\программирование\MyBibliotecForTask
# D:\программирование\MyBibliotecForTask
# D:
# D:
```

- os.mkdir('new'), Path('new').mkdir()

```py
import os
from pathlib import Path

os.mkdir('new_os_dir')
Path('new_path_dir').mkdir()
# появляются 2 новые папки new_os_dir и new_path_dir
```

- os.makedirs('dir/other_dir/new_os_dir'), Path('some_dir/dir/new_path_dir').mkdir(parents=True)

```py
import os
from pathlib import Path


os.makedirs('dir/other_dir/new_os_dir')
Path('some_dir/dir/new_path_dir').mkdir() # FileNotFoundError
Path('some_dir/dir/new_path_dir').mkdir(parents=True)
# D:\программирование\MyBibliotecForTask\dir\other_dir\new_os_dir
# D:\программирование\MyBibliotecForTask\some_dir\dir\new_path_dir
```

- os.rmdir('dir'), os.rmdir('dir/other_dir/new_os_dir'), Path('some_dir').rmdir(), Path('some_dir/dir/new_path_dir').rmdir()

```py
import os
from pathlib import Path

os.rmdir('dir') # OSError - т.к. каталог не пустой
Path('some_dir').rmdir() # OSError - т.к. каталог не пустой
os.rmdir('dir/other_dir/new_os_dir') # удаление последней пустой папки из цепочки
Path('some_dir/dir/new_path_dir').rmdir() # удаление последней пустой папки из цепочки
```

- shutil.rmtree('some_dir'), shutil.rmtree('dir/other_dir')

```py
import shutil

shutil.rmtree('dir/other_dir') # удаление последней папки с информацией
shutil.rmtree('some_dir') # удаление папки с информацией
```

- file_1 = os.path.join(os.getcwd(), 'dir', 'new_file.txt'), file_2 = Path().cwd() / 'dir' / 'new_file.txt'

```py
import os
from pathlib import Path

file_1 = os.path.join(os.getcwd(), 'dir', 'new_file.txt') # берём текущую рабочую дирректорию, потом dir и new_file.txt (возвращает строку)
print(f'{file_1 = }\n{file_1}')

file_2 = Path().cwd() / 'dir' / 'new_file.txt' # собирает путь из текущей дирректории (использует правильное формирование пути отталкиваясь от ОС)
print(f'{file_2 = }\n{file_2}')

# file_1 = D:\\программирование\\MyBibliotecForTask\\dir\\new_file.txt
# D:\программирование\MyBibliotecForTask\dir\new_file.txt
# file_2 = WindowPath('D:/программирование/MyBibliotecForTask/dir/new_file.txt')
# D:\программирование\MyBibliotecForTask\dir\new_file.txt
```

- os.listdir(), iterdir()

```py
import os
from pathlib import Path

print(os.listdir()) # список каталогов и файлов

p = Path(Path().cwd())
for obj in p.iterdir(): # итерация по всем файлам и каталогам внутри дирректории
  print(obj)

# ['.git', '.gitignore', '.pytest_cache', '.vscode', 'html_css', 'Java', 'JS', 'Python', 'Tester', 'С#']
# D:\программирование\MyBibliotecForTask\.git
# D:\программирование\MyBibliotecForTask\.gitignore   
# D:\программирование\MyBibliotecForTask\.pytest_cache
# D:\программирование\MyBibliotecForTask\.vscode      
# D:\программирование\MyBibliotecForTask\html_css     
# D:\программирование\MyBibliotecForTask\Java
# D:\программирование\MyBibliotecForTask\JS
# D:\программирование\MyBibliotecForTask\Python
# D:\программирование\MyBibliotecForTask\Tester
# D:\программирование\MyBibliotecForTask\С#
```

- isdir(obj), isfile(obj), islink(obj), is_dir(), is_file(), is_symlink()

```py
import os
from pathlib import Path

dir_list = os.listdir()
for obj in dir_list:
  print(f'{os.path.isdir(obj) = }', end='\t')
  print(f'{os.path.isfile(obj) = }', end='\t')
  print(f'{os.path.islink(obj) = }', end='\t')
  print(f'{obj = }')

p = Path(Path().cwd())
for obj in p.iterdir():
  print(f'{obj.is_dir() = }', end='\t')
  print(f'{obj.is_file() = }', end='\t')
  print(f'{obj.is_symlink() = }', end='\t')
  print(f'{obj = }')
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.git'
# os.path.isdir(obj)=False os.path.isfile(obj)=True       os.path.islink(obj)=False       obj='.gitignore'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.pytest_cache'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.vscode'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='html_css'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Java'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='JS'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Python'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Tester'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='С#'
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.git')
# obj.is_dir()=False      obj.is_file()=True      obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.gitignore')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.pytest_cache')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.vscode')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/html_css')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Java')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/JS')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Python')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Tester')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/С#')
```

- os.walk()

```py
import os

for dir_path, dir_name, file_name in os.walk(os.getcwd()): # возвращает 3 значения: название дерриктории, имя дирректории которая находится внутри и имя найденных файлов
  print(f'{dir_path = }\n{dir_name = }\n{file_name = }\n')
# torConfig.editorconfig', 'task47_homework_7.GlobalUsings.g.cs']

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_48\\obj\\Debug\\net6.0\\ref'
# dir_name=[]
# file_name=[]

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_48\\obj\\Debug\\net6.0\\refint'
# dir_name=[]
# file_name=[]

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_49'
# dir_name=['bin', 'obj']
# file_name=['Program.cs', 'task48.csproj']

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_49\\bin'
# dir_name=['Debug']
# file_name=[]
#
# .............................
```

- os.rename('name.py', 'new_name.py'), Path('new_file.py').rename('newest_file.py')

```py
import os
from pathlib import Path

os.rename('old_name.py', 'new_name.py')

# вариант 1
p = Path('old_file.py')
p.rename('new_file.py') # переименовали файл

# вариант 2
Path('new_file.py').rename('newest_file.py') # и ещё раз переименовали тот же файл
```

- os.replace(), replace()

```py
import os
from pathlib import Path

os.replace('newest_file.py', os.path.join(os.getcwd(), 'dir', 'new_name.py')) # при переносе в папку dir можно изменить название файла с newest_file.py на new_name.py 

old_file = Path('new_name.py')
new_file = old_file.replace(Path.cwd() / 'new_os_dir' / old_file) # перенос в папку new_os_dir без изменения имени (написали тоже имя, что и было - old_file)
```

- shutil.copy(), shutil.copy2(), shutil.copytree()

```py
import shutil

shutil.copy('one.txt', 'dir') # копирование файла в дирректорию
shutil.copy2('two.txt', 'dir/one_more.txt') # перенос и переименование файла

shutil.copytree('dir', 'one_more_dir') # копирование дирректории и дали ей новое имя
```

- os.remove, unlink()

```py
import os
from pathlib import Path

os.remove('one_more_dir/one.txt') # удаление файла по указанному пути
Path('one_more_dir/one_more.txt').unlink()
```
