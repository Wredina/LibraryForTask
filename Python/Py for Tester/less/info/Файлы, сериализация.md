# Файловая система

**открытие и закрытие файла**

- with - менеджер контекста. гарантирует закрытие файла и сохранения информации даже если будут ошибки. Используется вместе с open(). with open(faile, mode, encoding='utf-8') as f: - открыть файл под именем f. Может открывать несколько файлов одновременно.

- open() - используется для доступа к файлу, по умолчанию на чтение. Имеет обязательный параметр file. Может быть вложен в переменную. f = open(file)

  - open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) - параметр file - это объект типа str или bytes, который представляет абсолютный или относительный путь к файлу

    - encoding - используемая кодировка. по умолчанию cp1251. Рекомендуется использовать utf-8. При работе с бинарными данными никакая кодировка не прописывается

      - encode() - при записи можно использовать разные кодировки. f.write('Привет, '.encode('utf-8') + 'мир!'.encode('cp1251')). Можно использовать для бинарной информации.

    - buffering — определяет режим буферизации (при работе с бинарным кодом)

      - 0 — отключить буферизацию

      - 1 — использовать буферизацию строк.

      - Число больше единицы определяет размер буфера в байтах для двоичных файлов. По умолчанию размер буфера подстраивается под файловую систему и обычно равен 4096 или 8192 байта.

    - errors — используется только в текстовом режиме и определяет поведение в случае ошибок кодирования или декодирования

      - 'strict' — вызывает исключение ValueError в случае ошибки. Работает как значение по умолчанию.

      - 'ignore' — игнорирует ошибки кодирования. При этом игнорирование ошибок может привести к потере данных.

      - 'replace' — вставляет маркер замены (например, '?') там, где есть некодируемые данные.

      - 'namereplace' — при записи заменяет неподдерживаемые символы последовательностями \N{...}.

    - newline — отвечает за преобразование окончания строки

    - closefd — указывает оставлять ли файловый дескриптор открытым при закрытии файла

    - opener — позволяет передать пользовательскую функцию для открытия файла.

- close() - завершение работы с файлом. Это гарантирует сохранение всех изменений в файле

**Режимы работы c файлами (моды)**

- 'r' — (read) - открыть для чтения (по умолчанию)

  - если файла нет, то программа выдаст ошибку

- 'w' — открыть для записи, предварительно очистив файл

  - если файла не существует - создаст

- 'x' — открыть для эксклюзивного создания.

  - если файла не существует, то он создаться и туда начнётся запись

  - Вернёт ошибку, если файл уже существует

- 'a' — (append) - открыть для записи в конец файла, если он существует

  - если файла не существует, то он создаться и туда начнётся запись

- 'b' — двоичный режим

- 't' — текстовый режим (по умолчанию 'rt')

- '+' — открыты для обновления (чтение и запись) (для чтения и записи в двоичном режиме нужно явно указывать режим 'b')

  - 'w+' - перезапись + чтение. позволяет открыть файл для записи(перезаписывания) и читать из него. если файла не существует - создаст

  - 'r+' - запись + чтение. Позволяет открывать файл для записи и читать из него. если файла не существует - будет ошибка

  - 'w+b' - открывают файл для чтения и записи и удаляют старое содержимое для побайтного файла

  - 'r+b' - открывают на чтение и запись без удаления старой информации для побайтного файла

**Чтение и запись файла**

- list() - чтение файла в списке. Оставляет переносы

- read() - читает весь файл. Не добавляются символы переноса в конце

  - read(n = -1) - читает n символов или n байт информации. Если n отрицательное или не указана, читает весь файл. Попытка чтения будет даже в том случае, когда файл больше оперативной памяти.

- readline() - чтение файла построчно. При чтении readline возвращает строку с символом переноса на конце.

- for line in file - построчное чтение файла при помощи цикла for. будет присутствовать символ переноса.

- write() - запись. принимает строку или набор байт. После записи возвращает количество записанной информации. Не добавляет в конец символ переноса. Для переноса нужно его явно указывать.

- writelines() - принимает последовательность и записывает каждый элемент в файл. Элементы последовательности должны быть строками или байтами. Метод ничего не возвращает. Записывает всё в одну большую строчку

- print(line, file=f) - печать в файл. Добавляет перенос строки. Можно явно изменить параметр end в функции

**Перемещения в фале**

- tell() - возвращает текущую позицию курсора в файле

- seek(offset, whence=0) - изменение положения курсора

  - offset - число, положительное или отрицательное. смещение относительно опорной точки

  - whence - способ выбора опорной точки

    - whence=0 - отсчёт от начала файла

    - whence=1 - отсчёт от текущей позиции в файле

    - whence=2 - отсчёт от конца файла

- truncate(size=None) - изменяет размер файла. Если не передать значение в параметр size будет удалена часть файла от текущей позиции до конца. Метод возвращает позицию после изменения файла.

**Каталоги**

- os.getcwd() - получение информации о текущем каталоге (import os) - старый вариант

  - os.chdir('../..') - изменение дирректории

  - os.mkdir('new') - создание дирректории

    - os.makedirs('dir/other_dir/new_os_dir') - создание несколько вложенных друг в друга дирректорий

  - os.rmdir('dir') - удаление каталога (удалять можно только пустые каталоги)

    - os.rmdir('dir/other_dir/new_os_dir') - удаление последнего каталога из цепочки (удалять можно только пустые каталоги)

  - file = os.path.join(os.getcwd(), 'dir', 'new_file.txt') - формирование нового пути для файла

  - os.listdir() - получение списка с информацией о дирректориях и файлах в текущей папке

    - isdir(obj) - возвращает True/False если папка/не папка

    - isfile(obj) - возвращает True/False если файл/не файл

    - islink(obj) - возвращает True/False если ссылка/не ссылка

  - os.walk() - выведет информацию о каталоге, который ей передать, включаю всю информацию о содержимых всех каталогах внутри. Т.е. функция пройдёт по всем папкам и всем файлам. (возвращает три значения: абсолютный путь до каталога, список с названиями всех каталогов внутри каталога и список названий всех файлов)

  - os.rename('name.py', 'new_name.py') - переименовывание файла

  - os.replace() - перенос файла в другую дирректорию

  - os.remove() - удалит файл

- pathlib.Path.cwd() - получение информации о текущем каталоге (import pathlib from Path) - современный вариант

  - Path('new').mkdir() - создание дирректории

    - Path('some_dir/dir/new_path_dir').mkdir(parents=True) - создание несколько вложенных друг в друга дирректорий

  - Path('some_dir').rmdir() - удаление каталога (удалять можно только пустые каталоги)

    - Path('some_dir/dir/new_path_dir').rmdir() - удаление последнего каталога из цепочки (удалять можно только пустые каталоги)

  - file_2 = Path().cwd() / 'dir' / 'new_file.txt' - формирование нового пути для файла

  - iterdir() - генератор который в цикле возвращает объекты из выбранной дирректории

    - is_dir() - возвращает True/False если папка/не папка

    - is_file() - возвращает True/False если файл/не файл

    - is_symlink() - возвращает True/False если ссылка/не ссылка

  - Path('name.py').rename('new_name.py') - переименовывание файла

  - replace() - перенос файла в другую дирректорию

  - unlink() - удаление файла

- shutil.rmtree('some_dir') - удаление каталога вместе с его содержимым (import shutil)

  - shutil.rmtree('dir/other_dir') - удалит последний каталог из цепочки вместе со всем содержимым

  - shutil.rmtree('dir') - удаление всег

- shutil.copy() - копирование файлов игнорируя метаданные (доп. информация о файле, где, когда и как создан и т.д.)

  - shutil.copy2() - копирование файла с попыткой сохранить и метаданные

  - shutil.copytree() - копирование каталога со всем содержимым в новое место (со всеми каталогами и файлами)

# Сериализация и Десериализация

**Сериализация** — это процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных или файл.

**Десериализация** — восстановление объектов из байт, сохранение которых было произведено ранее. Процедура выгрузки «зафиксированной» информации пользователем.

- JSON

| Python      | JSON         | Python |
|-------------|--------------|--------|
| dict        | object       | dict   |
| list,turple | array        | list   |
| str         | string       | str    |
| int         | number(int)  | int    |
| float       | numder(real) | float  |
| True        | true         | True   |
| False       | false        | False  |
| None        | null         | None   |

- import JSON

  - json.load(file) - загрузка JSON из файла (сохранение в dict или list)

  - json.loads(file) - загрузка JSON из строки (сохранение в dict или list)

  - json_text = """[{'key':'volue'}]""" - создание строки JSON в файле пайтона

  - json.dump(dict, file) - сохранение dict или list в файле в виде JSON

    - indent - форматирование с отступами

    - separators=(',', ':') - принимает кортеж из дыух строковых элементов. Первый - сивол разделителя элементов, второй - разделитель ключа и значения

    - sort_keys=True/False - сортировка ключей по алфавиту

  - json.dumps(dict) - сохранение dict или list в виде JSON строки (сохранение в переменную в виде строки)

    - имеет такие же параметры как и dump

- ensure_ascii=False - удалить символы эранирования (выводит русский язык)

- import CSV

  - csv.reader(file) - чтение файла построчно

  - newline='' - необходимо указывать при открытии файла. open(file, mode, newline='') - позволяет правильно считывать окончание строки и избежать проблем с отступами

  - dialect = 'exel-tab' - табуляция в виде разделителя

  - quoting=csv.QUOTE_NONNUMERIC - встроенная константа, указывающаяя функции, что числа без кавычек необходимо преобразовать к типу float

    - quoting=csv.QUOTE_ALL - заключить в кавычки все значения

  - csv_write = csv.writer(f) - возвращает объект для записи.

  - csv_write.writerow(line) - сохранение списка в виде одной строки в файле в формате csv (подходит и для DictWriter)

  - csv_write.writerows(all_data) - сохранение матрицы (списка списков) в нескольких строках в файле в формате csv (внутренний список будет сохраняться как новая строка) (подходит и для DictWriter)

  - csv.DictReader(f) - Чтение csv в словарь. по умолчанию, 1-я строка csv файла содержит заголовки и они автоматически становятся ключами словаря

    - fieldnames=[] - список заголовков столбцов, ключей словаря

    - restkey='' - значение ключа для столбцов, которых нет в fieldnames

    - restval='' - значение поля для ключей fieldnames, которых нет в файле csv

  - csv_write.writeheader() - запись из словаря, сохранение первой строки с заголовками в порядке их перечисления в параметре fieldnames

- import pickle - специализированный для языка пайтон модуль сериализации и десериализации, который преобразует информацию не в текст (как json или csv) а в поток байт. (pickle не занимается проверкой потока байт на безопасность перед распаковкой)

  - Допустимые данные для преобразования

    - None, True и False;

    - int, float, complex;

    - str, bytes, bytearrays;

    - tuple, list, set, dict если они содержат объекты, обрабатываемые pickle;

    - встроенные функции и функции созданные разработчиком и доступные из верхнего уровня модуля, кроме lambda функций;

    - классы доступные из верхнего уровня модуля;

    - экземпляры классов, если pickle смог обработать их дандер \_\_dict__или результат вызова метода \_\_getstate__().

  - pickle.dump(my_dict, f) - сохранение объекта в бинарном файле

  - res = pickle.dumps(my_dict) - сохранение объекта в строку байт

  - protocol=pickle.DEFAULT_PROTOCOL - можно не указывать. Но модуль pickle может не работать с более старыми версиями протокола. По умолчанию версия протокола 4. Если сохранения идут с одним протоколом, то и данные востанавливать с этим же.

  - n_dict = pickle.load(f) - загрузка из бинарного файла и сохранение в объект

  - n_dict = pickle.loads(f) - получение объекта из бинарной строки

**Примеры**

- open()

```py
# создали текстовый файл text.txt с английским текстом внутри, в конце которого по русски "Привет мир!". и что бы файл открыть используем функцию open()

f = open('text_data.txt') # файл находится в одной папке с питоновским
print(f)
print(list(f))
# <_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'РџСЂРёРІРµС‚, РјРёСЂ!\n']

# По умолчанию используется кодировка cp1251, поэтому русский текст выглядит - 'РџСЂРёРІРµС‚, РјРёСЂ!\n'
```

- open(file, encoding=None)

```py
# создали текстовый файл text.txt с английским текстом внутри, в конце которого по русски "Привет мир!". и что бы файл открыть, используем функцию open()

f = open('text_data.txt', encoding='utf-8') # задаём кодировку
print(f)
print(list(f))
# <_io.TextIOWrapper name='text_data.txt' mode='r' encoding='cp1251'>
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'Привет мир!\n']
```

- 'a' — (append), close()

```py
# создали текстовый файл text.txt
f = open('text_data.txt', 'a', encoding='utf-8')
f.write('Окончание файла\n') # запись в конец файла
f.close() # закрытие файла

# если перезапусить код, фраза "Окончание файла" добавится ещё раз
```

- buffering

```py
f = open('bin_data', 'wb', buffering=64) # создание файла bin_data для записиси бинарных данных 
f.write(b'X' * 1200) # передаём бинарный символ X. умножение на 1200 говорит о том, что этих Х должно быть на 1200 байт
f.close()

```

- encoding, encode(), errors, r

```py
f = open('data.txt', 'wb') # создали файл для бинарной информации
f.write('Привет, '.encode('utf-8') + 'мир!'.encode('cp1251')) # записываем Привет в кодировке utf-8, и мир в кодировке cp1251
f.close()


f = open('data.txt', 'r', encoding='utf-8') # открытие того же файла для чтения
print(list(f)) # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xec in position 14: invalid continuation byte (из-за того, что было записано в документ 2 разные кодировки, он не смог прочесть ср1251)
f.close()


f = open('data.txt', 'r', encoding='utf-8', errors='replace') # обработка ошибки, файл прочитается, но на месте, где будет кодировка ср1251 будут ???.
print(list(f))
f.close()
# ['Привет, ???!']
```

- with

```py
# открытие и печать одного файла
with open('text_data.txt', 'r+', encoding='utf-8') as f:
  print(list(f))

# открытие и печать нескольких файлов одновременно
with open('text_data.txt', 'r+', encoding='utf-8') as f1, \
  #тут просто текстовый файл 
  open('bin_data', 'rb') as f2, \
  # файл с бинарной информацией в котором много Х
  open('data.txt', 'r', encoding='utf-8', errors='backslashreplace') as f3: \
  # текст 'Привет,' - в кодировке utf-8 и текст 'мир!' в кодировке ср1251. Обработка ошибки при помощи обратного слэша - символов экранирования
  print(list(f1))
  print(list(f2))
  print(list(f3))
# ['text1 for test1\n', 'text2 for test1\n']
# [b'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX']
# ['Привет, \\xec\\xe8\\xf0!']

#пример как выше, только при помощи круглых скобок
with (
      open('text_data.txt', 'r+', encoding='utf-8') as f1,
      open('bin_data', 'rb') as f2,
      open('data.txt', 'r', encoding='utf-8', errors='backslashreplace') as f3
):
    print(list(f1))
    print(list(f2))
    print(list(f3))
```

- list()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  print(list(f))
# ['text for tests\n', 'text2 for tests2.\n', '......\n', 'Привет мир!\n']
```

- read()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  res = f.read()
  print(f'Читаем первый раз\n{res}')
  res = f.read() # попытка прочесть файл второй раз вернёт пустую строку.
  print(f'Читаем второй раз\n{res}') 
# Читаем первый раз
# text for tests
# text2 for tests2.
# ......
# Привет мир!
#
# Читаем второй раз
#

SIZE = 100 # выставляем ограничения на 100 символов
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.read(SIZE): # Считает по 100 символов
    print(res)
# text for tests
# text2 for tests2.
# ......

# text50 for tests50
# text51 for tests51
# ......

# ......
# Привет мир!
```

- readline()

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.readline(): # метод передаёт переход строки на новый
    print(res) # тоже даёт символ перехода на новую строку, поэтому будет выводиться через строку (два переноса)
# text for tests
#
# text2 for tests2.
#
# ......
#
# Привет мир!

# т.к. текст у меня короткий, буду показывать на нём
SIZE = 100 # ограничения в 100 символов
with open('text_data.txt', 'r', encoding='utf-8') as f:
  while res := f.readline(SIZE): # ограничение в 100 символос строки
    print(res) # если строка длинее 100 символов, будет один перенос строки, т.к. в месте ограничения нет символа переноса.
# text for tests
#
# text2 for te
# sts2.
#
# .......
# .......
# ...
#
# Привет мир!
```

- for line in file

```py
with open('text_data.txt', 'r', encoding='utf-8') as f:
  for line in f:
    print(line, end='') # убираем из принт переносы т.к. в строке есть свои символы переноса
# text for tests
# text2 for tests2.
# ......
# Привет мир!

# для работы без переноса строки
with open('text_data.txt', 'r', encoding='utf-8') as f:
  for line in f:
    print(line[:-1]) # отрезает два последних символа
    print(line.replace('\n', '')) # заменяет символ переноса на пустую строку
# text for tests
# text for tests
# text2 for tests2.
# text2 for tests2.
# ......
# ......
# Привет мир!
# Привет мир!
```

- write()

```py
text = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'
with open('new_data.txt', 'a', encoding='utf-8') as f: # открывается файл для записи
  res = f.write(text)
  print(f'{res = }\n{len(text) = }') # сколько символов записано
# res = 57
# len(text) = 57


text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f: # открывается файл для записи
  for line in text: # для каждой строки с текстом
    res = f.write(line) # записываем информацию
    print(f'{res = }\n{len(line) = }') # сколько символов было записано
# res = 57
# len(text) = 57
# res = 73
# len(text) = 73
# res = 72
# len(text) = 72
#
# в файл всё запишется одной строкой т.к. write не добавляет символа переноса строки

# делаем с переносом строки
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    res = f.write(f'{line}\n') # добавляем символ переноса в конец
    print(f'{res = }\n{len(line) = }') # длина res стала на 1 больше из-за символа переноса
# res = 58
# len(text) = 57
# res = 74
# len(text) = 73
# res = 73
# len(text) = 72
# 
# в файле каждая строчка перенесётся на новую
```

- writelines()

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  f.writelines('\n'.join(text)) # запись в одну строчку, join между каждой строчкой добавляет символ переноса
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?
```

- print(line, file=f), end=''

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    print(line, file=f) # не вывела в консоль а записала всё в файл

# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?

# но если в файле будет уже какая-то информация, принт сконкатенирует предыдущую строку со следующей, будет примерно так:

# text for tests
# text2 for tests2.Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?


text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  for line in text:
    print(line, end='***\n##', file=f)
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.***
# ##Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?***
# ##Accusantium alias amet fugit iste neque non odit quia saepe totam velit?***
# ##
```

- tell()

```py
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'a', encoding='utf-8') as f:
  print(f.tell()) # файл открыт, но ещё ничего не записано, находимся в самом начале файла
  for line in text:
    f.write(f'{line}\n')
    print(f.tell()) # печатаем местоположение курсора после каждой записи
  print(f.tell()) # положение курсора после завершения цикла
print(f.tell()) # ValueError: т.к. вышли из тела with и файл закрылся
# 0
# 59
# 134
# 208
# 208
```

- seek(offset, whence=0), r+

```py
last = before = 0 # хранят позиции двух последних прочитанных строк
text = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
'Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?',
'Accusantium alias amet fugit iste neque non odit quia saepe totam velit?', ]
with open('new_data.txt', 'r+', encoding='utf-8') as f: # открываем для чтнения и записи
  while line := f.readline():
    last, before = f.tell(), last # в last помещаем значение текущего положения курсора, а в before - предыдущее значение last
    print(f'{last = }, {before = }') # выводим позиции после каждой итерации
  print(f'{last = }, {before = }') # выыодим значения после цикла
  print(f'{f.seek(before, 0) = }') # устанавливаем позицию курсора на позицию 134 (before), и 0 - отсчёт идёт от начала файла
  f.write('\n'.join(text)) # записываем в файл ещё текст
# last = 59, before = 0
# last = 59, before = 59
# last = 208, before = 134
# last = 208, before = 134
# f.seek(before, 0) = 134

# при помощи цикла запишется 3 строчки текста, потом перемещаем курсор на конец второй строчки и перезаписываем информацию(ещё три строчки)

# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Lorem ipsum dolor sit amet, consectetur adipisicing elit.
# Consequatur debitis explicabo laboriosam sint suscipit temporibus veniam?
# Accusantium alias amet fugit iste neque non odit quia saepe totam velit?
```

- truncate(size=None)

```py
last = before = 0
with open('new_data.txt', 'r+', encoding='utf-8') as f:
  while line := f.readline():
    last, before = f.tell(), last # в last помещаем значение текущего положения курсора, а в before - предыдущее значение last
  print(f.seek(before, 0)) # перемещаем курсор на положение предпоследнего местоположения
  print(f.truncate()) # обрезаем текст в файле от текущего положения курсора до конца
# 268
# 268



size = 64
with open('new_data.txt', 'r+', encoding='utf-8') as f:
  print(f.truncate(size)) # обрезать файл по значению size (оставит 64 символа)

# 64
```

- os.getcwd(), pathlib.Path.cwd() / from pathlib import Path

```py
import os
from pathlib import Path


print(os.getcwd())
print(Path.cwd())
# D:\программирование\MyBibliotecForTask
# D:\программирование\MyBibliotecForTask
```

- os.chdir('../..')

```py
import os
from pathlib import Path


print(os.getcwd())
print(Path.cwd())
os.chdir('../..')
print(os.getcwd())
print(Path.cwd())
# D:\программирование\MyBibliotecForTask
# D:\программирование\MyBibliotecForTask
# D:
# D:
```

- os.mkdir('new'), Path('new').mkdir()

```py
import os
from pathlib import Path

os.mkdir('new_os_dir')
Path('new_path_dir').mkdir()
# появляются 2 новые папки new_os_dir и new_path_dir
```

- os.makedirs('dir/other_dir/new_os_dir'), Path('some_dir/dir/new_path_dir').mkdir(parents=True)

```py
import os
from pathlib import Path


os.makedirs('dir/other_dir/new_os_dir')
Path('some_dir/dir/new_path_dir').mkdir() # FileNotFoundError
Path('some_dir/dir/new_path_dir').mkdir(parents=True)
# D:\программирование\MyBibliotecForTask\dir\other_dir\new_os_dir
# D:\программирование\MyBibliotecForTask\some_dir\dir\new_path_dir
```

- os.rmdir('dir'), os.rmdir('dir/other_dir/new_os_dir'), Path('some_dir').rmdir(), Path('some_dir/dir/new_path_dir').rmdir()

```py
import os
from pathlib import Path

os.rmdir('dir') # OSError - т.к. каталог не пустой
Path('some_dir').rmdir() # OSError - т.к. каталог не пустой
os.rmdir('dir/other_dir/new_os_dir') # удаление последней пустой папки из цепочки
Path('some_dir/dir/new_path_dir').rmdir() # удаление последней пустой папки из цепочки
```

- shutil.rmtree('some_dir'), shutil.rmtree('dir/other_dir')

```py
import shutil

shutil.rmtree('dir/other_dir') # удаление последней папки с информацией
shutil.rmtree('some_dir') # удаление папки с информацией
```

- file_1 = os.path.join(os.getcwd(), 'dir', 'new_file.txt'), file_2 = Path().cwd() / 'dir' / 'new_file.txt'

```py
import os
from pathlib import Path

file_1 = os.path.join(os.getcwd(), 'dir', 'new_file.txt') # берём текущую рабочую дирректорию, потом dir и new_file.txt (возвращает строку)
print(f'{file_1 = }\n{file_1}')

file_2 = Path().cwd() / 'dir' / 'new_file.txt' # собирает путь из текущей дирректории (использует правильное формирование пути отталкиваясь от ОС)
print(f'{file_2 = }\n{file_2}')

# file_1 = D:\\программирование\\MyBibliotecForTask\\dir\\new_file.txt
# D:\программирование\MyBibliotecForTask\dir\new_file.txt
# file_2 = WindowPath('D:/программирование/MyBibliotecForTask/dir/new_file.txt')
# D:\программирование\MyBibliotecForTask\dir\new_file.txt
```

- os.listdir(), iterdir()

```py
import os
from pathlib import Path

print(os.listdir()) # список каталогов и файлов

p = Path(Path().cwd())
for obj in p.iterdir(): # итерация по всем файлам и каталогам внутри дирректории
  print(obj)

# ['.git', '.gitignore', '.pytest_cache', '.vscode', 'html_css', 'Java', 'JS', 'Python', 'Tester', 'С#']
# D:\программирование\MyBibliotecForTask\.git
# D:\программирование\MyBibliotecForTask\.gitignore   
# D:\программирование\MyBibliotecForTask\.pytest_cache
# D:\программирование\MyBibliotecForTask\.vscode      
# D:\программирование\MyBibliotecForTask\html_css     
# D:\программирование\MyBibliotecForTask\Java
# D:\программирование\MyBibliotecForTask\JS
# D:\программирование\MyBibliotecForTask\Python
# D:\программирование\MyBibliotecForTask\Tester
# D:\программирование\MyBibliotecForTask\С#
```

- isdir(obj), isfile(obj), islink(obj), is_dir(), is_file(), is_symlink()

```py
import os
from pathlib import Path

dir_list = os.listdir()
for obj in dir_list:
  print(f'{os.path.isdir(obj) = }', end='\t')
  print(f'{os.path.isfile(obj) = }', end='\t')
  print(f'{os.path.islink(obj) = }', end='\t')
  print(f'{obj = }')

p = Path(Path().cwd())
for obj in p.iterdir():
  print(f'{obj.is_dir() = }', end='\t')
  print(f'{obj.is_file() = }', end='\t')
  print(f'{obj.is_symlink() = }', end='\t')
  print(f'{obj = }')
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.git'
# os.path.isdir(obj)=False os.path.isfile(obj)=True       os.path.islink(obj)=False       obj='.gitignore'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.pytest_cache'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='.vscode'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='html_css'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Java'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='JS'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Python'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='Tester'
# os.path.isdir(obj)=True os.path.isfile(obj)=False       os.path.islink(obj)=False       obj='С#'
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.git')
# obj.is_dir()=False      obj.is_file()=True      obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.gitignore')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.pytest_cache')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/.vscode')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/html_css')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Java')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/JS')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Python')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/Tester')
# obj.is_dir()=True       obj.is_file()=False     obj.is_symlink()=False  obj=WindowsPath('D:/программирование/MyBibliotecForTask/С#')
```

- os.walk()

```py
import os

for dir_path, dir_name, file_name in os.walk(os.getcwd()): # возвращает 3 значения: название дерриктории, имя дирректории которая находится внутри и имя найденных файлов
  print(f'{dir_path = }\n{dir_name = }\n{file_name = }\n')
# torConfig.editorconfig', 'task47_homework_7.GlobalUsings.g.cs']

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_48\\obj\\Debug\\net6.0\\ref'
# dir_name=[]
# file_name=[]

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_48\\obj\\Debug\\net6.0\\refint'
# dir_name=[]
# file_name=[]

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_49'
# dir_name=['bin', 'obj']
# file_name=['Program.cs', 'task48.csproj']

# dir_path='D:\\программирование\\MyBibliotecForTask\\С#\\task_49\\bin'
# dir_name=['Debug']
# file_name=[]
#
# .............................
```

- os.rename('name.py', 'new_name.py'), Path('new_file.py').rename('newest_file.py')

```py
import os
from pathlib import Path

os.rename('old_name.py', 'new_name.py')

# вариант 1
p = Path('old_file.py')
p.rename('new_file.py') # переименовали файл

# вариант 2
Path('new_file.py').rename('newest_file.py') # и ещё раз переименовали тот же файл
```

- os.replace(), replace()

```py
import os
from pathlib import Path

os.replace('newest_file.py', os.path.join(os.getcwd(), 'dir', 'new_name.py')) # при переносе в папку dir можно изменить название файла с newest_file.py на new_name.py 

old_file = Path('new_name.py')
new_file = old_file.replace(Path.cwd() / 'new_os_dir' / old_file) # перенос в папку new_os_dir без изменения имени (написали тоже имя, что и было - old_file)
```

- shutil.copy(), shutil.copy2(), shutil.copytree()

```py
import shutil

shutil.copy('one.txt', 'dir') # копирование файла в дирректорию
shutil.copy2('two.txt', 'dir/one_more.txt') # перенос и переименование файла

shutil.copytree('dir', 'one_more_dir') # копирование дирректории и дали ей новое имя
```

- os.remove, unlink()

```py
import os
from pathlib import Path

os.remove('one_more_dir/one.txt') # удаление файла по указанному пути
Path('one_more_dir/one_more.txt').unlink()
```

- JSON

```py

# формат такой:
# {
#   'key':'str'
#   'key2': 12
#   'key3' : [arr1, arr2]
#   'key4': {'key5':'value', 'key6':123}
# }

{
  "id": 2,
  "name": "Ervin Howell",
  "username": "Antonette",
  "email": [
    "Shanna@melissa.tv",
    "antonette@howel.com"
  ],
  "address": {
    "street": "Victor Plains",
    "suite": "Suite 879",
    "city": "Wisokyburgh",
    "zipcode": "90566-7771",
    "geo": {
      "lat": "-43.9509",
      "lng": "-34.4618"
    }
  },
  "phone": "010-692-6593 x09125",
  "website": "anastasia.net",
  "company": {
    "name": "Deckow-Crist",
    "catchPhrase": "Proactive didactic contingency",
    "bs": "synergize scalable supply-chains"
  }
}

```

- json.load(file), import JSON

```py
import json

with open('user.json', 'r', encoding='utf-8') as f:
  json_file = json.load(f) # в переменную json_file помещаем весь json файл

print(f'{type(json_file) = }\n{json_file = }') #тип файла и его распечатка
print(f'{json_file["name"] = }') # получить значение по ключу name
print(f'{json_file["address"]["geo"] = }') # найти ключ adress, в ней найти ключ geo и вывести его значение
print(f'{json_file["email"] = }') # получить значения по ключу email
# type(json_file) = <class 'dict'>
# json_file = {"id": 2, "name": "Ervin Howell", ... "bs": "synergize scalable supply-chains"}}
# json_file["name"] = "Ervin Howell"
# json_file["address"]["geo"] = {"lat": "-43.9509", "lng": "-34.4618"}
# json_file["email"] = ["Shanna@melissa.tv", "antonette@howel.com"]
```

- json_text = """[{'key':'volue'}]""", json.loads(file)

```py
import json

json_text = """
[
  {
    "userId": 1,
    "id": 9,
    "title": "nesciunt iure omnis dolorem tempora et
    accusantium",
    "body": "consectetur animi nesciunt iure dolore"
  },
  {
    "userId": 1,
    "id": 10,
    "title": "optio molestias id quia eum",
    "body": "quo et expedita modi cum officia vel magni"
  },
  {
    "userId": 2,
    "id": 11,
    "title": "et ea vero quia laudantium autem",
    "body": "delectus reiciendis molestiae occaecati non minima
    eveniet qui voluptatibus"
  },
  {
    "userId": 2,
    "id": 12,
    "title": "in quibusdam tempore odit est dolorem",
    "body": "praesentium quia et ea odit et ea voluptas et"
  }
]"""

print(f'{type(json_text) = }\n{json_text = }') #вывести тип и полностью текст

json_list = json.loads(json_text) # поместить в переменную значение json_text
print(f'{type(json_list) = }\t{len(json_list) = }\n{json_list = }') # вывести тип, длину и сам список (список JSON объектов)

# type(json_text)=<class 'str'>
# json_text='\n[\n  {\n    "userId": 1,\n    "id": 9, .....\n   "body": "praesentium quia et ea odit et ea voluptas et"\n  }\n]'
# type(json_list)=<class 'list'>  len(json_list)=4
# json_list=[{'userId': 1, 'id': 9, ...... 'body': 'praesentium quia et ea odit et ea voluptas et'}]
```

- json.dump(dict, file)

```py
import json

my_dict = {
  "first_name": "Джон",
  "last_name": "Смит",
  "hobbies": ["кузнечное дело", "программирование", "путешествия"],
  "age": 35,
  "children": [
    {
      "first_name": "Алиса",
      "age": 5
    },
    {
      "first_name": "Маруся",
      "age": 3
    }
  ]
}

print(f'{type(my_dict) = }\n{my_dict = }') # вывод типа и содержимого

with open('new_user.json', 'w') as f: # открытие файла на перезапись
  json.dump(my_dict, f) # запись в файл (будет одна длинная json строка текста и всё что было на русском, преобразуется в "\u0410\u043b\u0438\u0430") - это нормально. При чтении через load в кодировке utf-8 - всё будет выводиться читабельно

# {type(my_dict) =<class 'dict'>
# my_dict = {"first_name": "Джон", "last_name": "Смит", "hobbies": ["кузнечное дело", ...}

# в файле
# {"first_name": "\u0410\u043b\u0438", "last_name": "\u0438\u0430", "hobbies": ["\u0410\u043b\u0438\u0430", ...}
```

- ensure_ascii=False

```py
import json

my_dict = {
  "first_name": "Джон",
  "last_name": "Смит",
  "hobbies": ["кузнечное дело", "программирование", "путешествия"],
  "age": 35,
  "children": [
    {
      "first_name": "Алиса",
      "age": 5
    },
    {
      "first_name": "Маруся",
      "age": 3
    }
  ]
}

with open('new_user.json', 'w', encoding='utf-8') as f: # открытие файла на перезапись в кодировке utf-8
  json.dump(my_dict, f, ensure_ascii=False)

# {"first_name": "Джон", "last_name": "Смит", "hobbies": ["кузнечное дело", ...}
```

- json.dumps(dict), ensure_ascii=False

```py
import json

my_dict = {
  "first_name": "Джон",
  "last_name": "Смит",
  "hobbies": ["кузнечное дело", "программирование", "путешествия"],
  "age": 35,
  "children": [
    {
      "first_name": "Алиса",
      "age": 5
    },
    {
      "first_name": "Маруся",
      "age": 3
    }
  ]
}

dict_to_json_text = json.dumps(my_dict) # записали файл как строку
print(f'{type(dict_to_json_text) = }\n{dict_to_json_text = }') # вывели тип и содержание
# type(dict_to_json_text)=<class 'str'>
# dict_to_json_text='{"first_name": "\\u0414\\u0436\\u043e\\u043d", "last_name": "\\u0421\\u043c\\u0438\\u0442", .... "age": 3}]}'

dict_to_json_text = json.dumps(my_dict, ensure_ascii=False) # записали файл как строку с параметром ensure_ascii=False
print(f'{type(dict_to_json_text) = }\n{dict_to_json_text = }') # вывели тип и содержание
# type(dict_to_json_text)=<class 'str'>
# dict_to_json_text='{"first_name": "Джон", "last_name": "Смит", .... "age": 3}]}'
```

- indent, separators=(',', ':'), sort_keys=True/False

```py
import json

my_dict = {
  "id": 123,
  "name": "Clementine Bauche",
  "username": "Cleba",
  "email": "cleba@corp.mail.ru",
  "address": {
    "street": "Central",
    "city": "Metropolis",
    "zipcode": "123456"
  },
  "phone": "+7-999-123-45-67"
}

res = json.dumps(my_dict, indent=2, separators=(',', ':'), sort_keys=True) # indent - даёт 2 пробела отступа между элементами, separators - убирает пробели после ',' и ':', sort_keys - сортирует ключи по алфавиту
print(res)
# {
#   "address":{
#     "city":"Metropolis",
#     "street":"Central",
#     "zipcode":"123456"
#   },
#   "email":"cleba@corp.mail.ru",
#   "id":123,
#   "name":"Clementine Bauche",
#   "phone":"+7-999-123-45-67",
#   "username":"Cleba"
# }
```

- CSV

```py
# имеет вид
# "name colum1","name colum2","name colum3"
# "row1 colum1","row1 colum2","row1 colum3"
# "row2 colum1","row2 colum2","row2 colum3"
# "row3 colum1","row3 colum2","row3 colum3"

"Name","Sex","Age","Height (in)","Weight (lbs)"
"Alex","M",41,74,170
"Bert","M",42,68,166
"Carl","M",32,70,155
"Dave","M",39,72,167
"Elly","F",30,66,124
"Fran","F",33,66,115
"Gwen","F",26,64,121
"Hank","M",30,71,158
"Ivan","M",53,72,175
"Jake","M",32,69,143
"Kate","F",47,69,139
"Luke","M",34,72,163
"Myra","F",23,62,98
"Neil","M",36,75,160
"Omar","M",38,70,145
"Page","F",31,67,135
"Quin","M",29,71,176
"Ruth","F",28,65,131

```

- import CSV, csv.reader(file), newline=''

```py
import csv

with open('biostats.csv', 'r', newline='') as f: # открытие файла на чтение
  csv_file = csv.reader(f) # сохранение содержимого файла в переменную
  for line in csv_file: # построчно перебираем файл
    print(line)
print(type(line))
#["Name", "Sex", "Age", "Height (in)", "Weight (lbs)"]
# ["Alex", "M", '41', '74', '170']
# ["Bert", "M", '42', '68', '166']
# ["Carl", "M", '32', '70', '155']
# ..............
# <class 'list'>
```

- dialect = 'exel-tab', quoting=csv.QUOTE_NONNUMERIC

```py
import csv

with open('biostats_tab.csv', 'r', newline='') as f:
  csv_file = csv.reader(f, dialect='excel-tab', quoting=csv.QUOTE_NONNUMERIC)
  for line in csv_file:
    print(line)
  print(type(line))

# ["Name", "Sex", "Age", "Height (in)", "Weight (lbs)"]
# ["Alex", "M", 41.0, 74.0, 170.0]
# ["Bert", "M", 42.0, 68.0, 166.0]
# ["Carl", "M", 32.0, 70.0, 155.0]
# ["Dave", "M", 39.0, 72.0, 167.0]
```

- csv_write = csv.writer(f), csv_write.writerow(line), csv_write.writerows(all_data)

```py
import csv

with (
  open('biostats_tab.csv', 'r', newline='') as f_read, # открываем первый файл на чтение
  open('new_biostats.csv', 'w', newline='', encoding='utf-8') as f_write # открываем второй файл на запись
  ):

  csv_read = csv.reader(f_read, dialect='excel-tab', quoting=csv.QUOTE_NONNUMERIC)# записываем содержимое первого файла в переменную, преобразуя цифры в float
  csv_write = csv.writer(f_write, dialect='excel', delimiter='', quotechar='|' quoting=csv.QUOTE_MINIMAL)# диалект exel (на выходе получаем элементы разделённые запятой), в качестве разделителя СТОЛБОВ " ", если символ разделитель есть В ОБЪЕКТЕ (пробел) - экранируем объект вертикальной чертой, символ экранирования используется по минимуму

  all_data = []
  for i, line in enumerate(csv_read):# читаем первый файл
    if i == 0: # если прочитали самую верхную строку (строку с заголовками)
      csv_write.writerow(line) # записываем в новый файл
    else:
      line[2] += 1 # то что находится в ячейке 2 увеличиваем на 1
      for j in range(2, 4 + 1): # то что находится в ячейках 2,3 и 4
        line[j] = int(line[j]) # преобразоывваем к целому типу
      all_data.append(line) # всё это сохраняется в виде строки (all_data - матрица)
  csv_write.writerows(all_data) # записываются все строки в файл

# Name Sex Age |Height (in)| |Weight (lbs)|
# Alex M 41 74 170
# Bert M 42 68 166
# Carl M 32 70 155
# Dave M 39 72 167
# Elly F 30 66 124
```

- csv.DictReader(f, fieldnames=[], restkey='', restval='')

```py
import csv

with open('biostats_tab.csv', 'r', newline='') as f:
  csv_file = csv.DictReader(f, fieldnames=["name", "sex", "age", "height", "weight", "office"], restkey="new", restval="Main Office", dialect='excel-tab', quoting=csv.QUOTE_NONNUMERIC) # в fieldnames нет значения office, поэтому для него будет использоваться значение из restval

  for line in csv_file:
    print(f'{line = }')
    print(f'{line["name"] = }\t{line["age"] = }')
```

```py
import csv

with open('biostats_tab.csv', 'r', newline='') as f:
  csv_file = csv.DictReader(f, fieldnames=["name", "sex", "age", ], restkey="new",restval="Main Office", dialect='excel-tab', quoting=csv.QUOTE_NONNUMERIC) # в fieldnames не передали higt и weight как ключи, поэтому будет срабатывать restkey и в new будет помещён список значений, которых мы явно не указали

  for line in csv_file:
    print(f'{line = }')
    print(f'{line["name"] = }\t{line["age"] = }')
```

- csv_write.writeheader(), csv_write.writerow(line), csv_write.writerows(all_data)

```py
import csv
from typing import Iterator

with (
open('biostats_tab.csv', 'r', newline='') as f_read, #открывание первого файла на чтение
open('biostats_new.csv', 'w', newline='', encoding='utf-8') as f_write #открывание второго файла на запись
):
  csv_read: Iterator[dict] = csv.DictReader(f_read, fieldnames=["name", "sex", "age","height", "weight", "office"], restval="Main Office", dialect='excel-tab', quoting=csv.QUOTE_NONNUMERIC) # пять столбцов с явно-прописанными именами и одно имя которое в файле не существует 'office', в него будет вложено значение из restval

  csv_write = csv.DictWriter(f_write, fieldnames=["id", "name", "office", "sex", "age", "height", "weight"], dialect='excel-tab', quoting=csv.QUOTE_ALL) # создание объекта для чтение в словарь. Появляется поле 'id', поле 'office' перенесено после поля имя

  csv_write.writeheader() #записывает заголовки из csv_write в том порядке, который указали
  all_data = [] # для хранения отдельных словарей

  for i, dict_row in enumerate(csv_read): #нумерация в i и значение полец в dict_row
    if i != 0:
      dict_row['id'] = i # добавляем значение из enumerate в id
      dict_row['age'] += 1 # значение в age увеличиваем на 1
      all_data.append(dict_row) #сохраняем в список all_data всё что изменили в поле
  csv_write.writerows(all_data) #после цикла, запись всего списка в конец файла
# 'id'  'name'  'office'  'sex' 'age' 'higtht'  'weight'
# '1' "Alex"  "Main Ofice"  "M" "42.0"  "74.0"  "170.0"
# '2' "Bert"  "Main Ofice"  "M" "43.0"  "68.0"  "166.0"
# '3' "Bert"  "Main Ofice"  "M" "43.0"  "68.0"  "166.0"
```

```py
import csv

with open('quest.csv', 'w', newline='', encoding='utf-8') as f_write:
  csv_write = csv.DictWriter(f_write, fieldnames=["number", "name", "data"],restval='Hello world!', dialect='excel', delimiter='#', quotechar='=', quoting=csv.QUOTE_NONNUMERIC) # наименования столбцов "number", "name", "data", если не будет каких-то значений, будет подставляться restval='Hello world!'. Стандратный вид данных черех запятую, но, delimiter='#' - значит запятые будут обозначены решёткой(замена символа разделителя столбца). quotechar='=' - значит все кавычки будут заменены на =, quoting=csv.QUOTE_NONNUMERIC - цифры принимают формат float и не будут в кавычках, а значит,  не будут обёрнуты в =

  csv_write.writeheader() #записываем заголовки
  dict_row = {} # подготавливаем словарь для хранения данных

  for i in range(10):
    dict_row['number'] = i # в заголовок number кладём ключ i
    dict_row['name'] = str(i) # в заголовок name кладём значение ключа, строковую i
    csv_write.writerow(dict_row) # значения записываем
    # т.к. нет значений для заголовка data, туда будет подставлено Hello world! из restval

# =number=#=name=#=data=
# 0#=0=#=Hello world!=
# 1#=1=#=Hello world!=
# 2#=2=#=Hello world!=
# 3#=3=#=Hello world!=
# 4#=4=#=Hello world!=
# 5#=5=#=Hello world!=
# 6#=6=#=Hello world!=
# 7#=7=#=Hello world!=
# 8#=8=#=Hello world!=
# 9#=9=#=Hello world!=
```

- import pickle

```py
import pickle
import os

res = pickle.loads(b"cos\nsystem\n(S'echo Hello world!'\ntR.")
print(res)

os.system('echo Hello world!')

# Hello world!
# res = 0
# Hello world!
```

- res = pickle.dumps(my_dict)

```py
import pickle

my_dict = {
  "first_name": "Джон",
  "last_name": "Смит",
  "hobbies": ["кузнечное дело", "программирование", "путешествия"],
  "age": 35,
  "children": [
    {
      "first_name": "Алиса",
      "age": 5
    },
    {
      "first_name": "Маруся",
      "age": 3
    }
  ]
}

print(my_dict)
res = pickle.dumps(my_dict, protocol=pickle.DEFAULT_PROTOCOL) #преобразовывание всей структуры в строку байт
print(f'{res = }')
print(f'{pickle.DEFAULT_PROTOCOL = }') # 
# {'first_name': 'Джон', 'last_name': 'Смит', .....'age': 3}]} 
# res=b'\x80\x04\x95\xe3\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c ....... \nK\x03ueu.'
# pickle.DEFAULT_PROTOCOL=4
```

- pickle.dump(my_dict, f)

```py
import pickle

def func(a, b, c):
  return a + b + c

my_dict = {
  "numbers": [42, 4.1415, 7+3j],# передача списка int, float, comlex
  "functions": (func, sum, max), # передача созданной функции и функций из "упаковки"
  "others": {True, False, 'Hello world!'}, # булевые значения и строка
}

with open('my_dict.pickle', 'wb') as f: # открытие файла на запись байт
  pickle.dump(my_dict, f)

# создастся файл с байтовой информацией
```

- n_dict = pickle.loads(f)

```py
import pickle

data = b'\x80\x04\x95\xe3\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c\nfirst_name\x94\x8c\x08\xd0\x94\xd0\xb6\xd0\xbe\xd0\xbd\x94\x8c\tlast_name\x94\x8c\x08\xd0\xa1\xd0\xbc\xd0\xb8\xd1\x82\x94\x8c\x07hobbies\x94]\x94(\x8c\x1b\xd0\xba\xd1\x83\xd0\xb7\xd0\xbd\xd0\xb5\xd1\x87\xd0\xbd\xd0\xbe\xd0\xb5 \xd0\xb4\xd0\xb5\xd0\xbb\xd0\xbe\x94\x8c\xd0\xbf\xd1\x80\xd0\xbe\xd0\xb3\xd1\x80\xd0\xb0\xd0\xbc\xd0\xbc\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5\x94\x8c\x16\xd0\xbf\xd1\x83\xd1\x82\xd0\xb5\xd1\x88\xd0\xb5\xd1\x81\xd1\x82\xd0\xb2\xd0\xb8\xd1\x8f\x94e\x8c\x03age\x94K#\x8c\x08children\x94]\x94(}\x94(h\x01\x8c\n\xd0\x90\xd0\xbb\xd0\xb8\xd1\x81\xd0\xb0\x94h\nK\x05u}\x94(h\x01\x8c\x0c\xd0\x9c\xd0\xb0\xd1\x80\xd1\x83\xd1\x81\xd1\x8f\x94h\nK\x03ueu.'

new_dict = pickle.loads(data) # сохранение файла в словарь
print(f'{new_dict = }')
# # {'first_name': 'Джон', 'last_name': 'Смит', .....'age': 3}]} 
```

- n_dict = pickle.load(f)

```py
import pickle

def func(a, b, c):
  return a * b * c

with open('my_dict.pickle', 'rb') as f: # файл из примера pickle.dump(my_dict, f) открыли на чтение
  new_dict = pickle.load(f)

print(f'{new_dict = }')
print(f'{new_dict["functions"][0](2, 3, 4) = }') # запуск функции func (она под элементом [0]) и передача ей аргументы, но запустится функция которая в этом файле, т.к. имена совпали. Если бы функции этой небыло, была бы ошибка. Функции которые были сохранены из другого файла, должны присутствовать и здесь в полном объёме.

# new_dict = {"numbers": [42, 4.1415, 7+3j], 'functions': (<function func at 0x00001A6B>, <built-in function sum>, <built-in function max>),  ....}
# new_dict[["functions"][0](2, 3, 4) = 24] 
```
