# Методы, атрибуты и функции

**функции из коробки**

abs(), aiter(), all(), any(), anext(), ascii(), bin(), bool(), breakpoint(), bytearray(), bytes(),
callable(), chr(), classmethod(), compile(), complex(), delattr(), dict(), dir(), divmod(),
enumerate(), eval(), exec(), filter(), float(), format(), frozenset(), getattr(), globals(),
hasattr(), hash(), help(), hex(), id(), input(), int(), isinstance(), issubclass(), iter(), len(),
list(), locals(), map(), max(), memoryview(), min(), next(), object(), oct(), open(), ord(),
pow(), print(), property(), range(), repr(), reversed(), round(), set(), setattr(), slice(),
sorted(), staticmethod(), str(), sum(), super(), tuple(), type(), vars(), zip().

При создании своей функции рекомендуется делать 2 отступа в начале и конце. А так же если есть совпадение по названию с уже существующей функцией, то ставить в конце чёрточку

```py
"""all(iterable)"""


def all_(iterable): # чёрточка в названии функии и два отступа до и после
    for element in iterable:
        if not element:
            return False
    return True


```

---

- _\_doc\_\_ магический атрибут или дандер, который открывает документацию по типу

- dir() - попытается вернуть список допустимых атрибутов для объекта. Если объект не передавать = список имен в текущей локальной области

- help() выводит подсказку об объекте, который передается в качестве аргумента. более продвинутая версия dir(). help() без аргументов запускает интерактивный режим. В нём можно указывать имена зарезервированных слов, встроенных функций, модулей и получать справочную информацию

- id() - возвращает адрес объекта в оперативной памяти вашего компьютера

- type(object) - Возвращает класс объекта, его тип. Принимает на вход либо сам объект, либо переменную указывающею на объект.

- isinstance(object, classinfo) - Принимает на вход объект и класс и возвращает истину, если объект является экземпляром прямого или косвенного подкласса

- Оператор is - Сравнивает пару объектов на идентичность. Тоже самое что и ==

- hash(object) - Возвращает hash объекта в виде целого числа. Если объект не изменяемый, то можно вычислить hash, а если он изменяемый - hash не вычисляется.

- getsizeof() из модуля sys чтобы посмотреть на затраты памяти

- map(function, iterable) - принимает на вход функцию и последовательность. Функция применяется к каждому элементу последовательности и возвращает map итератор

- filter(function, iterable) - принимает на вход функцию и последовательность. Функция применяется к каждому элементу последовательно и если функция вернёт True, то элемент остаётся в последовательности. Возвращает объект итератор

- zip(\*iterables, strict=False) - принимает несколько последовательностей и итерируется по ним параллельно. Если передать ключевой элемент strict=True, будет ошибка ValueError в случае разного числа элементов в каждой из последовательностей. (параллельная обработка последовательностей при помощи List Comprehension)

- Функция max(el1, el2) - поиск максимума

  - max(iterable, \*[, key, default]) - принимает на вход итеррируемую последовательность

  - max(arg1, arg2, \*args[, key]) - принимает на вход позиционные элементы

- Функция min(el1, el2) - поиск минимума

  - min(iterable, \*[, key, default]) - принимает на вход итеррируемую последовательность

  - min(arg1, arg2, \*args[, key]) - принимает на вход позиционные элементы

- Функция sum(el1, el2) - подсчитывает сумму

  - sum(iterable, /, start=0) - принимает объект итератор. Ключевое значение start задаёт начальное значение для суммирования

- all(iterable) - возвращает истину, если все элементы итерации True

- any(iterable) - возвращает истину если хотя бы один элемент последовательности True

- chr(int) -  принимает на вход число от 0 до 1_114_111 и по этому числу возвращает строковый символ из таблицы Юникод

- ord(char) - принимает на вход строковый символ и возвращает его число из юникод таблицы

- locals() - возвращает неизменяемый словарь локальных переменных (! Если вызвать функцию locals() из основного кода модуля, а не из функции, результат будет аналогичен работе функции globals())

- globals() - возвращает изменяемый словарь из глобальной области видимости

- global - Глобальная, переменные заданные внешнего кода, которые находятся за пределами функции

- nonlocal - Не локальная, когда функция вложена в функцию, можно обращаться к переменным, не доходя до переменных внешнего кода

- vars() - без аргументов работает так же как и locals(). Если передать объект в функцию vars(), функция вернёт атрибут \_\_dict__. А если атрибута нет, вызывет ошибку TypeError

**Примеры**

Синтаксический сахар:

```py
num = num + 1
num += 1
num++ # не работает в Python
```

Аннотация типов (явное указание типов):

```py
a: int = 42
b: float = float(input('num'))
a = a / b
```

```py
def my_func(data: list[int, float]) -> float:
    res = sum(data) / len(data)
    return res

print(my_func([2, 5.5, 15, 8.0, 13.74]))
```

```py
a: int | float = 42
b: float = float(input('Введи число: '))
a = a / b
```

---

<br>

---

<br>

---

- _\_doc\_\_ магический атрибут или дандер, который открывает документацию по типу

```py
print("Hello world!".__doc__)
print(str.__doc__)
```

>str(object='') -> str
>
>str(bytes_or_buffer[, encoding[, errors]]) -> str (и много строчек текста)

---

- dir() - попытается вернуть список допустимых атрибутов для объекта. Если объект не передавать = список имен в текущей локальной области

```py
print(dir('hello world!'))
```

>['\_\_add__', '\_\_class__', '\_\_contains__', '\_\_delattr__', ....]

- help() выводит подсказку об объекте, который передается в
качестве аргумента. более продвинутая версия dir().

```py
help(str)
```

интерактивный режим

```py
help()
```

Для выхода из режима справки используйте команду quit

- id() - возвращает адрес объекта в оперативной памяти вашего компьютера

```py
a = 5
print(id(a))
a = "hello world"
print(id(a))
a = 42.0 * 3.141592 / 2.71828
print(id(a))
```

>1615821406576
>
>1615826697776
>
>1615831485936

- type(object) - Возвращает класс объекта, его тип. Принимает на вход либо сам объект, либо переменную указывающею на объект.

```py
a = 5
print(type(a))
a = "hello world"
print(type(a))
a = 42.0 * 3.141592 / 2.71828
print(type(a))
```

><class 'int'>
>
><class 'str'>
>
><class 'float'>

- isinstance(object, classinfo) - Принимает на вход объект и класс и возвращает истину, если объект является экземпляром прямого или косвенного подкласса

```py
data = 3.14
print(isinstance(data, (int, float, complex)))

data = True
print(isinstance(data, int))
```

> True
>
> True

---

- Оператор is - Сравнивает пару объектов на идентичность

```py
num = 2 + 2 * 2
digit = 36/6
print(num, digit)
print(num == digit)
print(num is digit)
```

>6 6.0
>
>True
>
>False

---

- hash(object) - Возвращает hash объекта в виде целого числа. Если объект не изменяемый, то можно вычислить hash, а если он изменяемый - hash не вычисляется.

```py
x = 42
y = 'text'
z = 3.1415
print(hash(x), hash(y), hash(z))
my_list = [x, y, z]
print(hash(my_list)) # получим ошибку, т.к. list изменяемый
```

>42 -456521654848532 3265468786542332
>
> TypeError: unhashable type:
'list'

---

- getsizeof() из модуля sys чтобы посмотреть на затраты памяти

```py
import sys

STEP = 2 ** 16
num = 1
for _ in range(30):
print(sys.getsizeof(num), num)
num *= STEP
```

> 28 1
>
> 28 65536
>
> 32 4294967296
>
>... и т.д.

- map(function, iterable)

```py
texts = ["Привет", "ЗДОРОВА", "привеТствую"]
res = map(lambda x: x.lower(), texts) # итерация по тексту, где каждый элемент списка попадает в переменную х и приравнивается к нижнему регистру
print(*res) # распаковка map объекта итератора
# привет здорова приветствую
```

- filter(function, iterable)

```py
numbers = [42, -73, 1024]
res = tuple(filter(lambda x: x > 0, numbers)) # в фильтре нужно использовать только булевы операции. если х > 0 то элемент сохраняется. Т.к. мы обернули это в кортеж (что бы не использовать звёздочку), то значения сохраняются в кортеже.
print(res)
# (42, 1024)
```

- zip(\*iterables, strict=False)

```py
names = ["Иван", "Николай", "Пётр"]
salaries = [125_000, 96_000, 109_000]
awards = [0.1, 0.25, 0.13, 0.99] # тут 4 значения, но последнее никак не участвует т.к. zip по умолчанию False 
for name, salary, award in zip(names, salaries, awards): # параллельно обрабатывает сразу 3 списка в цикле
    print(f'{name} заработал {salary:.2f} денег и премию {salary * award:.2f}')
# Иван заработал 125000.00 денег и премию 12500.00
# Николай заработал 96000.00 денег и премию 24000.00
# Пётр заработал 109000.00 денег и премию 14170.00
```

- Функция max(el1, el2), max(iterable, \*[, key, default]), max(arg1, arg2, \*args[, key])

```py
lst_1 = []
lst_2 = [42, 256, 73]
lst_3 = [("Иван", 125_000), ("Николай", 96_000), ("Пётр",
109_000)]
print(max(lst_1, default='empty')) # т.к. последовательность пустая, выведется значение по умолчанию
print(max(*lst_2)) # распаковка элементов списка
print(max(lst_3, key=lambda x: x[1])) # сортировка по ключу, в который мы задаём лямбду функцию, обращаясь к 2-му элементу (к зп) каждого кортежа и ищем максимум
# empty
# 256
# ('Иван', 125000)
```

- Функция min(el1, el2), min(iterable, \*[, key, default]), min(arg1, arg2, \*args[, key])

```py
lst_1 = []
lst_2 = [42, 256, 73]
lst_3 = [("Иван", 125_000), ("Николай", 96_000), ("Пётр",
109_000)]
print(min(lst_1, default='empty')) # т.к. последовательность пустая, выведется значение по умолчанию
print(min(*lst_2)) # распаковка элементов списка
print(min(lst_3, key=lambda x: x[1])) # сортировка по ключу, в который мы задаём лямбду функцию, обращаясь к 2-му элементу (к зп) каждого кортежа и ищем минимум
# empty
# 42
# ('Николай', 96000)
```

- Функция sum(el1, el2), sum(iterable, /, start=0)

```py
my_list = [42, 256, 73]
print(sum(my_list)) # сложение всех элементов списка
print(sum(my_list, start=1024)) # просуммирует все значения списка и сложит с 1024
# 371
# 1395
```

- all(iterable)

```py
# реализация функции all, если бы её небыло
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True

# работа функции
numbers = [42, -73, 1024]
if all(map(lambda x: x > 0, numbers)): # map применяет функцию сравнения к элементам. all проходит по всем элементам которые вернула ф-ция map
    print('Все элементы положительные')
else:
    print('В последовательности есть отрицательные и/или нулевые элементы')
# В последовательности есть отрицательные и/или нулевые элементы
```

- any(iterable)

```py
# реализация функции any, если бы её небыло
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False

# работа функции
numbers = [42, -73, 1024]
if any(map(lambda x: x > 0, numbers)):# map применяет функцию сравнения к элементам. any проходит по всем элементам которые вернула ф-ция map
    print('Хотя бы один элемент положительный')
else:
    print('Все элементы не больше нуля')
# Хотя бы один элемент положительный
```

- chr(int)

```py
print(chr(97))
print(chr(1105))
print(chr(128519))
# a
# ё
# 😇
```

- ord(char)

```py
print(ord('a')) # английская а
print(ord('а')) # русская а
print(ord('😉'))
# 97
# 1072
# 128521
```

- locals()

```py
SIZE = 10

def func(a, b, c):
    x = a + b
    print(locals()) # выведет все переменные внутри функции которые объявлены перед вызовом функции locals(). 
    z = x + c # все переменные после вызова функции locals() в неё не попадут
    return z

func(1, 2, 3)
# {'a': 1, 'b': 2, 'c': 3, 'x': 3}
```

- globals()

```py
SIZE = 10

def func(a, b, c):
    x = a + b # не попадут в глобал т.к. явлаются локальными переменными
    print(globals())
    z = x + c # не попадут в глобал т.к. явлаются локальными переменными
    return z

print(globals())
print(f'{func(1, 2, 3) = }')
# {'__name__': '__main__', '__doc__': 'globals()', '__package__': None, .....} // идентичен второму выводу
# {'__name__': '__main__', '__doc__': 'globals()', '__package__': None, .....} // идентичен первому выводу
# func(1, 2, 3) = 6


# изменения значения в словаре функции globals()
x = 42
glob_dict = globals() # в переменную сохраняем словарь globals()
glob_dict['x'] = 73 # в переменной обращаемся по ключу 'x' и изменяем его значение
print(x)
# x = 73
```

- vars()

```py
# без аргументов сработает как globals()
# с аргументом
print(vars(int))# проверяем какие внутренние методы есть у класса int
# {'__new__': <built-in method __new__ of type object at 0x00007FFEAF088AF0>, '__repr__': <s;ot wrapper '__repr__'....>.....}
```

- global, глабольная переменная

```py
def func(y: int) -> int:
    global x # обращение к переменной вне тела функции
    x += 100 # 42 + 100
    print(f'In func {x = }') 
    return y + 1

x = 42 # сначала задали x значение 42, а потом использовали этот х в функции
print(f'In main {x = }')
z = func(x) 
print(f'{x = }\t{z = }')
# In main x = 42
# In func x = 142
# x = 142  z = 43
```

- nonlocal, не локальная переменная позволяет заглянуть
на верхний уровень вложенности, но не выходить на глобальные переменные
модуля.

```py
def main(a):
    x = 1

    def func(y):
        nonlocal x # взять переменную из функции уровнем выше, но не глобальную
        x += 100 # 1 + 100
        print(f'In func {x = }')
        return y + 1

    return x + func(a)

x = 42 
print(f'In main {x = }')
z = main(x)
print(f'{x = }\t{z = }')
# In main x = 42
# In func x = 101
# x = 42  z = 44
```
