# Testing

### ISTQB (International Software Testing Qualifications Board) - некоммерческая организация, которая занимается вопросами развития сферы тестирования ПО. Это международный стандарт в области тестирования ПО.

## Тестирование
Проверка чего угодно с помощью тестов. Т.е. заранее подготовленного списка вопросов, проверок, испытаний и убедиться, что:
- безопасно
- надёжно
- понятно
- доступно
- обладает прочими показателями, совокупность которых определяет качество программы.

### Тестирование ПО
Это проверка соответствия реального и ожидаемого поведения программы, а так же степени удовлетворения потребностей пользователя. Выполняется на конесном наборе тестов, который составляет тестировщик.

### Тестирование
Одна из техник контроля качества. Включает в себя:

- планирование работ
- проектирование тестов
- выполнение тестирования
- анализ полученных результатов

### Общие признаки тестирования:

- продукт, показатели которого неизвестны.
- заранее подготовленный список проверок
- правила проведения исследования - описание процессов, протоколы.
- Ожидаемый результат тестирования
- фактический результат тестирования

ISTQB определяет тестирование как процесс, содержащий в себе все активности жизненного цикла, как динамические, так и статические. Эти активности включают планирование, подготовку и оценку программного продукта и связанных с этим результаты работ.

1. Тестирование - поэтапный процесс. Включает:
 - планирование тестирования
 - анализ требований
 - проектирование и реализация тестов
 - создание отчётов о ходе и результатах тестирования
 - оценка качества объекта тестирования

2. Совокуаность этопов - это жизненный цикл тестирования

3. В тестировнии вылеляются динамические и статические активности
 - динамические предполагают исполнение готового кода - выполнение тестов на работающей версии программного продукта (это может быть запущенное приложение или открытый сайт)
 - статтические не требуют запуска кода на исполнение, это анализ макетов, рецензирование документации и кода

4. цели тестирования
 - определить насколько ПО соответствует заявленным требования
 - выявить дефекты, то есть отелонения ПО от требований

## Качество

**Качество** - это степень того, насколько компонент, система или процесс соответсвует требования и ожиданиям пользователя.

**Качество ПО** - совокупность характеристик, относящихся к его способности удовлетворять установленные и продпологаемые потребности.

Качествро программногопродукта характеризует набор свойств, определяющих, насколько продукт "хорош" с точки зрения заинтересованных сторон: заказчика, спонсора, пользователя, разработчиков, тестировщиков, инденеров поддержики, сотрудников отдеоа маркетинга, обучения и продаж. У каждого участника может быть своё представление о качестве продукта.

### Критерии качества

есть 8 критериев:
1. функциональность
2. эффективность
3. надёжность
4. удобство использования
5. поддерживаемость
6. переносимость
7. безопасность
8. совместимость

### 1. Функциональность

Продукт или система должны выполнять основные функции - то есть решать те задачи, для которых они созданы.

критерии:
- функциональная полнота - насколько функциональность охватывает и решает задачи пользолвателя. 
- функциональная правильность - насколдько продукт или система обеспечивают правильные результаты с требуемой степенью точности.
- Функциональная целесообразность - насколько функции продукта востребованы пользователем. Иногда дополнительные ненудные функции навязываются пользователю.

### 2. Эффективность
Производительность продукта или системы. Например, как быстро обрабатываются запросы пользователей.

Каритерии:

- Поведение в зависимости от времени - насколько ыстро и оптимвально обрабатывается запрос пользователя.
- Использования ресурсов - насколько оптимально ПО расходует ресурсы.
- вместимость - каковы предельные показатель системы, количество пользователей в единицу времени.

### 3. Надёжность

Степень выполнения указанных функций системой, продуктом или компонентом при определённых условиях в течение конкретного периода времени. А также способность быстро востанавливать работу при отказе оборудования.

Критерии:

- Завершённость - степень удовлетворения потребности при нормально работе системы, продукта или компонента.
- Доступность - степень работоспособности и доступности системы, продукта или компонента при использовании
- Отказоустойчивость - насколько стабильно работает ПО при аппаратных или программных сбоях. Например, при отключении электричества или интернета
- Восстанавливаемость - насколько продукт или система могут восстановить данные и желаемое состояние системы при прерывании или сбое

### 4. Удобство использования

Насколько эффективно продукт удовлетворяет потребности конкретного пользователя. Например, пользователю может быть неудобно работать в приложении - непонятно, куда нажимать.

- узнаваемость - насколько пользователи распознают, что умеет делать продукт
- обучаемость - насколько продукт помогает пользователю научиться эффективно в нём работать. Есть ли в нём подсказки, "обучалки" при первом запуске, неизменный основной интерфейс.
- работоспособность - степень, в которой продукт или система имеют атрибуты, облегчающие управление и контроль
защита от ошибок - насколько система защищает пользоваптелей от ошибок: предотвращает деструктивные действия, показывает сообщения при сбоях или при вводе некорректной информации.
- Эстетика пользовательского интерфейса - степень "приятности" взаимодействия пользователя и интерфейса.
- доступность - насколько широки круг людей может пользоваться продуктом. Зависит от совместимости с программным или аппаратным обеспечением.

### 5. Поддерживаемость

Степень адаптируемости приложения к изменениям.  Например, если пользователь подключит дополнительные датчики, увидит ли их система?

Критерии: 

- Модульность - степень, в которой система состоит из отдельных компонентов. Изменение одного оказывает минимальное влияния на другие.
- Повторное использование - степень, в которой компонент системы изпользуется более чем в одной системе или при создании других компонентов
- Пригодность к анализу - степень эффективности и рещультативности, с которой оценивается влияние на продукт или систему предпологаемого изменения одной или нескольких его частей. Продукт диагностируется на наличие недостатков или причин отказов. Определяются детали, подлежащие модификации.
- Модифицируемость - степень, в которой продукт или система могут эффективно модифицироваться бещ внесения дефектов или ухудшения качества продукта.
- тестируемость - степень эффективности и результативности, с которой станавливаются критерии тестирования для системы, продукта или компонента, а так же выполняются тесты.

### 6. Переносимость

Степень эффективности и результативности, с которой система, продукт или компонент переносятся из одного аппаратного, программного, оперционнного или эксплуатационного окружения в другое. 

Критерии:
- Адаптивность - степень, в которой продукт или система эффективно адаптируются
к разным или развивающимся аппаратным средствам, программному обеспечению или другим операционным средствам, а так же к средам использования.
- простота и лёгкость установки - степень эффективности и продуктивности, с которой продукт или система успешно устанавливаются и (или) удаляются в конкретной среде.
- Заменяемость - степень, в которой продукт может заменить другой указанный программный продукт для идентичной цели и среды.

### 7. Безопасность

Степень, в которой продукт или система защищают информацию и двнные таким образом, что бы лица или другие системы имели степень достиупа к ним, соответствующую из импам и уровням авторизации. Например, что бы злоумышленник не смог перехватить запрост от вашего приложения.

Критерии:
- Конфиденциальность - степень, в которой продукт или система гарантируют, что данные получают только те, кому разрешён доступ к ним.
- Целостность - степень, в которой система, продукт или компонент предотвращают несанкционированный доступ или модификацию компьютерныз программ (данных)
- Невозможность отказаться - степень, в которой действия или события могут быть доказаны без возможности их скрыть или совершить подмену.
- Ответственность - степень, в которой действия объекта однозначно прослеживаются, а так же определяются ответственные лица.
- Подлинность - степень, в которой личность субъекта или ресурса доказываются как заявленная.

### 8. Совместимость
Степень, в которой продукт, система или компонент обмениваются иныормацией с другими продуктами, системами или компонентами и выполняют требуемые функции, совместно используя ту же аппаратную или программную среду.

- Сосуществование - степень, в которой продукт эффективно выполняет требуемые функции при совместном использовании общей срелы и ресурсов с лругими продуктами без вредного воздействия на любой другой продукт. 
- Совместимость - степень, в которой системы, продукты или компоненты обмениваются информацией и используют её.

## Цели тестирования и роль тестировщика
### Тестировать ПО нужно:
1. Процесс тестирования гарантирует, что ПО будет работать в соответствии с оджиданиями клиентов на имеющимся у них оборудовании
2. Выявление проблем на начальном этапе разработки уменьшает объём работ по исправению ошибок на более поздних стадиях, обеспечивает правильное использование ресурсов и предотвращает повышение стоимости
3. Команда тестирования привносит взгляд клиента в роцесс и находит варианты использования, о которых разработчик может не подумать.

Любой сбой, дефект или ошибка, обнаруженная клиентом в готовом продукте, рушат доверие к компании и увеличивают финансовые затраты.

### Цели тестирования ПО
1. Оценка соответствия стандартам компании рабочих продуктов: требования, пользоватедльских историй, проектирования и кода.
2. Проверка выполнения требований.
3. Поиск и предотвращение дефектов.

Такая постановка целей даёт возможность:

1. Повыситьь вероятность, что прилодение, предназначенное для тестирования, будет работать правильно.
2. Повысить вероятность, что приложение, предназначенное для тестирования, букдет соответствовать всем описанным ттребования.
3. Предоставить актуальную информацию о состоянии продукта в конкретный момент.

### Обязанности инженера QA

1. Изучение и уточнение требований к ПО у заказчика (в больших проектаз этим могут заниматься бизнес-аналитики)
2. Написание и доработка сценариев тестирования
3. Тестирование функционала ПО
4. Составление отчётов по обнаруженным недочётам в трекинговой системе - программе, в которую разработчики, программисты и тестировщики могут вностить найденные ошибки и отслеживать их выполнение/невыполнение.
5. Анализ результатов и показателей проведённых тестов.
6. Составление ТЗ на устранение найденных недочётов
7. Мониторинг и отслеживание правок.
8. Проведение повторных тестов, что бы убедиться, что найденные ошибки исправлены.
9. Анализ и оптимизация этапов разработки для устранения причин ошибок и защиты от их повторного появления.
10. Работа с тестовой документацией.

## Принципы тестирования
### 1. Тестирование демонстрирует наличие дефектов
Тестирование показывает, что дефекты есть, но не может доказать, что их нет.

Тестирование снижает вероятность, что в ПО есть дефекты, но, даже если дефекты не обнаружены, не доказывает его полную корректность

### 2. Исчерпывающее тестирование недостижимо
Полное тестирование с использованием всез комбинаций вводов и предусловий физически невыполнимо, кроме тривиальных случаев. Вместо исчерпывающего тестирования используется анализ рисков и расстановка приоритетов, что бы точнее сфокусироваьб усилия по тестированию.

### 3. Раннее тестирование
Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия должны концентрироваться на конкретныз целях. Такой подход поможет раньше найти дефекты.

### 4. Скопление дефектов
Как правило, большинство дефектов обнаруживают в небольшом количестве иожулей. Усилия по тестированию сосредотачиваю пропорционально ожидаемой, а затем и реальной плотности дефектов в модулях.

### 5. Парадокс пестицида
Если одни и те же тесты выполняются много раз, в конечном счёте этот набор тестовых сцунарие больше не будет находить новые дефекты.

Что бы преодолеть парадокс пестицида, тестовые сценарии нужно регулярно рецензировать и корректировать. При этом новые тесты должны быть разносторонними, что бы охватить все компоненты ПО или системы, и найти как можно больше дефектов.

### 6. Тестирование зависит от контекста
Тестирование выполняется по разному в зависимости от контекста. Например, программное обеспечение, где критически важна безопастность, тестироется иначе, чем сайт электронной коммерции.

### 7. Заблуждение об отсутствии ошибок
Обнаружение и исправление дефектов не помогут, если созданная система не подходит пользователь и не удовлетворяет его ожиданиям и потребностям.

## Тестовая среда и тестовые данные
**Тестовая среда** - полигон для испытаний: например, сервер, мобильный телефон и так далее. Настраивается в соответствии с требования тестируемого приложения.

Всё, чем пользуются люди, проходит испытания. Если сделать прибор и сразу продавать его, он может оказаться небезопасным. Поэтому его нужно проверить на полигоне с условиями, максимально приближенным к реальным.

**Окружение** - это среда, место или машина, на которой находится приложение/сайт.

На проекте можно встретить немколько видов таких сред:
- Локальное окружение - всего одна машина, на которой разрабоатывают и тестируют приложение. Тестировщик или разработчик может развернуть её у себя на ноутбуке. Грубо говоря, это виртуалка с копией проекта. Часто у неё огранниченный функционал: например, нет реальных товаров или возможности из оплатить.

- Тестовая - среда тестирования функциональности. Она наполнена тестовыми данными, которые могут показывать случаи, редко возникающие в рабочей среде или удобные для тестирования. Здесь идёт тестирование того, что готовится в продакшен.

- Stage или staging - окружение - среда, в точности походая на продакшн-окружение. Может подключаться к другим продакшен - сервисам и данным, таким как базы данных.

- Боевое оружие - реальная сеть машин, совокупность нескольких окрудений. Не тестовое, а самое настоящее окружение, где работают пользователи. Тестирование в такой среде практически не проводится.

**Тестовые данные** - это набор входных значений, нужных для выполнения тестов. Тестировщики определяют данные в соответствии с требованиями. Для генерации тестовыз данных используют различные инструменты.

**Инструменты генерации** - это программы, которые быстро создают тестовые данные. Их целесообразно использовать в случаях, когда:
- нужно много однотипных данных
- речная генерация тестовых данных занимает много времени (в случает тестирования сложных систем)
- данные нужны для автотестов(код, который пишут тестировщики для покрытия ручных проверок)

**Инструменты генерации**
- таблицы Excel
- онлайн утилиты, например Pairwise Pict Online для генерации попарных данных
- скрипты для выполнения в командной строке
- сложные программы, созданные самими тестировщиками

## Testing, QC, QA
**QC**(Quality Control) - контроль качества: анализ результатов тестирования и качества новых версий выпускаемого продукта.

Задачи:
 - проверка готовности ПО к релизу
 - проверка соответсвия требований и качества проекта

**QA**(Quality Assurance) - обеспечение качества продукта: изучение возможностей изменения и улучшения процесса разработки и куммуникаций в команде.

Тестирование - один из аспектов обеспечения качества.

Задачи:

- Проверка тезнических характеристик и требований к ПО
- оценка рисков
- планирование задач для улучшения качества продукции
- подготовака документации, тестового окружения и данных
- тестирование
- анализ результатов тестирования, а так же составление отчётов и других документов

Тестирование - процесс проверки результатов работы на соответствие установленным требования. Тестировщик - специалист, который занимается такой проверкой: тестирует компоненты продукта или весь продукт целиком на предмет ошибок или неточностей разработки

Тестирование - один из ключевыз процессов в системе обеспечения качества.

## Hard Skills & Soft Skills
**Hard skills** - технические компетенции, которые можно наглядно продемонстрировать, оуенить и проверить. К ним относятся навыки работы с инструментами, знание языков программирования, SQL, системы контроля версий GIT, основ тестирования, техники тест-дизайна, а так же понимание жизненного цикла тестирования, компьюитерная грамотность и многое другое.

**Soft skills** - универсальные социально-психологические качества, которые не зависят от профессии, но непосредственно влияют на успешность человека. К ним относятся коммуникативные навыки, организованность, способность решать конфликты, умение убеждать, работать в команде, адаптивность, обучаемость. Они могут зависеть от характера человека и формироваться с опытом.

В последние годы на Soft skills обращают всё больше внимания. Иногда они оказываются решающими.

____

<br>

# Чек-Листы
Чек-лист - список, содержащий ряд проверок во время тестирования программного продукта.


## Составление чек-листов
Чек-листы составляют на основе технического задания (ТЗ) - одного или нескольких документов, определяющих цель, структуру, свойства и методы проекта.

Так же и тестировщик после знакомства с ТЗ составляет чек-лист, то есть список проверок программного обеспесения. Затем команда или один тестировщик проводят проверки и отмечают исполненные (пройденные) пункты чек-листа.

### Последовательность действий
Сперва тестировщик знакомится с требованиями и только потом составляет по этим требованиям чек-лист.

Если нужно, требования делят на атомные части, то есть декомпозируют, разбивают на небольшие составляющие. Это нужно, что бы с ними было удобнее работать.

Последовательность действий при составлении чек-листа:

1. Определить все возможнве проверки
2. Сгруппировать проверки в разделы
3. Определить тестовые данные, если они необходимы
4. Подумать, какие колонки будут в чек-листе

Затем состовляется сам чек-лист

### Правила составления

1. Один пункт - одна операция

Пункты чек-листа - это однозначные атомарные (выполняющие одно действие) и полные (логически завершённые) операции. Например, авторизация в профиль пользователя и редактирование данных пользователя - две разные задачи. В списке проверок их оформляют отдельными пунктами.

2. Пункты всегда начинаются с существительного или глагола неоплределённой формы.

При составлении пунктов важно придерживаться унифицированных форм: начинать их с существительного ("проверка", "добавление", "отправка") или неопределённой формы глагола ("проверить", "добавить", "отправить"). Так пункты будут однозначными и понятными.

3. Соблюдайте структуру.

Что бы выполнять чек-лист было удобно, лучше составлять тесты так, что бы они исходили из логики пользования функционала. Например:
- в рамках раздела "регистрация и личный профиль" - регистрация на сайте, редактирования профиля
- в рамках раздела "форма обратной связи" - валидация полей, отправка письма, доставка письма

4. Ничего не придумывайте

Чек-лист важно составлять, опираясь на требования. Не придумывайте то, чего нет в требовании.

5. Общепринятые названия

Хорошо, когда в команде все разговаривают на одном языке, используют общую терминологию

Если один тестировщик в команде называет линию, разделяющую элементы на странице, дивайдером, а остальные - сепаратором, может возникнуть недопонимание.

### Оформление чек-листов
Разбор на проекте:

Есть экран товара пользователя. Пользователь может перейти на карточку своего товара из профиля. На карточке есть слайдер, кнопки продвижения (поднятия товара в выдече), шеринга товара (возможность подельться в соц.сетях), а так же цена, название и описание товара.

Лично опредеоить, в каком модуле будет находиться карточка товара, затем определить название модуля - карточка товара. После идукт сами проверки.

**Важно!** Напротив каждой из проверок есть статусы. Тестировщик ставит их только после выполнения каждого из пунктов чек-листа.

### Варианты колонок в чек-листе
В зависимости от того, что принято на проекте и как удобнее команде, есть несколько видов оформления чек-листов.

#### простейший

В чек-листе две колонки: действие и результат - пройдено (passed) или не пройдено (failed). Исполнитель самостоятельно подбирает тестовые данные. Их необязательно фиксировать в чек-листе. Преимущества - быстрое составление.

#### простейший с комментарием

Похож на простейший, но с дополнительной колонкой для комментария. В ней указываются примечания, ссылки на созданные дефекты и прочая полезная информация.

#### С тестовыми данными

Кроме действия и результата в чек-листе указано, на каких тестовых данных бедт проводиться тестирование.

#### Проверки с детализацией по тестовым данным

Тестовые данные, на которых тестировщик выполняет проверку, могут указываться в столбце "действие"

#### Проверка с детализацией по версиям

В чек-листе хранится история прохождения для разных версий ПО. Это полезно для отслеживания: в одних местах чаще возникают ошибки, а в других всё относительно стабильно.

#### Проверка с детализацие по окружениям

Задача тестирования - проверять работу ПО в разных условиях, то есть с разными окружениями. Веб-приложения должны работать без ошибок во всех браузераз, а мобильные - на всех устройствах и разных операционных системах.

### Виды чек-листов

#### Специальные и универсальные

**Специальные** чек-листы создают и использую для конкретных проектов. Их пункты соответствуют его специфике. По специальному чек-листу тестировщик проверяет возможность выполнить уникальное действие, предусмотренное требованиями.

**Универсальные** чек-листы подходят для тестирования проектов одного типа.

Проверка по универсальному чек-листу не привязывается к графическим элементам или конкретной реальзации. Проверяется сама возможность выполнить действие.

Для универсального чек-листа составляется абстрактный список проверок.

Пример:
- Переход в профиль пользователя
- Отображается аватарка пользователя
- Отображается имя пользователя

#### Связанные и несвязанные чек-листы

Пункты чек-листа могут быть в разной степени связаны друг с другом. В зависимости от этого выделяются три типа чек-листов:

- Подробный перечень
- Связанный чек-лист
- Несвязанный чек-лист

**Подробный перечень** (Laundry list) - упрощает понимание и восприятие информации. Элементы списка группируются по критериям, порядрок не влияет на точность данных.

По сути, главная ценность подробного списка - верно подобранные категории, по которым происходит группировка. Его можно сравнить с сортировкой белья разных цветов при стирке. Альтернативный перевод Laundry list - список белья, отданный в стирку.

Пример:
1. Вёрстка
- вёрска не "едет" во всех утверждённых ТЗ браузерах.
- Работают динамические элементы, нет явных ошибок отображения.
- нет горизонтального скролла
- Прочее

2. Содержимое
- нет орфографических и грамматических ошибок
- Удалены тексты заглушки
- Навсез страницах есть контент
- Есть политика конфеденциальности и подтверждения согласия на обработку персональных данных от пользователей при сборе любых данных
- прочее

3. Функциональность
- Нет битых ссылок
- все страницы сайта доступны из главной навигации
- ссылка на открытую страницу подсвечивается в меню
- прочее

4. Безопасность и быстродействие
- нет визуальных проблем с быстродействием
- установлены последние версии используемы библиотек
- Настроено резервное копирование
- у посторонних пользователей нет доступа к закрытым файлам
- прочее

Для проверки сайта не важно, будет ли сначала проверяться вёрстка, а потом содержимое, или наоборот. Важнее сгруппировать проверки таким образом, чтобы:
- одну группу проверок выполнял один человек
- была возможность распараллелить проверки (взять разные проверки разным тестировщиками), что бы повысить скорость работы.

**в связанном чек-листе** ( strongly sequential checklist) - последовательность влияет на результат. Ключевой этап работы над созданием связанного чек-листа - корректное размещение информации

Пример - предполётная контрольная таблица, которую использует персонал авиакомпаний. Её задача - определить, можно ли эксплуатировать конкретный самолёт. В ней важна строгая последовательность характеристик для адекватной оценки машины.

Пример связанного чек-листа для проверки поведения окна программы.

1. новое окно открывается при двойном клике на ярлык.
2. окно сворачивается в панель задач при нажатии кнопки "свернуть"
3. окно разворачивается из панель задач при нажатии на ярлык панели задач
4. окно закрывается при нажатии кнопки "закрыть"

Пункты 2 и 3 нельзя поменять местами. Нельзя развернуть открытое окно, а на свёрнутом окне не будет кнопки "закрыть"

**в несвязанном чек-листе** (weakly sequebtial checklist) - последовательность размещения данных играет скорее психологическую роль, нежели логическую.

Несвязанный чек-лист - среднее между пробным перечнем и связынным чек-листом. Связать между элементами есть, но изменение порядка не повлияет на результат проверки.

Пример несвязанного чек-листа для тестирования социальной сети:

1. пользователь может создать публикацию
2. пользователь видит публикации открытых аккаунтов, независимо от нгаличия подписки.
3. пользователь видит публикации закрытых аккаунтов, на которые он подписан
4. пользователь не видит публикации закрытых аккаунтов, на которые он не подписан
5. пользователь может удалить публикацию.

Эти действия тестируются в любом порядке независимо друг от друга. Но психологически комфортнее идти именно в таком порядке.


### Правила выполнения чек-листа

1. Не пропускать проверки чек-листа. Если какие-то пункты нельзя проверить тз-за багов или недоступности среды, надо отметить их и вернуться к ним позже.
2. Если указываются тестовые данные, нужно использовать именно их.
3. Указывать результат и комментарий.

### Резолюция

Когда исследуемый объект протестирован, нужно выставить кейсу резолюцию, то есть вердикт - прошл он проверку или нет.

Распространённые статусы:
- passed - успешно пройден
- failed - кейс не прошёл проверку
- skipped - пропуск проверки
- blocked - проверка заблокирована
- untested - кейс ещё не брали в работу

passed - ставится, когда исследуемый объект проходит проверку в соответствии с ТЗ.

failed - исследуемый объект не соответствует ТЗ. Например, функционал поломан, не работает или его нет

skipped - пропуск проверки кейса. Наример, из-за  нехватки времени или если в кейсе есть неточности: он устарел, из документации вы понимаете, что его уже изменили в проекте

blocked - проверка заблокирована поломанным функционалом, от которого прямо или косвенно зависит тестируемый. Например, есть функционал "авторизация пользователя" и функционал "редактирование данных пользователя". Разработчик допустил ошибку в коде и функционал авторизации поломан - ему мы выносим резолюцию failed. Проверить редактирование данных пользователя не можем - выставляем статус blocked/ В комментарии указываем, почему не можем протестировать этот функционал

## Преимущества и недостатки чек-листа
Плюсы:

- Чек-листы затрагивают большее кольчество кейсов, так как при прохождении их можно по - разному выполнять.
- Сокращают затраты на содержание и поддержку тестов.
- Обеспечтвают высокую скорость тестирования: не нужно отмечать результат каждого шага тестировщика, достаточно общего результата проверки.
- Позволяют проходить и комбинировать тесты по-разному, в зависимости от предпостений сотрудников. Показывают статистику: кто, когда и что проходил - с детализацией по сборке продукта и окружению, на котором проводилось тестирование.
- Улучшают представление о системе в целом, показывают статус её готовности.
- показывают объём проделанной работы по тестированию

Минусы: 
- Начинающие тестировщики не всегда эффективно проводят тесты без достаточно подробной документации.
- чек-листы не возможно использовать для обучения начинающих сотрудников, так как в них недостаточно подробных сведений.
- руководителю или заказчику может быть недостаточно того уровня детализации, который предлагают чек-листы.
- неопределённость тестового набора: каждый тестировщик выполняет пункт чек-листа по-своему.

### Распространённые ошибки
1. Не атомарные проверки:
- не верно:

  1. авторизовался в профиле пользователя и изменил имя пользователя
  2. редактирование номера телефона

  <br>

- верно:

  1. авторизация по номеру телефона
  2. переход в профиль пользователя
  3. редактирование имени пользователя
  4. редактирование номера телефона пользователя
  5. редактирование почты пользователя.

  <br>

2. Не корректная форма глагола
- не верно:

  1. авторизовался в профиле пользователя
  2. отредактировал номер телефона

  <br>

- верно:

  1. авторизация по номеру телефона
  2. редактирование номера телефона

  <br>

3. Нет разделителя по модулям

- не верно:

  1. авторизация по номеру телефона
  2. редактирование номера телефона
  3. редактирование имени пользователя

  <br>

- верно:

  1. Авторизация
      - авторизация по номеру телефона
  2. Профиль пользователя
      - редактирование номера телефона
      - редактирование имени пользователя


## Программы для составления и хранения чек-листов

### Google - таблицы
Чек-листы наглядные, действия и результаты распределены
по ячейкам.

Минусы:
- Google-таблицы могут быть запрещены политикой безопасности;
- Документы Excel неудобно модифицировать.

  <br>

### TMS - системы — Test Management System

Чек-листы можно составлять в таблицах Excel — на некоторых проектах так и делают. Но общепринято использовать специальные инструменты — Test Management System (TMS) или системы управления тестированием.

Популярные системы управления тестированием:
- Test Link
- Test IT
- Zephyr
- qTest
- PractiTest
- TestLodge
- TestRail
- Qase.io
- Tematoo
- Test Collab
- HP ALM
- Testuff
- XQual

плюсы:
- удобное оформление тестовой
документации
- структурированное отображение
- удобное выполнение кейсов
- наглядный отчёт после
прохождения

минусы:
- дополнительный инструмент в
команде, который может
требовать настройки
- большинство TMS — платные

### RMS - системы - Requirements Management Systems

это средства поддержки и
автоматизации работы с требованиями на протяжении всего жизненного цикла
разработки программного продукта. В них тоже можно составлять и хранить
чек-листы, но это не очень удобно и затратно по времени
___

<br>

# Тест - кейсы

Тестовый случай (тест-кейс) — это совокупность шагов, конкретных условий и
параметров, нужных для проверки работы тестируемой функции или её части.

тест-кейс — это небольшая инструкция по проверке работы функции.

В нём описывается:
- какие шаги нужно выполнить (например, какие кнопки нажать, чекбоксы
активировать, данные внести), чтобы проверить работу участка системы;
- какой результат должен быть у каждого шага.

В тест-кейсе есть подробная детализация для каждой из проверок, а в чек-листе —
нет.

## Атрибуты тест-кейса
У тест-кейса есть обязательные атрибуты (необходимые поля). Большая часть
заполняется на этапе проектирования тест-кейса, несколько — после прохождения
теста.

### Атрибуты на этапе проектирования тест-кейсов

1. **ID тест-кейса** — уникальный идентификатор, присваивается автоматически.
2. **Название** — краткое описание сценария, который проверяет тест-кейс.
3. **Шаги** — последовательность действий, чтобы проверить работу функции или
выполнение сценария.
4. **Ожидаемый результат** — как должна вести себя система после каждого шага
тест-кейса, то есть то поведение, которое мы ожидаем получить после
выполнения конкретного действия или последовательности действий.
5. **Приоритет тест-кейса** зависит от приоритета функций и сценариев, которые он
проверяет. Определяет очерёдность выполнения теста во время тестирования.
Например, при высоком приоритете тест-кейс будет в начале очереди на
выполнение, а при низком — в конце. Если во втором случае что-то сломано, для
нас это не так критично, как в первом.
6. **Тестовые данные** — данные, которые используются для проверки. Могут
указываться в шагах тест-кейса или в отдельном файле с указанием ссылки на
них. Это, например, данные для авторизации пользователя или данные тестовой
карты для оплаты заказа.
7. **Предусловия** — действия, которые нужно выполнить, прежде чем приступать к
тест-кейсу, а также настройки приложения и тестовой среды.

    Например, если мы проверяем отправку сообщения в чате с другом в
    социальной сети, мы точно знаем, что пользователь должен быть авторизован.
    Но сама авторизация как набор действий с вводом логина/пароля не имеет
    отношения к отправке сообщения другу. Таким образом, правильно будет
    указать в предусловии этого кейса, что пользователь должен быть авторизован,
    а страница чата — открыта. В самих шагах мы будем описывать действия,
    имеющие непосредственное отношение к отправке сообщения другу.
8. **Постусловия** — выполнение тест-кейса, как правило, переводит систему из
одного состояния в другое: меняются настройки, производятся расчёты.
Состояние, в которое нужно привести систему после прохождения тест-кейса,
указывается в постусловии.
 
    Допустим, мы проводили тестирование кейса с редактированием данных
пользователя на боевом сервере (на окружении, которым пользуются обычные пользователи) и в процессе тестирования изменили часть данных на
ненастоящие: вместо имени указали странную последовательность букв, в
описании интересов написали несвязный текст, вместо фотографии человека
прикрепили небо.
Но, так как мы тестируем на продакшене, наш тестовый профиль может попасть
в выдачу обычным пользователям, и это будет выглядеть странно. Чтобы этого
избежать, мы можем в постусловиях указать, что все изменённые значения надо
вернуть в исходное состояние и указать, какие данные надо ввести в каждое
поле.

### Атрибуты на этапе исполнения тест-кейсов

1. **Фактический результат** — то, что мы получаем после выполнения всего
тест-кейса или его конкретного шага. Это необязательный атрибут, его можно не
указывать. Но если он указывается, в нём может быть как краткое описание
того, что мы получили по факту прохождения шага / шагов, так и статус для
каждого фактического результата.

    Если фактический результат совпадает с ожидаемым, в графе с фактическим
    ставится статус passed — тест-кейс успешно пройден, ошибок не обнаружено.
    Если результат отличается от ожидаемого — статус failed — проверка провалена,
    полученный результат не соответствует ожидаемому. Во втором случае
    тестировщик создаёт отчёт о дефекте. К тест-кейсу
    обязательно добавляется ссылка на дефект, обнаруженный при исполнении.

2. **Статус тест-кейса**

- passed — успешно пройден
- failed — кейс не прошел проверку
- skipped — пропуск проверки
- blocked — проверка заблокирована
- untested — кейс еще не брали в работу


## Составление тест-кейсов
Как писать тест-кейсы по требованиям - зависит от того, в каком виде они будут представлены — в виде текста разной
степени детализации, в виде схем, майнд-карт или use case (пользовательских
сценариев).

Вне зависимости от вида требований можно выделить общий алгоритм:

1. Продумайте, какие именно сценарии и функции нужно покрыть тест-кейсами.
Для этого определите, какие новые возможности и сценарии появятся за счёт
новой фичи, с какими функциями из существующих связана новая фича.
2. Сформулируйте названия для тест-кейсов.
3. Определите для каждого сценария нужные предусловия: например,
пользователь или другой объект системы должен быть в определённом
состоянии.
4. Опишите шаги, по которым будете проверять сценарий, в соответствии с
требованиями. Всегда внимательно следите, чтобы не было пропусков.
5. Опишите ожидаемый результат в соответствии с требованиями.
6. Заполните остальные атрибуты этапа, если нужно.

Тест-кейс готов. Ничего сложного, если знать правила составления и работы.

## Правила работы с тест-кейсами
1. Один тест-кейс — одна проверка или один сценарий.

2. Заголовок точно описывает суть тест-кейса. По нему можно определить
характер проверок, не открывая шаги теста: то есть что конкретно
проверяется в функциональности. Если мы говорим про кейс с отправкой сообщения, заголовок может быть следующим: «Отправка сообщения другу
из раздела “Чаты”»

3. Названия для элементов приложения (кнопок, чекбоксов, элементов меню)
точные. Тест-кейсы используют разные люди, всем должно быть понятно их
содержание. Не общепринятые названия элементов допускаются только в тех
случаях, когда они понятны для всей команды.

4. Простой технический стиль без объяснений базовых понятий работы ПО.
Подробности описываются в требованиях или спецификации. Тест-кейс не
должен быть сочинением, иначе его будет трудно и долго читать.

5. Нет пропущенных шагов: каждое следующее действие вытекает из
предыдущего. Например, в кейсе на проверку подписки на пользователя
сразу после шага «Запустить приложение» не должно быть шага
«Подписаться на пользователя», ведь нужно ещё перейти на страницу
пользователя, на которого будем подписываться.

    Простой способ проверить, нет ли пропуска — пройти тест-кейс строго по
описанным шагам, ничего не додумывая.

6. Нет описания очевидных действий (например, разблокировки девайса).
Лучше начинать с ненулевого состояния и определённого экрана. О них
сообщить в предусловии.

7. Нет зависимостей от других тест-кейсов. Часто для выполнения тест-кейса
нужно попасть в определённое состояние пользователя. В таких случаях
высок соблазн в предусловии сослаться на тест-кейс, в котором мы как раз
попадаем в нужное состояние. Но это неправильно: спустя время тест-кейс,
на который мы ссылаемся, может быть удален или изменён. Поэтому чётко
описываем в предусловии, что должно быть сделано до выполнения
тест-кейса, в шагах чётко прописываем все действия, даже если они частично
дублируют действия из другого тест-кейса

8. Каждый тест-кейс уникален и не дублирует другой.

9. Обнаруженная ошибка становится очевидной. Шаги тест-кейса и ожидаемые
результаты описываются таким образом, чтобы отклонение от них явно
свидетельствовало о дефекте.

10. Гибкость для модификации. В тест-кейсе легко добавить, изменить или
убрать шаг, в том числе в середине теста, а также изменить тестовые данные.

## Ошибки в тест - кейсах

1. Заголовка нет или он сформулирован некорректно. Например, из заголовка
«Кнопка “Сохранить”» или «Чат с поддержкой» непонятно, что мы проверяем
в кейсе. То, что они есть, или их функциональность?

2. Ссылки ведут на разные или недействительные требования. В тест-кейсах
можно ссылаться на требования, но если мы используем несколько ссылок,
стоит убедиться, что их содержимое актуально и не противоречит друг другу.

3. Используются личные формы глаголов: «нажми», «перейдите», «укажи». В
тест-кейсах, как и в чек-листах, следует использовать обезличенные формы
глаголов: «нажать», «перейти», «указать».

4. Пунктуационные, орфографические, синтаксические ошибки. Текст с
ошибками и опечатками читать сложнее, чем текст, не нарушающий правила
языка.

5. «Выдумывание» особенностей поведения приложения без отсылки к
требованиям. Тест-кейс должен описывать сценарий и ожидаемые
результаты чётко в соответствии с требованиями. Тестировщик ничего не
выдумывает.

6. Нет описания приготовления к выполнению тест-кейса, если требуются
предусловия. Например, для проверки фишек верифицированного
пользователя в соцсети нам нужен такой верифицированный пользователь.
При тестировании у нас есть возможность создать его через админку (не так,
как это происходит у обычного пользователя). Нам подойдёт этот вариант, так
как мы проверяем не верификацию, а функцию, доступную такому
пользователю.

    Соответственно, верификация пользователя — наше предусловие. В нём
обязательно нужно либо сказать, что надо верифицировать пользователя по
такой-то ссылке, либо дать конкретные данные для авторизации
пользователем

## Примеры тест-кейсов
Тест-кейсы составляются исходя из требования. Поэтому сперва внимательно
ознакомимся с требованием, а потом уже составим тест-кейсы.

Представим, что есть форма регистрации. Заголовок формы — «Начни бесплатно».
Шрифт — Sans Serif, размер текста — 40px. Есть три поля:

1. **«Имя и фамилия»**. Принимает на вход русский и английский текст. Когда
пользователь начинает заполнять поле, плейсхолдер (текст-подсказка)
скрывается.
2. **«Email»**. Принимает на вход адрес электронной почты в формате
email@mail.ru. Когда пользователь начинает заполнять поле, плейсхолдер
скрывается.
3. **«Номер телефона»**. Пользователь может выбрать страну и ввести свой
номер телефона. При вводе номера автоматически добавится код выбранной
страны. Вводимый номер будет разделяться пробелами.

Для отправки формы есть кнопка «Начать». Она становится активной (на неё можно
нажать), если заполнены все поля.

Есть два чекбокса:
- «Я подтверждаю согласие на обработку персональных данных в соответствии
с условиями Политики конфиденциальности, ознакомился и согласен с
условиями Пользовательского соглашения»;
- «Я согласен получать уведомления о новых продуктах и предложениях
GeekBrains и его партнеров»

При определённых условиях отображаются ошибки:
- если поле «Имя и фамилия» не заполнено — «Заполните поле Имя и
фамилия»;
- если поле «Email» не заполнено — «Заполните поле Email»;
- Если поле «Номер телефона» не заполнено — «Заполните поле Номер
телефона».

Размер текста ошибки — 12px, шрифт — Sans Serif, цвет — #f2363b.

___

Первый тест-кейс будет проверять наличие заголовка формы «Начни бесплатно»

> **ID**: 1
>
>**Название**: отображение заголовка формы регистрации
>
>**Предусловие**: открыта форма регистрации
>
>**Шаг 1**: проверить отображение и наличие заголовка формы
>
>**Ожидаемый результат 1**: заголовок формы «Начни бесплатно» отображается.
Шрифт — Sans Serif, размер текста — 40px.

<br>

Теперь составим второй тест-кейс. Проверим заполнение и отображение поля «Имя
и фамилия». Будет два разных тест-кейса. Начнём с отображения:

>**ID**: 2
>
>**Название**: отображение поля «Имя и фамилия»
>
>**Предусловие**: открыта форма регистрации
>
>**Шаг 1**: проверить наличие поля «Имя и фамилия»
>
>**Ожидаемый результат 1**: поле «Имя и фамилия» отображается в соответствии с
макетом
>
>**Шаг 2**: проверить наличие плейсхолдера в поле «Имя и фамилия»
>
>**Ожидаемый результат 2**: плейсхолдер «Имя и фамилия» отображается в поле,
размер шрифта — 14px

<br>

Далее проверим заполнение поля:

>ID: 3
>
>Название: заполнение поля «Имя и фамилия»
>
>Предусловие: открыта форма регистрации
>
>Шаг 1: клик в поле «Имя и фамилия»
>
>Ожидаемый результат 1: в поле отображается курсор
>
>Шаг 2: ввести в поле Иван Иванов
>
>Ожидаемый результат 2: плейсхолдер скрывается, введённый текст
отображается

<br>

А если пользователь заполнил поле невалидными данными или оставил поле
пустым?

>ID: 4
>
>Название: отображение ошибки «Заполните поле Имя и фамилия»
>
>Предусловие: открыта форма регистрации
>
>Шаг 1: клик на кнопку «Начать»
>
>Ожидаемый результат 1: отображение ошибка «Заполните поле Имя и фамилия».
Размер текста — 12px, шрифт — Sans Serif, цвет — #f2363b
___

## Преимущества и недостатки тест-кейсов

Преимущества:
- За счёт полной детализации шагов тест-кейсы может проходить новичок. По
ним удобно знакомиться с продуктом.
- Достаточно подробное описание бизнес-логики. При неидеальной
организации хранения требований уточнение некоторых моментов проще
будет найти в тест-кейсах.

Недостатки:
- Нужно больше времени на написание, чем для чек-листов.
- Сложно поддерживать. Если изменится бизнес-логика, будут переименованы
разделы или произойдут другие изменения, затрагивающие
пользовательский интерфейс и сценарии использования системы, нужно
будет актуализировать все тест-кейсы, связанные с измененной частью.

## Инструменты для работы с тест-кейсами

Тест-кейсы нужно структурировать, хранить и поддерживать. У тестировщиков
должна быть возможность работать с ними совместно.

Системы для работы с тест-кейсами (test-case management system, TMS) —
автоматизированные приложения, которые позволяют управлять тест-кейсами. К
ним относятся:

- Jira + Zephyr,
- TestRail,
- Allure,
- Test IT,
- TestLink,
- Прочие.

Основные функции инструментов:
1. Создание тест-кейсов — приложения содержат специальные формы и
шаблоны, которые ускоряют процесс разработки тест-кейсов.
2. Выполнение тест-кейсов и запись результатов — тест-кейсы запускаются с
использованием приложения, и результат их исполнения записывается в
систему.
3. Отслеживание дефектов — возможность прикреплять ссылку на дефект,
который обнаружен тест-кейсом. Это позволяет эффективнее отслеживать
исправление дефектов.
4. Отслеживание требований и других проектных документов — в
приложениях можно прикреплять ссылки на требования, по которым
разрабатывается тест-кейс, и отслеживать полноту покрытия требований
тест-кейсами
5. Защита тест-кейсов — тест-кейсы создают для многократного
использования, поэтому их важно защитить от несанкционированных
изменений и удалений. Все действия тестировщиков с тест-кейсами
отслеживаются и сохраняются в истории версий.

## Наборы тест-кейсов

Test case — атомарный элемент тест-плана. Тест-план включает в себя следующие
компоненты:

- **Test suite** — список кейсов, объединённых общим фактором: весь продукт,
конкретная фича и так далее.
- **Test plan** — список тест-сьютов, выбранных для теста.
- **Test run** — проход («прогон») тест-сьютов, выбранных для тестирования в
соответствии с тест-планом.


# Тест-кейс и чек-лист
И тест-кейс, и чек-лист — это упорядоченная последовательность проверок работы
программы. Они представляют собой документацию к продукту и содержат
информацию о его функциональности.

Различия тест-кейса и чек-листа:

- Детализация:
  - тест-кейс - Проверки детализированы,
расписаны по шагам
  - чек-лист - Проверки формулируются в
общем виде. Часто пункт
чек-листа = заголовок тест-кейса

- Понятность:
  - тест-кейс - Понятен любому человеку 
  - чек-лист - Понятен человеку, который
знаком с продуктом

- Эффект пестицида (пропуск ошибок):
  - тест-кейс - Есть риск возникновения,
так как каждый раз
воспроизводятся одни и те
же шаги

  - чек-лист - Риск снижается, так как каждый
выполняет проверку по-своему

## Ценность тест-кейсов и чек-листов
1. **Структурируют и систематизирую подход к тестированию**. Позволяют
оценить объём предстоящей работы, распределить задачи между
тестировщиками в команде, не пропустить важных проверок.
2. **Основа для метрик тестового покрытия.** Помогают оценить, сколько
процентов требований протестируют, а на какие требования тесты ещё не
появились. Иными словами, какой процент технического задания покрыт
тестами.
3. **Основа для увеличения тестового покрытия**. Если тест-кейсов
недостаточно, нужно добавить.
4. **Показатель соответствия ситуации плану**:
- сколько тестов уже выполнено;
- какие из них прошли успешно;
- как много осталось проверить;
- какие функциональности тестировались или нет.
5. **Поддерживают взаимопонимание между заказчиком, разработчиками и тестировщиком**. Написание тест-кейсов часто приводит к дополнительным
вопросам по работе приложения. Это закрывает пробелы в знаниях о
системе, устраняет недопонимание с заказчиком или разработчиком.
6. **Хранят информацию для длительного использования и обмена опытом**
между сотрудниками и командами. Тест-кейсы и чек-листы используются,
чтобы удобно передавать знания о системе другим членам команды, а также
обращаться к ним при решении спорных вопросов — при условии, что
тест-кейсы написаны качественно и корректно.
7. **Основа регрессионного тестирования**. Тест-кейсы делают повторные
проверки регулярными и полноценными.

# Регрессионное тестирование

В течение всего жизненного цикла продукта в него вносят изменения — правки,
доработки, рефакторинг кода и новые фичи. Прежде чем отправить любые
изменения в коде в релиз, нужно убедиться, что работа системы не стала хуже. То
есть перед релизом мы проверяем не только что внесённые изменения
действительно есть и работают корректно, но и проверяем, что старый функционал
не был поломан.

Регрессионное тестирование (regression testing) — тестирование уже проверенной
функциональности после внесения изменений в код для уверенности, что эти
изменения не внесли или не активизировали ошибки в областях, которые не
подвергались изменениям.
Для регрессионного тестирования выбирают уже ранее составленные тест-кейсы

# Тест-дизайн

Тест-дизайн — этап тестирования ПО, на котором проектируются и создаются
тестовые случаи (тест-кейсы). Они соответствуют определённым ранее критериям
качества и целям тестирования.

В начале тестирования мы анализируем требования: определяем, насколько они
полные, чёткие, тестируемые. Когда требования проверены, проанализированы и
приоритизированы, начинается этап написания тест-кейсов — это и есть
тест-дизайн.


Важно, что критерии качества и цели тестирования должны быть определены до
начала написания тест-кейсов. От этих критериев и целей зависит, какими будут
тест-кейсы, для каких модулей они будут описаны в первую очередь, проверка
каких функций будет приоритетной.

Когда мы пишем тест-кейсы, одна из основных задач — создать оптимальное
тестовое покрытие функциональности, то есть не допустить «слепых зон» в
системе, которые не покрываются проверками

Задачи тест-дизайна на проекте:
- максимально покрыть функциональность тестами;
- обнаружить серьёзные баги;
- сократить количество тестов, исключив непродуктивные;
- не пропустить важные тесты.

Не возможно провести исчерпывающее тестирование. Поэтому
нужно применять разные техники, чтобы выполнить его эффективно и вовремя,
избежав при этом проверки лишних кейсов. При этом вся функциональность
должна быть покрыта тестами.

Кроме того, нужно попытаться составить тесты так, чтобы с их помощью можно
было обнаружить критичные дефекты. Нельзя выявить все баги и убедиться в их
отсутствии, но усилия и внимание тестировщиков должны быть направлены на
поиск самых серьёзных дефектов.

Если времени и специалистов мало, важно исключать из работы непродуктивные
тесты, которые не обнаруживают ошибок. В этом тоже помогут техники
тест-дизайна.

## Техники тест-дизайна

1. Классы эквивалентности (эквивалентное разделение).
2. Граничные значения (анализ граничных значений, метод граничных
значений).
3. Попарное тестирование (тестовая комбинаторика, pairwise).
4. Тестирование состояний и переходов.
5. Таблицы принятия решений.
6. Исследовательское тестирование.

### Классы эквивалентности
Класс эквивалентности — набор данных, которые обрабатываются одинаковым
образом и приводят к одному результату

Если известно, что есть группа данных, использование которых приводит систему в
одно и то же состояние, нет необходимости проверять каждое значение из этой
группы отдельно. Исключения возможны, но мы не можем проверять все данные,
так что приходится прибегать к подобным допущениям.

Например, в требованиях есть условие для посещения онлайн-кинотеатра:
«Возраст пользователя — от 16 лет и старше». Результат для пользователей,
которые указывают возраст меньше 16 лет (не важно, 5 или 15), всегда должен
быть одинаковым — сообщение «Извините, в связи с политикой сайта вы не можете
пользоваться сервисом». Так же и со значениями от 16 и выше — не важно, какой
возраст укажет пользователь (16, 23, 75, 99 лет), результат будет одинаковым:
«Добро пожаловать в наш кинотеатр. Желаем приятного просмотра!»

**Тестирование на основе классов эквивалентности**(equivalence partitioning) —
техника тест-дизайна на основе метода чёрного ящика: специалист не знает, как
устроена система, и проходит все шаги тестов, используя только те инструменты,
которые доступны пользователю.

**Цель техники** — обеспечить максимальную проверку всех требований тестами.
Разделяя данные на классы эквивалентности и выбирая лишь несколько значений
из каждого, можно существенно повысить эффективность и скорость тестирования,
разрабатывать и выполнять меньше тест-кейсов.

Есть два признака, что данные в тесте относятся к одному классу эквивалентности:

1. **Если один тест выявит ошибку, остальные, скорее всего, тоже это сделают.** Если в тестах используются значения из одного класса
эквивалентности, и один из тестов выявляет ошибку, остальные тесты,
построенные на данных из этого класса, тоже должны обнаружить эту
ошибку. Например, если онлайн-кинотеатр позволяет пользователю в
возрасте 14 лет зарегистрироваться на сайте, то, вероятнее всего,
регистрация будет возможна и для пользователей, указавших возраст 5, 10,
12 лет. А по требованиям это ошибка.

2. **Если один из тестов не выявит ошибку, остальные, скорее всего, тоже этого не сделают.** Если пользователю, указавшему возраст 15 лет, было
отказано в регистрации на сайте, то нет смысла перебирать все значения от 0
до 15 лет. Вероятнее всего, они тоже обработаются корректно.

Так как в тестировании нельзя быть уверенным в наличии или отсутствии ошибок, в
описаниях часто встречаются комментарии «скорее всего», «с большой долей
вероятности».

Если проводить исчерпывающее тестирование и проверять все варианты,
количество тестов составит минимум 100. Выполнить их
невозможно, поэтому нужно:
1. Разделить данные на классы эквивалентности.
2. Выбрать хотя бы одно значение из каждого класса эквивалентности для
проверки

Например выборка:

от 0 до 15 - вывети "нет"

от 16 до 17 - вывести "да, но"

от 18 до 64 - вывасти "да"

от 65 - 99 - вывести "нет"


Получаем следующие проверки:
- 1-й класс эквивалентности — 0;
- 2-й класс эквивалентности — 16;
- 3-й класс эквивалентности — 18;
- 4-й класс эквивалентности — 65.

Из каждого класса эквивалентности мы выбрали значения, чтобы сократить
количество тестов (теперь их 4 вместо 100). Любые другие значения из класса
эквивалентности должны давать те же результаты, что и выбранные.


Мы рассмотрели данные, которые можно расположить на числовой
прямой — классы эквивалентности этих данных будут **линейными**. Их можно
разбить на диапазоны с точными границами начала и конца (от 0 до 15, от 16 до 18
и так далее).

**Нелинейные** классы эквивалентности — это набор неупорядоченных данных. У них
нет границ, они являются частью множества данных. Пример — расширения
файлов, операционные системы, группы пользователей с различными правами
(пользователь, модератор, администратор) и так далее. В этом случае можно
выделить только два класса эквивалентности:

- валидный — соответствует требованиям,
- невалидный — не соответствует требованиям или обрабатывается системой
отличным от валидного класса образом.

Например, приложение обрабатывает только файлы в форматах MP3, APE, WAV.
Остальные форматы файлов системой не поддерживаются. В этом случае
невозможно выделить диапазоны и определить их границы. Можно выделить
только валидный класс эквивалентности, то есть допустимые форматы файлов, и
невалидный — все остальные форматы, которые система не поддерживает. Так как
в валидном классе всего три значения, их можно проверить все, а из невалидного
класса выбрать несколько вариантов.

Кроме чисел, на классы эквивалентности можно разбить:
- **символы** — они могут быть валидными (@ в адресе электронной почты) и
невалидными (?, %,*);
- **длину строки** — например, валидный класс от 1 до 30 знаков, невалидный —
всё остальное (меньше 1 и больше 30);
- **объём памяти**, который необходим приложению для стабильной работы;
- **разрешение экрана** — всё, что меньше или больше заявленных требований к
разрешению экрана, будет относиться к невалидным классам;
- **версии операционных систем, библиотек** — также определяются согласно
требованиям. Например, приложение должно работать на ОС Windows 7, но
поддержка Windows Nt уже не требуется.
- **объём передаваемых данных** — по требованиям. Например, если мощности
сервера не позволяют обработать объём данных больше определённого
значения.

Классы эквивалентности — одна из основных техник тест-дизайна. Именно с ней
тестировщики и тест-дизайнеры работают чаще всего. Она сокращает число тестов
(можно выбрать только несколько значений из класса эквивалентности), но к
использованию нужно подходить внимательно: если неверно выделить класс
эквивалентности, можно получить некорректные результаты тестирования и
пропустить ошибку.

### Граничные значения

**Граничное значение** (border condition, boundary condition) — значение на границе
классов эквивалентности.

Когда тестировщик работает с линейными классами эквивалентности (диапазонами
значений), может потребоваться определить границы диапазона, чтобы точно
отнести значение к конкретному классу эквивалентности.

У каждого диапазона будет начальная и конечная граница — это места
повышенного риска ошибок, так как разработчик может указать некорректный знак
неравенства или задать ошибочную границу диапазона.

**Техника анализа граничных значений** (boundary value testing) — проверка
поведения продукта на граничных значениях входных данных.

Граничные значения обязательно использовать при написании тестов, так как
именно на границе классов эквивалентности чаще всего и обнаруживаются
ошибки. Например, если в требованиях указано, что пользователь сайта должен
быть старше 16 лет, тестировщику следует уточнить у аналитика, входит ли
значение «16 лет» в валидный класс эквивалентности. А затем — проверить,
действительно ли это реализовано в приложении. Может оказаться, что
разработчик понял требования иначе и указал в коде, что сайтом могут
пользоваться лица с 17 лет (>16 вместо >=16)

Алгоритм определения граничных значений:
1. Выделить классы эквивалентности.
2. Определить граничные значения этих классов.
3. Определить, к какому классу будет относиться каждая граница.
4. Для каждой границы провести тесты: проверить значения до границы, на ней
и сразу после неё.

применение:

1. Определяем граничные классы эквивалентности:
- 1-й класс эквивалентности — 0–15;
- 2-й класс эквивалентности — 16–17;
- 3-й класс эквивалентности — 18–64;
- 4-й класс эквивалентности — 65–99.

2. Выделяем граничные значения:


|............. нет............ |...... да, но...... |......................... да ........................ | ........ нет ............ |

0-----------------16-------------18-----------------------------65---------------99

4. Для каждой границы выделяем три значения:
- {-1, 0, 1},
- {15, 16, 17},
- {17, 18, 19},
- {64, 65, 66},
- {98, 99, 100}.

5. Исключаем дубликаты (в нашем случае 17) и добавляем негативные
проверки, например: {-36, 1001, FRED, %$#@}

На основании этих данных можно проводить тестирование.


### Попарное тестирование

Попарное тестирование (pairwise testing) — техника формирования наборов
тестовых данных, при которой каждое тестируемое значение каждого из проверяемых параметров хотя бы раз сочетается с каждым из тестируемых
значений всех остальных проверяемых параметров

Попарное тестирование — разработка тестов методом чёрного ящика, в которой
тестовые сценарии разрабатываются таким образом, чтобы выполнить все
возможные отдельные комбинации каждой пары входных параметров.

Попарное тестирование — техника тестирования, в которой вместо проверки всех
возможных комбинаций значений всех параметров проверяются только
комбинации значений каждой пары параметров.

Техника применяется на проектах, где много параметров и их значений. Для
примера возьмём сайт по поиску автомобилей.

Для поиска автомобиля пользователь может указать марку, модель, цену, тип
автомобиля и другие параметры. У каждого из них множество возможных значений.
У параметра «Коробка передач» — четыре: механика, автомат, робот, вариатор. У
«Типа кузова» — седан, хетчбэк, универсал и другие. У параметров «Марка» и
«Модель» несколько десятков значений. Если и другие параметры, проверить все
варианты и их сочетания невозможно.

Есть теория, что большинство дефектов возникают при комбинации двух
параметров. Если проверка будет состоять из параметров BMW + Х6 + от 1 500 000 руб. до 4 000 000 руб. + с пробегом + от 2001 до 2019 года + автомат + хетчбэк +
бензин, то ошибка с большей вероятностью возникнет из-за сочетания только двух
из вышеперечисленных параметров

Например, при совпадении пары «хетчбэк + бензин», а не из-за сочетания всех
параметров одновременно. Поэтому есть смысл проверять сочетания двух значений
разных параметров. Это сократит количество тестов и увеличит вероятность
выявления дефектов.

Рассмотрим пример: нужно проверить форму, содержащую 20 чекбоксов
(элементов страницы с двумя значениями — выключен/включен). Если проводить
полный перебор для проверки сочетания всех значений, может потребоваться
1 048 576 тестов. Выполнить столько физически невозможно. Попарное
тестирование позволяет сократить количество проверок до 10.

В примере хорошо прослеживаются особенности техники попарного тестирования:
она наиболее эффективна при большом количестве параметров, которые имеют
ограниченное количество значений. В примере 20 чекбоксов, по два значения для
каждого — это позволило ощутимо сократить количество тестов

Если у параметра очень много значений, как у «Марки» в примере с сайтом по
поиску автомобилей, сокращение проверок при применении техники попарного
тестирования может быть незначительным. В этом случае удобнее разделить
значения на два класса эквивалентности — валидный и невалидный. К
невалидному классу будет относиться пустое поле или некорректные значения, а к
валидному — все корректные значения.

Учитывая огромное количество тестируемых параметров и значений в
приложениях, сгруппировать их по технике pairwise вручную невозможно либо
очень трудозатратно. Для этого есть специальные инструменты, и один из
популярных — PICT.

### Тестирование состояний и переходов

**Тестирование на основе состояний и переходов** (State-Transition Testing)
используют для фиксирования требований и описания дизайна приложения.

В проекте может быть большой набор требований с описанием состояния системы и
условий, при которых она в них переходит. Без визуального представления этих
состояний трудно увидеть всю цепочку событий. А это может привести к дефектам
архитектуры и дизайна приложения уже на уровне требований. Например, теперь в
мессенджерах можно удалять сообщения как у отправителя, так и у получателя. То
есть для состояния сообщения «Отправлено» или «Прочитано» должен быть
предусмотрен переход в состояние «Удалено». Если он будет упущен при
составлении требований, приложение получится неудобным для пользователей,
вряд ли его станут часто запускать.

Чтобы избежать таких ошибок, можно использовать технику тест-дизайна
«Тестирование состояний и переходов». Она позволяет составлять тестовые
сценарии, основываясь на визуальном представлении состояний и переходов
системы.

основне понятия,
которые используются при составлении диаграмм переходов и состояний:

**Точка входа** — старт работы системы или приложения.

**Переход** (transition) — переход системы из одного состояния в другое. Происходит в
результате действий пользователя или при определённых условиях.

**Событие** (event) — действие пользователя, которые он выполнил для перевода
системы в другое состояние. Или действия самой системы, меняющие её состояние.

**Действие** (action) — реакция приложения на действия пользователя или самой
системы (на событие).

**Условия перехода** (transition conditions) — условия, которые необходимы для
перехода системы в другое состояние. Например, изменение даты для начисления
процентов на вклад.

**Состояние** (state) — состояние системы до или после перехода в результате
действий пользователя или при определённых условиях.

**Точка выхода** — успешное окончание полного цикла работы приложения, то есть
выполнение всех переходов и состояний.

**Роли пользователей** (actors) — пользователи, которые могут по-разному влиять на
систему в зависимости от уровня прав доступа (зарегистрированный пользователь,
менеджер, администратор).


Классический пример — бронирование авиабилетов. Начнём с позитивного
сценария: пользователь успешно проходит весь цикл бронирования, включая
оплату и использование билета. Всегда стоит начинать с позитивных проверок,
чтобы убедиться, что система работоспособна и выполняет ключевые функции.

Если это не так, дальнейшее тестирование не имеет смысла до устранения
дефектов

 
1. Точкой старта будет вход в систему бронирования и выбор нужного билета.
Затем пользователь передаёт информацию, нужную для бронирования (имя и
фамилию, паспортные данные), и нажимает кнопку «Забронировать».
Нажатие можно считать событием. После него стартует таймер до окончания
срока оплаты. Система перешла в первое состояние — «Билет
забронирован».
2. Дальнейшее событие — «Оплата билета». Переводит систему в следующее
состояние — «Билет оплачен».
3. Затем по событию «Получить билет» система должна выполнить действие
«Отправка билета по email» и перейти в другое состояние — «Билет получен».
4. Последним звеном в этой цепочке будет событие «Предъявление билета при
посадке» (в примере часть событий пропущена — в реальных проектах их,
конечно, может быть намного больше). Состояние «Билет использован» —
цикл бронирования успешно завершён, система попадает в точку выхода.

--Передача данных/старт таймера--> |Билет забронирован| --оплата--> |Билет оплачен| --Получить/Отправка по email--> |Билет получен| --Предъявить на посадке--> |Билет использован| -->конец 

Рассмотренный сценарий — позитивный, он не предполагает дополнительных
действий пользователя. Это, конечно, невозможно, так как не всегда бронирование
билета должно заканчиваться его использованием. Пользователь может не
оплатить билет или оплатить, но потом отменить и прочее. Эти состояния также
нужно отразить на диаграмме.

При построении диаграмм состояний и переходов важно:
- не допускать пересечения линий переходов — это усложняет визуальное
восприятие диаграммы и может привести к ошибочному переходу;
- сложные процессы лучше представлять в виде нескольких диаграмм — если
охватить всё одной схемой, она будет слишком трудной для понимания;
- главную последовательность состояний следует размещать на одной
горизонтальной линии, чтобы прослеживался позитивный сценарий работы
системы. Дополнительные состояния можно представить в виде ответвлений
и разместить по бокам от основной последовательности.

Плюсы диаграмм состояний:
- позволяют визуализировать состояния продукта;
- демонстрируют варианты переходов, которые можно пропустить;
- помогают отследить дефект, сужая его локацию до конкретного перехода;
- показывают внутреннюю механику продукта

Минусы:
- можно пропустить неочевидные переходы;
- при слишком сложной структуре продукта диаграммы могут стать
громоздкими и запутанными;
- являются только основой к применению других методов;
- бесполезны при плохом знании продукта.

### Таблицы принятия решений
**Таблицы принятия решений** (таблицы решений) — способ компактно представить
модели со сложной логикой. А ещё это техника тестирования чёрного ящика,
которая применяется для систем со сложной логикой.

Таблицы принятия решений используют, чтобы упорядочить и задокументировать
сложную логику приложения, а также протестировать все комбинации условий и
состояний

Часто аналитики создают требования в виде сплошного текста с множеством
условий вида «если …, то ...». Например, «если пользователь старше 16 лет, то
доступ на сайт разрешён», «если пользователь авторизован в системе, то его
личные данные в форме заказа должны быть заполнены автоматически».
Тестирование таких требований и создание на их основе тест-кейсов трудоёмкое,
нужно повышенное внимание. Для таких случаев можно использовать технику
тест-дизайна «Таблицы принятия решений»


Состовляющие таблицы принятия решений:

**Условия** (conditions) — короткое описание входных условий (данных),
сформулированное в виде вопроса. Ответ — либо «да/нет», либо ограниченный
набор значений. Например: «Пользователь авторизован в системе?», «Вид
документа, предоставленный клиентом, — паспорт, водительские права,
загранпаспорт?»

**Действия**(actions) — чёткое описание ожидаемого результата, действия системы.
Формулировка действия — утвердительное предложение. Одно предложение
обязательно описывает только одно действие. Например: «Данные заполнены
автоматически», «Сообщение об ошибке отображается на экране».

**Значения** (values) — значения, допустимые для входных данных, указанных в
условии. Например: «да/нет», «паспорт, водительские права, загранпаспорт».

**Правила** (rules) — комбинации входных данных, которые отражены в таблице.

Пример:

Требование: для поддержания системы лояльности провести информационную
рассылку постоянным клиентам.

Содержание писем зависит от следующих условий:
1. Клиенты типа А, В получают стандартное письмо.
2. Клиенты типа С получают специальное письмо.
3. Клиентам, совершившим пять и более покупок или купившим на сумму более
500 долларов, в письме сообщается о дополнительной скидке 20% на
следующий заказ

Начнём составлять таблицу по плану:
1. Разбить требование на условия.
2. Посчитать количество возможных правил (комбинаций).
3. Составить таблицу принятия решений.
4. Исключить лишние комбинации, если они есть.
5. Создать тесты.

Теперь разберём каждый пункт.
1. Разбить требование на условия.

Можно выделить три условия:
- тип клиента;
- пять и более покупок;
- сумма больше 500 долларов.

2. Посчитать количество возможных правил (комбинаций).

Расчёт можно выполнить по формуле X = Y1 ⋅ Y2 ⋅ … ⋅ Yn, где:

- Х — вычисляемое количество комбинаций;
- Y1...Yn — количество вариантов каждого условия;
- N — количество условий

Таким образом, получим:
- Y1 = 4 (четыре значения для условия «Тип клиента» — «A, B, C, D»);
- Y2 = 2 и Y3 = 2 (по два значения для условий «Пять и более покупок» и «Сумма
больше 500 долларов» — «YES/NO»);
- N = 3 (требование содержит три условия);
- X = 4 ⋅ 2 ⋅ 2;
- Х = 16 правил (комбинаций условий).

3. Составить таблицу принятия решений.

Заносим в таблицу условия, значения и правила следующим образом:

| Условия               | Значеня | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
|-----------------------|---------|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|
| Тип клиента           | А,B,С,D | А | А | А | А | B | B | B | B | С | С  | С  | С  | D  | D  | D  | D  |
| 5 и более покупок     | Y,N     | Y | Y | N | N | Y | Y | N | N | Y | Y  | N  | N  | Y  | Y  | N  | N  |
| Сумма больше 500 дол. | Y,N     | Y | N | Y | N | Y | N | Y | N | Y | N  | Y  | N  | Y  | N  | Y  | N  |
| **Действия:**              |         |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |
| Стандартное письмо    |         | x | x | x | x | x | x | x | x |   |    |    |    | ?  | ?  | ?  | ?  |
| Cпециальное письмо    |         |   |   |   |   |   |   |   |   | x | x  | x  | x  | ?  | ?  | ?  | ?  |
| Сообщение о скидке    |         | ? | x | x |   | ? | x | x |   | ? | x  | x  |    | ?  | ?  | ?  | ?  |
| Не получают письмо    |         |   |   |   |   |   |   |   |   |   |    |    |    | ?  | ?  | ?  | ?  |

В таблицу добавили тип клиента «D» — это все остальные типы клиентов, если будут
выявлены те, которые не подпадают под характеристики для клиентов типа «А, В,
С».

Для правил, которые не отражены в требованиях, использован «?» (в требованиях
не указано, какое письмо должно быть отправлено, когда сочетаются условия
«более пяти покупок» и «сумма больше 500 долларов», а также как поступить с
клиентами типа D). Ситуации, помеченные знаком вопроса, надо прояснить с
аналитиком или заказчиком.

Первая строка в таблице формируется так: количество всех правил (комбинаций)
делится на количество значений первого условия. То есть 16 (число правил) делим
на 4 (число значений для условия «Тип клиента»). Получаем ряд из четырёх
одинаковых значений подряд (см. таблицу выше). Заполняя остальные строки,
нужно соблюдать последовательность: каждая следующая строка — это
предыдущая строка, разделённая пополам. То есть в первой строке каждое
значение повторялось четыре раза подряд, во второй — два раза, в третьей
происходит чередование значений. Если бы в таблице было ещё одно условие, то в
следующей строке каждое значение снова повторялось бы четыре раза, потом два
раза и так далее.

Также в таблице указываем действия, которые произойдут при совпадении тех или
иных условий. И отмечаем, какое именно действие выполняется при совпадении
условий. В данном случае выделим четыре действия: «Стандартное письмо»,
«Специальное письмо», «Сообщение о скидке», «Не получают письмо».

4. Исключить/добавить комбинации.

В этом случае были добавлены комбинации для дополнительного типа клиента «D».
Могут возникать ситуации, когда в таблице появятся комбинации условий, которые
на практике невозможны. Например, если тестируется форма с двумя кнопками
«Сохранить» и «Отменить», каждая кнопка имеет два значения: «Нажата» / «Не
нажата». Одновременно обе кнопки не могут принимать значение «Нажата» —
значит, такая комбинация должна быть исключена из таблицы.

5. Создать тесты.
В результате получаем тестовые сценарии, которые можно либо перенести в
тест-кейсы, либо оставить в таблице и добавить строку с результатом проверки.

В этом случае:
- Draft — тест, который требует уточнения условий;
- Failed — тест, который прошёл неуспешно, например, был выявлен дефект;
- Passed — тест, который прошёл успешно, функциональность работает.

Плюсы таблиц принятия решений:
- помогают быстро составлять тестовые сценарии;
- позволяют выявить неполноту требований;
- их можно использовать при отсутствии требований;
- можно быстро проверить покрытие требований тест-кейсами;
- позволяют предугадывать возможные ошибки.

Минусы:
- при большом количестве условий таблицы могут быть громоздкими — их
сложно составлять и использовать;
- сложность в корректном определении условий, действий и значений при
первоначальном проектировании.

### Исследовательское тестирование

Исследовательское тестирование — это подход, когда тестировщик
не использует тест-кейсы, а тестирует приложение по определённому сценарию,
который часто составляется прямо во время проверки.

Тестировщик проводит исследовательское тестирование приложения, в результате
которого выявляются дефекты. Тот сценарий (тест), который выявил дефект, нужно
задокументировать (создать тест-кейс), чтобы в дальнейшем проверять, что дефект
исправлен и не появился вновь. Кроме того, стоит создать тест-кейсы (если их нет)
и для проверки похожих сценариев, чтобы обнаружить другие подобные дефекты. В
некоторых случаях проверки, проведённые при исследовательском тестировании,
следует документировать (создавать тест-кейс), даже если они не обнаружили
дефект. Это нужно, чтобы повторять проверки в будущем, в том числе при
регрессионном тестировании

Исследовательское тестирование также используют как вспомогательный подход к
тестированию по тест-кейсам. Оно помогает исключить эффект пестицида (когда тест-кейсы перестают выявлять дефекты) при частом использовании одних и тех же
тест-кейсов.

Ещё случаи, когда исследовательское тестирование может быть эффективным:
1. Нужно быстро понять, насколько качественно выполнена новая
функциональность: проверить, что в ней нет критических дефектов.
2. Нужно быстро изучить тестируемый продукт (например, новому
тестировщику на проекте) и получить общую информацию о его основной
функциональности.
3. Нужно проконтролировать работу других тестировщиков: проверить без
использования тест-кейсов, что приложение работает (с позиции
пользователя).
4. Недостаточно времени для составления тест-кейсов.
5. Отсутствуют требования, на основании которых можно составить тест-кейсы.
6. Тестируется небольшой проект, для которого не требуется
структурированного подхода к тестированию.
7. В проекте произошли внезапные изменения, которые требуют быстрой
проверки.

Плюсы исследовательского тестирования:
- не нужно тратить время на предварительное описание всех сценариев;
- не нужна поддержка тестовых сценариев;
- нет привыкания к тестовым сценариям, их прохождение не происходит «не
глядя»;
- не теряется цельное видение продукта;
- критические дефекты находятся быстрее;
- повышается скорость тестирования;
- можно сразу начинать тестировать продукт, даже если требований нет
вообще;
- исследовательское тестирование интереснее и креативнее (тесты
ограничиваются только фантазией и глубиной знаний о продукте).

Минусы:
- сложно планировать время на проведение тестирования без
задокументированных заранее сценариев;
- вероятность пропустить ключевые проверки, так как отсутствует
ранжирование сценариев по степени важности;
- сложность оценки полноты покрытия требований тестами;
- требуется высокая квалификация тестировщиков и хорошее знание
тестируемого приложения;
- сложно использовать для регрессионного тестирования;
- невозможно автоматизировать такое тестирование.

Важно понимать, что исследовательское тестирование — не хаотичное без
документации и подготовки. Оно требует планирования и профессиональных
навыков тестировщика.

 Есть решения, позволяющие сделать исследовательское
тестирование более структурированным:

- использование чит-листов — списков базовых проверок, которые можно
применять для тестирования однотипных приложений;
- сессионное тестирование — установка временного интервала для
проведения исследовательского тестирования, например, сессии в 90 минут;
- парное тестирование — проверка одного блока или модуля двумя
тестировщиками, один из которых может проводить тестирование, а второй
— описывать найденные дефекты;
- тест-туры Джеймса Уиттакера — отдельная тема в исследовательском
тестировании.

**Тест-туры** — неформальный подход, который позволяет сделать исследовательское
тестирование ещё более осмысленным и интересным. Они содержат инструкции по
исследованию приложения — по аналогии с тем, как турист изучает город.
Подробнее с этим способом работы с приложением можно познакомиться в статьях:
- Исследовательское тестирование и исследовательские туры Виттакера
https://www.software-testing.by/blog/exploratory-testing-exploratory-tours/
-  Как искать баги — исследовательские туры Уиттакера
http://okiseleva.blogspot.com/2015/01/blog-post_64.html

<br>

___

# Функциональное тестирование

Функциональное тестирование - это тестирование ПО, в процессе которого
проверяется реализация функциональных требований, то есть проверка работы
функциональностей, направленных на решение задач пользователя.

## Три ящика тестирования

Работая с программой, тестировщик обычно держит в уме её архитектурные
компоненты и особенности их взаимодействия.
Бывают ситуации, когда тестировщику ничего не известно об устройстве
программы «под капотом». А иногда тестировщик видит код программы и пишет
тесты, опираясь на него. В каждом случае у тестирования есть особенности,
обусловленные уровнем знаний о внутреннем устройстве программы. В
зависимости от этого уровня выделяются три вида тестирования: чёрного, белого и
серого ящика.

### Метод чёрного ящика

**Чёрный ящик** — это система, внутреннее устройство и механизм работы которой
сложны, неизвестны или не важны в рамках решения задачи.

**Метод чёрного ящика** — метод исследования, при котором вместо свойств и
взаимосвязей составных частей системы изучается реакция системы как целого на
изменяющиеся условия.
У чёрного ящика есть «вход» для ввода информации и «выход» для отображения
результатов работы. При этом происходящие процессы во время работы системы
наблюдателю неизвестны. Состояние выходов функционально зависит от состояния
входов.

**Тестирование чёрного ящика** (black box testing) - 
тестирование, основанное на
анализе функциональной или нефункциональной спецификации системы без
знания внутренней структуры.

У тестировщика нет доступа к коду, он видит приложение как пользователь.
Тестирование проводится через интерфейс приложения. Это ручное тестирование
без знания, что находится «за кулисами» интерфейса.

Тест-дизайн, основанный на технике чёрного ящика, это написание или отбор
тест-кейсов на основе анализа документации без знания внутреннего устройства
программы.

Тестирование чёрного ящика находит ошибки:
1. Функции неправильно реализуются или их нет.
2. Интерфейс отличается от макетов.
3. Данные не записываются в базы или записываются неверно.
4. Недостаточная производительность системы.

Таким образом, тестировщик концентрируется на том, что программа делает, а не
как.

Пример: тестировщик проводит тестирование веб-сайта, не зная особенностей его
реализации. Он использует только предусмотренные разработчиком поля ввода и
кнопки. Источник ожидаемого результата — спецификация (иными словами,
техническое задание).

Преимущества чёрного ящика:
1. Тестирование производится с позиции пользователя, обнаруживает
неточности и противоречия в поведении ПО.
2. Тестировщику не обязательно знать языки программирования.
3. Тестирование проводят независимые специалисты, что помогает избежать
предвзятого отношения.
4. Тест-кейсы пишутся как только готова спецификация

Недостатки чёрного ящика
1. Тестируется ограниченное количество сценариев.
2. Без чёткой спецификации трудно составить эффективные тест-кейсы.
3. Тесты избыточны, если их уже проверил разработчик на уровне модульного
тестирования.

### Метод белого ящика

**Тестирование белого ящика** (white box testing) основано на анализе внутренней
структуры системы, на знании и понимании исходного кода. У тестировщика есть
полный доступ к исходному коду

Для тестирования методом белого ящика нужно знать язык программирования, на
котором написано приложение. Обычно этот вид тестирования применяют
разработчики при написании юнит-тестов. Входные значения отбираются на основе
кода, который будет их обрабатывать.

Техника белого ящика применяется на разных уровнях тестирования, но главным
образом для модульного тестирования компонентов.

Преимущества:
1. Тестирование производится на ранних этапах: пользовательский интерфейс не
требуется.
2. Тестирование более тщательное, с покрытием путей выполнения программы
(условий и операторов).

Недостатки:
1. Для тестирования нужны специальные знания. В первую очередь — язык
программирования.

### Метод серого ящика

**Тестирование серого ящика** (gray box testing) — тестирование в условиях, когда
часть внутренней структуры программы известна. Тестировщик работает не с
кодом приложения, а с часть его внутренней структуры: проверяет запись в базе
данных, лог-файлы, коды ответа от сервера.

Для тестирования веб-приложений методом серого ящика тестировщик использует
инструменты разработчика, например, Chrome DevTools.

Техника серого ящика применяется на интеграционном уровне для проверки
взаимодействия компонентов программы, например, API-интерфейса и базы
данных

Пример: метод серого ящика используется при тестировании веб-сайтов на битые
ссылки. Если тестер сталкивается с проблемой таких ссылок, он может сразу внести
изменения в HTML-код и проверить в реальном времени

Методы тестирования серого ящика:
1. **Матричное тестирование** — определение всех переменных, которые есть в
программе.
2. **Тестирование ортогональных массивов** обеспечивает максимальное
покрытие кода с минимальным количеством тестов.
3. **Pattern Testing** выполняется на данных истории предыдущих дефектов
системы.

## Виды тестирования после изменений в коде
На протяжении всей разработки в код приложения вносят изменения: при
добавлении новых функций и при исправлении дефектов. В результате
тестировщик снова проводит тестирование той части приложения, которая уже
была проверена, но подверглась изменениям. В зависимости от изменений
выделяют регрессионное и повторное тестирование.

**Регрессионное тестирование** (regression testing) — тестирование уже проверенной
функциональности после изменений в коде. Цель — убедиться, что эти изменения
не добавили или не активизировали ошибки в изменённых областях.

**Повторное или подтверждающее тестирование** (re-testing/confirmation testing) —
исполняются тестовые сценарии, выявившие ошибки во время последнего запуска.
Цель — подтвердить, что ошибки исправили, и приложение работает в соответствии
с требованиями.

Повторное тестирование — обязательный этап. Тестировщик должен проверить,
исправлен ли дефект, повторив сценарий, который выявил ошибку.

## Статическое и динамическое тестирование

В зависимости от того, запускается код программы или нет, выделяют два виды
тестирования — статическое и динамическое.

**Статическое тестирование** (static testing) — тестирование системы на уровне
спецификации или реализации без исполнения кода. Так проводится тестирование:

- документации — требований, схем баз данных, тест-кейсов;
- кода приложения — проверка кода перед запуском специалистом, не
участвовавшем в его написании или изменении, то есть аудит кода, или code
review;
- параметров настройки среды приложения;
- подготовленных тестовых данных;
- прототипов пользовательского интерфейса.

Статическое тестирование начинается на ранних этапах жизненного цикла ПО и
продолжается на протяжении всей разработки.

**Динамическое тестирование** (dynamic testing) — тестирование во время
выполнения программного обеспечения, компонента или системы. Проверка —
реальное поведение ПО во время его работы.

Чтобы выполнить динамическое тестирование нужно, чтобы код программы
запустился. Тестируется как система в целом, так и отдельные компоненты. Все
виды функционального тестирования — динамические

## Позитивное и негативное тестирование

Тестирование можно делать по инструкции и проверять, работает ли приложение
согласно требованиям. А можно намеренно совершать некорректные действия,
чтобы понять, как оно будет реагировать. Первый вид тестирования называют
позитивным, а второй — негативным.

**Позитивное тестирование**(positive testing) — тестирование с использованием
только корректных данных. Проверяет, правильно ли приложение выполняет
вызываемые функции. Проводится, чтобы подтвердить работоспособность объекта
тестирования.

Тестировщик полностью следует требованиям и инструкции по работе с
приложением. Например, при тестировании формы регистрации заполняет её
корректными данными и нажимает кнопку «Зарегистрироваться».

**Негативное тестирование** (negative testing) направлено на исследование работы
приложения в ситуациях, когда выполняют некорректные операции или используют
данные, потенциально приводящие к ошибкам.

Негативное тестирование — это не попытка «сломать» систему, а проверка системы
на правильность обработки некорректных действий пользователя.

1. Если пользователь при регистрации укажет email без символа @, приложение
выведет сообщение об ошибке.
2. Если сообщение об ошибке не появится, и пользователь не зарегистрируется,
это будет считаться дефектом.
3. Если банковское приложение для выдачи кредита требует, чтобы возраст
заёмщика был больше или равен 18, негативным тестом будет проверка
возраста 15 лет, а успешным завершением — сообщение о невозможности
выдать кредит из-за возраста, не соответствующего требованиям.

Позитивные тесты проводятся, чтобы убедиться в правильной работе приложения.
После этого переходят к негативным проверкам.

## Альфа- и бета-тестирование

В зависимости от того, кто выполняет тестирование перед выпуском продукта на
рынок, выделяют альфа- и бета-тестирование.

**Альфа-тестирование** (alpha testing) — внутреннее пробное использование.
Выполняется внутри организации-разработчика, иногда — с частичным
привлечением пользователей.

Альфа-тестирование проводится после модульного, интеграционного и системного
тестирования, когда продукт уже частично готов к выпуску на рынок, но нужно его
доработать. Представляет собой имитацию реального использования, но
выполняется либо командой тестирования, либо другими сотрудниками
компании-разработчика в тестовой среде. Например, на тестовых стендах,
недоступных внешним пользователям.

После внутреннего альфа-тестирования выпускают бета-версию продукта и
передают её на внешнее (публичное) бета-тестирование.

**Бета-тестирование** (beta testing) выполняется вне организации с активным
привлечением пользователей. Обычно представляет собой форму внешнего
приёмочного тестирования.

Продукт должен быть стабилен, но не исключено появление проблем и выявление
недостатков. Поэтому сначала доступ открывают для небольшой группы лояльных
пользователей, чтобы проверить работоспособность и получить обратную связь.

Часто при тестировании игр применяют ОБТ — открытое бета-тестирование.
Привлекают либо всех желающих (например, заполнившие заявку), либо людей с
опытом в играх такого типа. Обычно у компаний есть контакты тех, с кем они
постоянно сотрудничают при проведении бета-тестирования.

Иногда бета-версия размещается в конкретной стране или регионе, чтобы собрать
статистику или получить обратную связь прежде, чем полность вывести продукт на
рынок

## Тестирование на основе тест-кейсов и исследовательское тестирование

**Тестирование на основе тест-кейсов**(scripted testing, test case based testing) —
формализованный подход, при котором тестирование проводится на основе
заранее подготовленных тест-кейсов. Часто используется на проектах по
разработке ПО, так как позволяет структурировать процесс тестирования и сделать
его контролируемым.

**Исследовательское тестирование** (exploratory testing) — частично
формализованный подход, при котором тестировщик работает с приложением по
сценарию. В процессе сценарий дорабатывается для более полного исследования
приложения.

Во время исследовательского тестирования неформальные (не созданные заранее)
тестовые сценарии разрабатываются, выполняются, анализируются и оцениваются
динамически. Результаты тестирования используют для изучения компонента или
системы и последующей разработки тестовых сценариев для непокрытых областей.

Исследовательское тестирование проводится сессиями. Сессия — это выделенный
промежуток времени, в котором тестировщик исследует программу, ориентируясь
на поставленную цель. Например, требуется проверить все поля ввода на странице.
Во время сессии ведётся протокол, а тестировщик фиксирует действия и
результаты.

Исследовательское тестирование лучше всего подходит, когда документация
недостаточная или вовсе отсутствует, в условиях сжатых сроков и как дополнение к
другим, более формальным методам тестирования.

Свободное (интуитивное) тестирование (ad hoc testing) — неформальный подход, в
котором не предполагается использование тест-кейсов, чек-листов и сценариев. Тестировщик полностью опирается на свой профессионализм и интуицию при
спонтанном выполнении проверок.

Часто при таком подходе предполагается, что тестировщик плохо знаком с
тестируемым приложением. Этот вид тестирования используется редко и только
как дополнение к полностью или частично формализованному тестированию, когда
для исследования некоторых функций приложения нет тест-кейсов, или они ещё не
написаны.

## Смоук-тесты

**Дымовой тест или смоук - тест** (от англ. smoke - дым) — это тип тестирования
программного обеспечения, который проверяет, правильно ли работают наиболее
важные функции программного приложения. Термин «дымовое тестирование»
происходит от идеи тестирования приложения ровно настолько, чтобы увидеть,
«горит» ли оно (т. е. сильно ли сломано), прежде чем проводить более глубокое
тестирование.

Дымовые тесты обычно запускаются после сборки, чтобы убедиться, что
приложение может быть запущено и работают самые основные функции, прежде
чем будет выполнено более всестороннее тестирование.

Дымовое тестирование может быть как ручным, так и автоматизированным.

**Ручное дымовое тестирование** — это процесс, при котором тестировщики вручную
выполняют набор предопределенных тестовых случаев для проверки основных
функций приложения. Этот метод предполагает ручное вмешательство, когда
тестировщики физически выполняют шаги в приложении и наблюдают за
результатами.

**Автоматизированное дымовое тестирование** использует программные инструменты
для автоматического выполнения набора предопределенных тестовых случаев.
Тестовые примеры написаны на языке сценариев, таком как Python или Java, и
автоматически выполняются инструментом тестирования.

Этапы дымового теста могут варьироваться в зависимости от конкретного
приложения и целей теста, но обычно включают следующее:

- Проверка сборки: убедитесь, что сборка завершена и может быть
установлена в целевой среде.
- Настройка среды: убедитесь, что тестовая среда настроена правильно и
соответствует необходимым требованиям.
- Выполнение теста: запустите наиболее важные и часто используемые
функции приложения, чтобы определить, работают ли они должным образом.
- Оценка результатов испытаний: проанализируйте результаты дымовых
испытаний и определите, произошли ли какие-либо сбои.
- Отчет о дефектах: задокументируйте любые сбои или дефекты,
обнаруженные во время дымового теста.
- Очистка: удалите все временные файлы и восстановите тестовую среду до
исходного состояния.

**Примечание**. Конкретные этапы дымового теста могут различаться в зависимости
от процесса разработки программного обеспечения и используемой методологии
тестирования.

Помните, что цель дымового теста — быстро выявить основные проблемы с
приложением и обеспечить уверенность в том, что приложение достаточно
стабильно, чтобы приступить к дальнейшему тестированию.

## Нефункциональное тестирование

**Нефункциональное тестирование** (non-functional testing) — анализ свойств
компонента или системы, не относящихся к функциональности. То есть,
проверяется, «как работает система».

Нефункциональное тестирование включает:

1. Тестирование производительности:
    - нагрузочное тестирование,
    - тестирование масштабируемости,
    - объёмное тестирование,
    - стрессовое тестирование.
2. Тестирование безопасности.
3. Инсталляционное тестирование
4. Тестирование интерфейса (GUI/UI-тестирование).
5. Тестирование удобства использования.
6. Тестирование локализации.
7. Тестирование надёжности.

### Тестирование производительности

**Тестирование производительности** (performance testing) помогает определить
работоспособность, стабильность, потребление ресурсов в условиях разных
сценариев использования и нагрузок.

Задача системы — обрабатывать нужное количество данных за установленное
время. В случае превышения запланированных объёмов входных данных, система
восстанавливается после отказа без потери данных.

Пример: в требованиях указано, что система обрабатывает тысячу запросов
пользователей в секунду без потери производительности. Чтобы проверить
выполнение этого требования, тестировщик формирует тысячу запросов
пользователей и направляет их на сервер

#### Нагрузочное тестирование

**Нагрузочное тестирование** (load testing) — тип тестирования производительности,
цель которого — оценить поведение системы при возрастающей нагрузке, а также
определить нагрузку, которую может выдержать компонент или система.

Нагрузка повышается, пока не будут достигнуты нужные характеристики. Затем
отслеживается поведение на протяжении повышения загрузки системы. При этом:

- измеряют время выполнения операций при определённой интенсивности
этих операций;
- определяют количество пользователей, одновременно работающих с
приложением;
- определяют границы приемлемой производительности при увеличении
нагрузки и при увеличении интенсивности выполнения операций.

#### Тестирование масштабируемости

**Тестирование масштабируемости**(scalability testing) — тестирование для
измерения возможностей вертикального и горизонтального масштабирования с
точки зрения любой из нефункциональных возможностей: увеличение количества
пользователей, рост количества транзакций, увеличение объёма данных.

**Вертикальное масштабирование** — это увеличение производительности каждого
компонента системы для повышения общей производительности. Например,
увеличивается объём оперативной памяти на сервере, чтобы он быстрее
обрабатывал запросы. Это повысит производительность всей системы.

**Горизонтальное масштабирование** — разбиение системы на структурные
компоненты и разнесение их по отдельным физическим машинам. А также
увеличение количества серверов, параллельно выполняющих одну и ту же
функцию. Например, увеличивается количество серверов, но каждый выполняет
одну и ту же задачу: принимает одни и те же запросы и отвечает на них.

Если разработчики заранее не подумают, как они увеличат ресурсы при росте
популярности, они потеряют значительную часть прибыли.

#### Объёмное тестирование

**Объёмное тестирование** (volume testing) — тестирование на больших объёмах
данных. Например, тестируется поведение приложения при попытке загрузить в его
базу данных нескольких файлов очень большого размера.

#### Стрессовое тестирование
Стрессовое тестирование (stress testing) оценивает систему на граничных
значениях рабочих нагрузок, за их пределами или в состоянии ограниченных
ресурсов — памяти или доступа к серверу

Например, стандартная нагрузка на сервер приложения — 1000 запросов в секунду.
При стрессовом тестировании нужно проверить её поведение при увеличении
нагрузки до 10 000 запросов в секунду. Если система не обработает такое
количество запросов и отключится, при перезапуске все данные и настройки
сохранятся.

#### Основные понятия при тестировании производительности

**Время задержки** (Latency) — временной интервал между запросом и ответом. Если
говорят, что у сервиса время задержки составляет 100ms, значит, ему требуется
100 миллисекунд на обработку запроса и ответ. Чем ниже время задержки, тем
лучше клиентский опыт

**Время ответа** (Response time) — время, нужное для ответа на запрос.

**Пропускная способность** (Throughput) — фактическое количество запросов,
которое обрабатывает система за определённое время. Метрика пропускной
способности показывает объём данных, полученных и обработанных в момент
времени.

Важно не отделять показатели времени задержки от пропускной способности.
Высокий показатель времени задержки часто напрямую связан с увеличением
показателей метрики пропускной способности. Пропускная способность обычно
измеряется в rps — количестве запросов в секунду (requests per second).

**Ширина пропускания канала** (Bandwidth) — максимальное число запросов,
обрабатываемых системой. Используется, чтобы измерять максимальный объём,
который обрабатывает приложение.

**Процент ошибок** — отношение невалидных ответов к валидным за промежуток
времени.

**Инсталляционное тестирование** (installation testing) — тестирование, направленное
на проверку успешной установки и настройки, обновления или удаления
приложения при различном программном и аппаратном окружении. Оно позволяет
оценить работоспособность системы после завершения работы инсталлятора.

**Тестирование пользовательского интерфейса** — проверка соответствия
интерфейса и требований, насколько удобно пользователям работать с
программным продуктом. Проверяют, ведёт ли себя программное обеспечение в
соответствии со спецификацией, когда пользователь взаимодействует с ним с
помощью клавиатуры и мыши (когда тестируется десктопное приложение), или с
помощью сенсорного экрана, жестов или движений устройства (когда тестируется
мобильное приложение).

**UX-тестирование** (юзабилити-тестирование, Usability testing) — проверка того,
насколько легко пользователь понимает и осваивает программу, включая
функциональную составляющую (саму систему) и её документацию —
пользовательские инструкции.

Результат грамотного UX-тестирования — перечень рекомендаций: что и как
изменить, чтобы повысить количество конверсий и превратить посетителей сайта в
постоянных и преданных пользователей.

**Тестирование локализации** (localization testing) — проверка адаптации
программного обеспечения для нового места эксплуатации. Включает проверку
изменения языка и культурной адаптации.

Например, проверяют, насколько перевод приложения на русский язык корректен с
точки зрения орфографии, грамматики, культурных особенностей. Проверка
затрагивает все части приложения, в том числе названия кнопок, всплывающие
подсказки, надписи над полями. Это касается приложений, которые планируется
внедрять в разных странах

**Тестирование безопасности** (security testing) — тестирование программного
продукта на предмет его защищённости. Основные понятия, которые охватывает
тестирование: конфиденциальность, целостность и сохранность данных,
аутентификация, авторизация и невозможность отказа от авторства (атрибуты
качества). Проводится для тех объектов, в работе которых обеспечение
защищённости — одна из важнейших задач.

**Тестирование надёжности** (reliability testing) — тестирование способности
приложения выполнять свои функции в заданных условиях на протяжении
заданного времени или установленного количества операций.

Неважно, как долго идёт это тестирование, основная задача — наблюдая за
потреблением ресурсов в течение определённого времени, выявить утечки памяти
и проследить, чтобы скорость обработки данных или время отклика в начале теста
и с течением времени не уменьшалась. Иначе вероятны сбои в работе продукта и
перезагрузки системы.

<br>

---
# Баг

При работе с ПО пользователь или тестировщик ожидает определённого поведения
системы. Дефект (баг) — это отклонение фактического результата от ожидаемого.

По легенде, термин «баг» впервые был применён 9 сентября 1947 года, когда
учёные Гарвардского университета, тестировавшие вычислительную машину Mark
II Aiken Relay Calculator, нашли мотылька, застрявшего между контактами
электромеханического реле. Именно тогда Грейс Хоппер произнесла этот термин.
Насекомое достали и вклеили в технический дневник, сопроводив надписью: «First
actual case of bug being found» (англ. «первый реальный случай, когда жук был
найден»).

Как определить, что поведение, которое мы видим, некорректное? Нужно
опираться на требования. Но не у всех проектов есть документация: требования,
спецификации и технические задания. Поэтому тестировщику приходится
опираться:
-  на предыдущий опыт тестирования подобных приложений;
- на критерии качества, работающие на рынке;
- на логику и здравый смысл.

## Причины появления дефектов

**Проблемы в коммуникациях между членами команды**. Если команда не работает
слаженно, то разработка тормозится или идёт с ошибками. Разработчик не понял
требований, задал вопрос аналитику, но не получил ответ или получил его слишком
поздно — вероятно, в системе появились дефекты. Тестировщик обнаружил
отклоняющееся поведение, но не нашёл документов с описанием «как надо», не
дождался ответа разработчика или заказчика — есть риск получить инцидент.

**Сложность программного обеспечения**. Чем сложнее программа, тем больше
вероятность появления ошибок. Сложная логика работы, множество
взаимодействующих систем, нетривиальные алгоритмы — всё это элементы
повышенного риска появления дефектов.

**Изменение требований.** ПО подстраивается под меняющийся мир и потребности
пользователя. Изменения требований приводят к модификации кода, и чем позже
изменились требования, тем больше работ выполняется для трансформации
системы. Правки влекут за собой новые дефекты или возврат уже исправленных.

**Ошибки программистов**. Разработчики должны писать и документировать код по
установленным правилам. Но нехватка времени вынуждает их работать быстро,
поэтому срабатывает фактор невнимательности и забывчивости.

**Ошибки тестировщиков**. Тестировщики не замечают ошибки из-за недостатка
опыта, упускают проблемы из-за сложности программного обеспечения и
невозможности исчерпывающего тестирования

## Жизненный цикл дефекта

Тестировщик создаёт новый дефект в системе, затем его чинит разработчик, и, если
работоспособность ПО восстановилась, тестировщик закрывает дефект. Эти этапы
составляют жизненный цикл дефекта

Этапы жизненного цикла дефекта:
- Open — специалист создал баг-репорт.
- In progress — баг назначен на разработчика, разработчик начал его
исправлять.
- Ready for test — разработчик всё поправил, задача готова к тестированию.
- Testing — тестировщик взял задачу в тестирование.
- Reopen — тестировщик проверил, задача нуждается в доработках.
- Close — задача работает, как описано в ТЗ.
- Frozen — разработка задачи приостановлена из-за изменений в продукте.

## Отчёт о дефекте

Чтобы сообщить о дефекте, тестировщик описывает его установленным образом. В
результате получается отчёт о дефекте, или баг-репорт (bug report). Для краткости
его называют «баг».

**Отчёт о дефекте** — это документ, который описывает шаги воспроизведения
дефекта, фактический и ожидаемый результат, серьёзность дефекта и приоритет
устранения.

Отчёты о дефектах — инструменты для сбора статистики на проекте. Они помогают
определить:

- в каких областях приложения;
- при каких условиях концентрируются дефекты.

Важная функция отчётов о дефектах — приоритизация проблем. Если дефектов
много, и времени на все не хватает, разработчику нужно понимать, какие из них
хуже всего влияют на работу приложения, и что исправить в первую очередь.

Отчёт о дефекте предоставляет важные подробности для понимания сути
случившегося, анализирует причины возникновения проблемы и даёт
рекомендации для исправления.

### Атрибуты отчёта о дефекте

1. Уникальный идентификатор (ID) — присваивается автоматически.
2. Тема (заголовок) — кратко сформулированная суть дефекта по правилу «Что?
Где? Когда?».
3. Подробное описание — более широкое описание сути дефекта (может быть,
может не быть).
4. Предусловие — описывается подготовка системы для воспроизведения
дефекта.
5. Шаги для воспроизведения — последовательное описание действий,
которые привели к выявлению дефекта. Описываются максимально
подробно с указанием конкретных вводимых значений.
6. Фактический результат — указывается, что работает не так, в каком месте
продукта и при каких условиях.
7. Ожидаемый результат — указывается, как именно должна работать система,
по мнению тестировщика, основанному на документации.
8. Вложения — скриншоты, видео или лог-файлы.
9. Серьёзность дефекта — влияние на работоспособность приложения.
10. Приоритет дефекта — влияние на очерёдность выполнения задачи или
устранения дефекта. Чем выше приоритет, тем быстрее нужно исправить
дефект.
11. Статус — текущее состояние дефекта: «открыт», «в работе», «исправлен» и
так далее

Окружение:
1. Компонент или среда — на какой платформе или операционной системе
дефект воспроизводится: iOS, Android, Windows, Mac.
2. Версия — на каком этапе разработки программного продукта обнаружился
дефект.
3. Назначение — кто ответственен за починку.
4. Номер сборки, в которой обнаружился дефект.

### Название отчёта

Название должно содержать ответы на вопросы:
1. Что происходит или не происходит согласно спецификации или
представлению тестировщика о нормальной работе продукта?
2. В каком месте интерфейса пользователя или архитектуры программного
продукта находится проблема?
3. В какой момент работы программного продукта, при наступлении какого
события или при каких условиях проявляется проблема?

**Это называется правилом «Что? Где? Когда?»**

Название содержит предельно краткую, но достаточную для понимания сути
проблемы информацию о дефекте. Оптимальная длина — до 10 слов и 80 символов.
В названии не употребляются слова «некорректно», «неправильно», «ошибка» и так
далее. Тестировщик описывает, что именно некорректно, и в чём именно ошибка

**Неудачное название:**

«Возникает ошибка при загрузке
большого файла».

*Какая ошибка? Насколько большого
файла?*

**Удачное название:**

«Код ошибки DB1001 при загрузке
файла 10 Гб».

### Шаги по воспроизведению

**Шаги по воспроизведению** — это руководство к действию для тех, кто будет
решать проблему. Составляются по правилам:

1. Вернуться к началу. Первый шаг — указание, по какой ссылке перейти, какое
окно открыть и так далее

2. Шаг отвечает на вопрос «Что сделать?».
    - нажать кнопку «Найти»;
    - ввести валидный email и пароль;
    - заполнить требуемые поля валидными данными.

3. Количество шагов — от 2 до 8. Если больше, нужно подумать, какие шаги
лишние.

4. Последний шаг — указание, на что обратить внимание:
    - осмотреть текст в выпадающем списке (подменю);
    - обратить внимание на Profile-форму.

### Фактический и ожидаемый результаты

Фактический и ожидаемый результаты рекомендуется описывать так:
1. Один дефект — один фактический и ожидаемый результат.
2. В ожидаемом результате дать ссылку на документацию.

**Фактический результат.** Элементы подменю «Курсы» отображаются за границами
выпадающего списка в главном меню после наведения курсора на блок «Курсы».

**Ожидаемый результат.** Элементы подменю «Курсы» находятся в пределах
выпадающего списка в главном меню после наведения курсора на блок «Курсы».

### Серьёзность и приоритет

Серьёзность показывает степень ущерба, который наносится проекту дефектом.

1. Блокирующий (Blocker) — функция не работает.
2. Критический (Critical) — функция работает, но с ограничениями.
3. Значительный (Major) — функция работает, но неправильно.
4. Незначительный (Minor) — функция работает,но неудобно.
5. Тривиальный (Trivial) — грамматические ошибки в пользовательской
документации.

Срочность — высокая (High), средняя (Medium), низкая (Low). Порядок исправления
ошибок по их приоритетам:
1. High – высокий, дефект нуждается в срочном устранении.
2. Medium – средний, дефект нуждается в устранении, но это не срочно.
3. Low – низкая срочность исправления дефекта.

### Правила хорошего баг-репорта

1. Следовать правилу «Что? Где? Когда?».
2. Одна ошибка — один отчёт о дефекте.
3. Краткость — сестра баг-репорта.
4. Писать техническим языком с применением терминологии, принятой на
проекте.
5. Прикреплять дополнительные файлы: логи, скриншоты, видео.
6. Прикреплять ссылки к требованиям, чтобы избежать споров.
7. Избегать дубликатов дефектов — прежде чем сохранить отчёт о дефекте,
надо проверить в баг-трекере, есть ли уже такой дефект.
8. Указывать версию ПО и тестовый стенд (окружение), на котором
обнаружился дефект.
9. Воспроизводить дефект, следуя собственным шагам.

## Багтрекинговая система

Система отслеживания ошибок (от англ. bug tracking system) — прикладная
программа, созданная, чтобы разработчикам ПО (программистам, тестировщикам и
другим) было проще:

  - учитывать и контролировать ошибки и неполадки, найденные в программах,
а также пожелания пользователей;
  - следить за устранением этих ошибок и выполнением или невыполнением
пожеланий.

Багтрекинговые системы используются для создания отчётов о дефектах и для
управления ими. Они также применяются при создании задач для команды
разработки.

## Отчёт о результатах тестирования

Метрики и критерии описываются в плановой документации проекта. В процессе
выполнения или завершения тестирования требуется оценить эффективность
проделанной работы и соответствие метрик, критериев и прочих характеристик
плану. Для этого используются различные виды тестовой отчётности.

**Отчётность** — сбор и распространение информации о результатах работы, включая
текущий статус, оценку прогресса и прогноз развития ситуации.

**Отчёт о результатах тестирования** — документ, обобщающий результаты работ по
тестированию и содержащий информацию, достаточную для соотнесения текущей
ситуации с тест-планом и для принятия необходимых управленческих решений.

Отчёт о результатах тестирования может формироваться каждый день, в конце
каждой итерации, каждую неделю и так далее. При полном завершении
тестирования формируется отчёт о его результатах. Он представляется в разных
видах: в текстовом, табличном и графическом.

### Содержание отчёта о тестировании

**Краткое описание** — вводный раздел, в котором кратко описывается содержание
отчёта, перечисляются основные числовые показатели хода тестирования,
обозначаются главные выводы и даются рекомендации для дальнейшей работы.
Этой части отчёта достаточно для общей оценки ситуации заинтересованными
лицами (менеджерами, руководителями команд).

**Команда тестировщиков** — список участников проектной команды,
задействованных в тестировании, с указанием их должностей и ролей в отчётный
период.

**Описание процесса тестирования** — вся выполненная тестировщиками работа:
количество написанных и пройденных тест-кейсов, число найденных дефектов,
добавленные и протестированные функции.

**Расписание** — календарные сроки, в которые выполнены работы.

**Статус активностей тестирования и прогресс по сравнению с планом
тестирования** — график burndown, на котором видно соотношение
запланированных и проведённых работ

**Факторы, препятствующие прогрессу** — критичные дефекты, недоработанная
функциональность, пробелы в требованиях

**Статистика по новым дефектам** — количество дефектов, обнаруженных за
отчётный период, с указанием степени важности, срочности, места обнаружения и
прочего.

**Список новых дефектов** — список дефектов, обнаруженных в отчётном периоде, с
указанием их основных атрибутов.

**Статистика по всем дефектам** — график, который отражает динамику обнаружения
дефектов на протяжении всего процесса тестирования. В итоговом отчёте по
результатам тестирования указываются все обнаруженные дефекты за весь период
тестирования, распределённые по выбранной классификации, например, по
степени важности, времени обнаружения

**Качество объекта тестирования** — экспертное заключение об уровне качества
продукта.

**Рекомендации** — выводы по результатам тестирования и рекомендации по
повышению его эффективности в будущем.

**Приложения** — графики, таблицы, диаграммы, демонстрирующие числовые
характеристики процесса тестирования.

Отчёт о тестировании представляется в разных видах: в текстовом, табличном и
графическом