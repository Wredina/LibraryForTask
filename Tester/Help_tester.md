# Testing

### ISTQB (International Software Testing Qualifications Board) - некоммерческая организация, которая занимается вопросами развития сферы тестирования ПО. Это международный стандарт в области тестирования ПО.

## Тестирование
Проверка чего угодно с помощью тестов. Т.е. заранее подготовленного списка вопросов, проверок, испытаний и убедиться, что:
- безопасно
- надёжно
- понятно
- доступно
- обладает прочими показателями, совокупность которых определяет качество программы.

### Тестирование ПО
Это проверка соответствия реального и ожидаемого поведения программы, а так же степени удовлетворения потребностей пользователя. Выполняется на конесном наборе тестов, который составляет тестировщик.

### Тестирование
Одна из техник контроля качества. Включает в себя:

- планирование работ
- проектирование тестов
- выполнение тестирования
- анализ полученных результатов

### Общие признаки тестирования:

- продукт, показатели которого неизвестны.
- заранее подготовленный список проверок
- правила проведения исследования - описание процессов, протоколы.
- Ожидаемый результат тестирования
- фактический результат тестирования

ISTQB определяет тестирование как процесс, содержащий в себе все активности жизненного цикла, как динамические, так и статические. Эти активности включают планирование, подготовку и оценку программного продукта и связанных с этим результаты работ.

1. Тестирование - поэтапный процесс. Включает:
 - планирование тестирования
 - анализ требований
 - проектирование и реализация тестов
 - создание отчётов о ходе и результатах тестирования
 - оценка качества объекта тестирования

2. Совокуаность этопов - это жизненный цикл тестирования

3. В тестировнии вылеляются динамические и статические активности
 - динамические предполагают исполнение готового кода - выполнение тестов на работающей версии программного продукта (это может быть запущенное приложение или открытый сайт)
 - статтические не требуют запуска кода на исполнение, это анализ макетов, рецензирование документации и кода

4. цели тестирования
 - определить насколько ПО соответствует заявленным требования
 - выявить дефекты, то есть отелонения ПО от требований

## Качество

**Качество** - это степень того, насколько компонент, система или процесс соответсвует требования и ожиданиям пользователя.

**Качество ПО** - совокупность характеристик, относящихся к его способности удовлетворять установленные и продпологаемые потребности.

Качествро программногопродукта характеризует набор свойств, определяющих, насколько продукт "хорош" с точки зрения заинтересованных сторон: заказчика, спонсора, пользователя, разработчиков, тестировщиков, инденеров поддержики, сотрудников отдеоа маркетинга, обучения и продаж. У каждого участника может быть своё представление о качестве продукта.

### Критерии качества

есть 8 критериев:
1. функциональность
2. эффективность
3. надёжность
4. удобство использования
5. поддерживаемость
6. переносимость
7. безопасность
8. совместимость

### 1. Функциональность

Продукт или система должны выполнять основные функции - то есть решать те задачи, для которых они созданы.

критерии:
- функциональная полнота - насколько функциональность охватывает и решает задачи пользолвателя. 
- функциональная правильность - насколдько продукт или система обеспечивают правильные результаты с требуемой степенью точности.
- Функциональная целесообразность - насколько функции продукта востребованы пользователем. Иногда дополнительные ненудные функции навязываются пользователю.

### 2. Эффективность
Производительность продукта или системы. Например, как быстро обрабатываются запросы пользователей.

Каритерии:

- Поведение в зависимости от времени - насколько ыстро и оптимвально обрабатывается запрос пользователя.
- Использования ресурсов - насколько оптимально ПО расходует ресурсы.
- вместимость - каковы предельные показатель системы, количество пользователей в единицу времени.

### 3. Надёжность

Степень выполнения указанных функций системой, продуктом или компонентом при определённых условиях в течение конкретного периода времени. А также способность быстро востанавливать работу при отказе оборудования.

Критерии:

- Завершённость - степень удовлетворения потребности при нормально работе системы, продукта или компонента.
- Доступность - степень работоспособности и доступности системы, продукта или компонента при использовании
- Отказоустойчивость - насколько стабильно работает ПО при аппаратных или программных сбоях. Например, при отключении электричества или интернета
- Восстанавливаемость - насколько продукт или система могут восстановить данные и желаемое состояние системы при прерывании или сбое

### 4. Удобство использования

Насколько эффективно продукт удовлетворяет потребности конкретного пользователя. Например, пользователю может быть неудобно работать в приложении - непонятно, куда нажимать.

- узнаваемость - насколько пользователи распознают, что умеет делать продукт
- обучаемость - насколько продукт помогает пользователю научиться эффективно в нём работать. Есть ли в нём подсказки, "обучалки" при первом запуске, неизменный основной интерфейс.
- работоспособность - степень, в которой продукт или система имеют атрибуты, облегчающие управление и контроль
защита от ошибок - насколько система защищает пользоваптелей от ошибок: предотвращает деструктивные действия, показывает сообщения при сбоях или при вводе некорректной информации.
- Эстетика пользовательского интерфейса - степень "приятности" взаимодействия пользователя и интерфейса.
- доступность - насколько широки круг людей может пользоваться продуктом. Зависит от совместимости с программным или аппаратным обеспечением.

### 5. Поддерживаемость

Степень адаптируемости приложения к изменениям.  Например, если пользователь подключит дополнительные датчики, увидит ли их система?

Критерии: 

- Модульность - степень, в которой система состоит из отдельных компонентов. Изменение одного оказывает минимальное влияния на другие.
- Повторное использование - степень, в которой компонент системы изпользуется более чем в одной системе или при создании других компонентов
- Пригодность к анализу - степень эффективности и рещультативности, с которой оценивается влияние на продукт или систему предпологаемого изменения одной или нескольких его частей. Продукт диагностируется на наличие недостатков или причин отказов. Определяются детали, подлежащие модификации.
- Модифицируемость - степень, в которой продукт или система могут эффективно модифицироваться бещ внесения дефектов или ухудшения качества продукта.
- тестируемость - степень эффективности и результативности, с которой станавливаются критерии тестирования для системы, продукта или компонента, а так же выполняются тесты.

### 6. Переносимость

Степень эффективности и результативности, с которой система, продукт или компонент переносятся из одного аппаратного, программного, оперционнного или эксплуатационного окружения в другое. 

Критерии:
- Адаптивность - степень, в которой продукт или система эффективно адаптируются
к разным или развивающимся аппаратным средствам, программному обеспечению или другим операционным средствам, а так же к средам использования.
- простота и лёгкость установки - степень эффективности и продуктивности, с которой продукт или система успешно устанавливаются и (или) удаляются в конкретной среде.
- Заменяемость - степень, в которой продукт может заменить другой указанный программный продукт для идентичной цели и среды.

### 7. Безопасность

Степень, в которой продукт или система защищают информацию и двнные таким образом, что бы лица или другие системы имели степень достиупа к ним, соответствующую из импам и уровням авторизации. Например, что бы злоумышленник не смог перехватить запрост от вашего приложения.

Критерии:
- Конфиденциальность - степень, в которой продукт или система гарантируют, что данные получают только те, кому разрешён доступ к ним.
- Целостность - степень, в которой система, продукт или компонент предотвращают несанкционированный доступ или модификацию компьютерныз программ (данных)
- Невозможность отказаться - степень, в которой действия или события могут быть доказаны без возможности их скрыть или совершить подмену.
- Ответственность - степень, в которой действия объекта однозначно прослеживаются, а так же определяются ответственные лица.
- Подлинность - степень, в которой личность субъекта или ресурса доказываются как заявленная.

### 8. Совместимость
Степень, в которой продукт, система или компонент обмениваются иныормацией с другими продуктами, системами или компонентами и выполняют требуемые функции, совместно используя ту же аппаратную или программную среду.

- Сосуществование - степень, в которой продукт эффективно выполняет требуемые функции при совместном использовании общей срелы и ресурсов с лругими продуктами без вредного воздействия на любой другой продукт. 
- Совместимость - степень, в которой системы, продукты или компоненты обмениваются информацией и используют её.

## Цели тестирования и роль тестировщика
### Тестировать ПО нужно:
1. Процесс тестирования гарантирует, что ПО будет работать в соответствии с оджиданиями клиентов на имеющимся у них оборудовании
2. Выявление проблем на начальном этапе разработки уменьшает объём работ по исправению ошибок на более поздних стадиях, обеспечивает правильное использование ресурсов и предотвращает повышение стоимости
3. Команда тестирования привносит взгляд клиента в роцесс и находит варианты использования, о которых разработчик может не подумать.

Любой сбой, дефект или ошибка, обнаруженная клиентом в готовом продукте, рушат доверие к компании и увеличивают финансовые затраты.

### Цели тестирования ПО
1. Оценка соответствия стандартам компании рабочих продуктов: требования, пользоватедльских историй, проектирования и кода.
2. Проверка выполнения требований.
3. Поиск и предотвращение дефектов.

Такая постановка целей даёт возможность:

1. Повыситьь вероятность, что прилодение, предназначенное для тестирования, будет работать правильно.
2. Повысить вероятность, что приложение, предназначенное для тестирования, букдет соответствовать всем описанным ттребования.
3. Предоставить актуальную информацию о состоянии продукта в конкретный момент.

### Обязанности инженера QA

1. Изучение и уточнение требований к ПО у заказчика (в больших проектаз этим могут заниматься бизнес-аналитики)
2. Написание и доработка сценариев тестирования
3. Тестирование функционала ПО
4. Составление отчётов по обнаруженным недочётам в трекинговой системе - программе, в которую разработчики, программисты и тестировщики могут вностить найденные ошибки и отслеживать их выполнение/невыполнение.
5. Анализ результатов и показателей проведённых тестов.
6. Составление ТЗ на устранение найденных недочётов
7. Мониторинг и отслеживание правок.
8. Проведение повторных тестов, что бы убедиться, что найденные ошибки исправлены.
9. Анализ и оптимизация этапов разработки для устранения причин ошибок и защиты от их повторного появления.
10. Работа с тестовой документацией.

## Принципы тестирования
### 1. Тестирование демонстрирует наличие дефектов
Тестирование показывает, что дефекты есть, но не может доказать, что их нет.

Тестирование снижает вероятность, что в ПО есть дефекты, но, даже если дефекты не обнаружены, не доказывает его полную корректность

### 2. Исчерпывающее тестирование недостижимо
Полное тестирование с использованием всез комбинаций вводов и предусловий физически невыполнимо, кроме тривиальных случаев. Вместо исчерпывающего тестирования используется анализ рисков и расстановка приоритетов, что бы точнее сфокусироваьб усилия по тестированию.

### 3. Раннее тестирование
Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия должны концентрироваться на конкретныз целях. Такой подход поможет раньше найти дефекты.

### 4. Скопление дефектов
Как правило, большинство дефектов обнаруживают в небольшом количестве иожулей. Усилия по тестированию сосредотачиваю пропорционально ожидаемой, а затем и реальной плотности дефектов в модулях.

### 5. Парадокс пестицида
Если одни и те же тесты выполняются много раз, в конечном счёте этот набор тестовых сцунарие больше не будет находить новые дефекты.

Что бы преодолеть парадокс пестицида, тестовые сценарии нужно регулярно рецензировать и корректировать. При этом новые тесты должны быть разносторонними, что бы охватить все компоненты ПО или системы, и найти как можно больше дефектов.

### 6. Тестирование зависит от контекста
Тестирование выполняется по разному в зависимости от контекста. Например, программное обеспечение, где критически важна безопастность, тестироется иначе, чем сайт электронной коммерции.

### 7. Заблуждение об отсутствии ошибок
Обнаружение и исправление дефектов не помогут, если созданная система не подходит пользователь и не удовлетворяет его ожиданиям и потребностям.

## Тестовая среда и тестовые данные
**Тестовая среда** - полигон для испытаний: например, сервер, мобильный телефон и так далее. Настраивается в соответствии с требования тестируемого приложения.

Всё, чем пользуются люди, проходит испытания. Если сделать прибор и сразу продавать его, он может оказаться небезопасным. Поэтому его нужно проверить на полигоне с условиями, максимально приближенным к реальным.

**Окружение** - это среда, место или машина, на которой находится приложение/сайт.

На проекте можно встретить немколько видов таких сред:
- Локальное окружение - всего одна машина, на которой разрабоатывают и тестируют приложение. Тестировщик или разработчик может развернуть её у себя на ноутбуке. Грубо говоря, это виртуалка с копией проекта. Часто у неё огранниченный функционал: например, нет реальных товаров или возможности из оплатить.

- Тестовая - среда тестирования функциональности. Она наполнена тестовыми данными, которые могут показывать случаи, редко возникающие в рабочей среде или удобные для тестирования. Здесь идёт тестирование того, что готовится в продакшен.

- Stage или staging - окружение - среда, в точности походая на продакшн-окружение. Может подключаться к другим продакшен - сервисам и данным, таким как базы данных.

- Боевое оружие - реальная сеть машин, совокупность нескольких окрудений. Не тестовое, а самое настоящее окружение, где работают пользователи. Тестирование в такой среде практически не проводится.

**Тестовые данные** - это набор входных значений, нужных для выполнения тестов. Тестировщики определяют данные в соответствии с требованиями. Для генерации тестовыз данных используют различные инструменты.

**Инструменты генерации** - это программы, которые быстро создают тестовые данные. Их целесообразно использовать в случаях, когда:
- нужно много однотипных данных
- речная генерация тестовых данных занимает много времени (в случает тестирования сложных систем)
- данные нужны для автотестов(код, который пишут тестировщики для покрытия ручных проверок)

**Инструменты генерации**
- таблицы Excel
- онлайн утилиты, например Pairwise Pict Online для генерации попарных данных
- скрипты для выполнения в командной строке
- сложные программы, созданные самими тестировщиками

## Testing, QC, QA
**QC**(Quality Control) - контроль качества: анализ результатов тестирования и качества новых версий выпускаемого продукта.

Задачи:
 - проверка готовности ПО к релизу
 - проверка соответсвия требований и качества проекта

**QA**(Quality Assurance) - обеспечение качества продукта: изучение возможностей изменения и улучшения процесса разработки и куммуникаций в команде.

Тестирование - один из аспектов обеспечения качества.

Задачи:

- Проверка тезнических характеристик и требований к ПО
- оценка рисков
- планирование задач для улучшения качества продукции
- подготовака документации, тестового окружения и данных
- тестирование
- анализ результатов тестирования, а так же составление отчётов и других документов

Тестирование - процесс проверки результатов работы на соответствие установленным требования. Тестировщик - специалист, который занимается такой проверкой: тестирует компоненты продукта или весь продукт целиком на предмет ошибок или неточностей разработки

Тестирование - один из ключевыз процессов в системе обеспечения качества.

## Hard Skills & Soft Skills
**Hard skills** - технические компетенции, которые можно наглядно продемонстрировать, оуенить и проверить. К ним относятся навыки работы с инструментами, знание языков программирования, SQL, системы контроля версий GIT, основ тестирования, техники тест-дизайна, а так же понимание жизненного цикла тестирования, компьюитерная грамотность и многое другое.

**Soft skills** - универсальные социально-психологические качества, которые не зависят от профессии, но непосредственно влияют на успешность человека. К ним относятся коммуникативные навыки, организованность, способность решать конфликты, умение убеждать, работать в команде, адаптивность, обучаемость. Они могут зависеть от характера человека и формироваться с опытом.

В последние годы на Soft skills обращают всё больше внимания. Иногда они оказываются решающими.

____

<br>

# Чек-Листы
Чек-лист - список, содержащий ряд проверок во время тестирования программного продукта.


## Составление чек-листов
Чек-листы составляют на основе технического задания (ТЗ) - одного или нескольких документов, определяющих цель, структуру, свойства и методы проекта.

Так же и тестировщик после знакомства с ТЗ составляет чек-лист, то есть список проверок программного обеспесения. Затем команда или один тестировщик проводят проверки и отмечают исполненные (пройденные) пункты чек-листа.

### Последовательность действий
Сперва тестировщик знакомится с требованиями и только потом составляет по этим требованиям чек-лист.

Если нужно, требования делят на атомные части, то есть декомпозируют, разбивают на небольшие составляющие. Это нужно, что бы с ними было удобнее работать.

Последовательность действий при составлении чек-листа:

1. Определить все возможнве проверки
2. Сгруппировать проверки в разделы
3. Определить тестовые данные, если они необходимы
4. Подумать, какие колонки будут в чек-листе

Затем состовляется сам чек-лист

### Правила составления

1. Один пункт - одна операция

Пункты чек-листа - это однозначные атомарные (выполняющие одно действие) и полные (логически завершённые) операции. Например, авторизация в профиль пользователя и редактирование данных пользователя - две разные задачи. В списке проверок их оформляют отдельными пунктами.

2. Пункты всегда начинаются с существительного или глагола неоплределённой формы.

При составлении пунктов важно придерживаться унифицированных форм: начинать их с существительного ("проверка", "добавление", "отправка") или неопределённой формы глагола ("проверить", "добавить", "отправить"). Так пункты будут однозначными и понятными.

3. Соблюдайте структуру.

Что бы выполнять чек-лист было удобно, лучше составлять тесты так, что бы они исходили из логики пользования функционала. Например:
- в рамках раздела "регистрация и личный профиль" - регистрация на сайте, редактирования профиля
- в рамках раздела "форма обратной связи" - валидация полей, отправка письма, доставка письма

4. Ничего не придумывайте

Чек-лист важно составлять, опираясь на требования. Не придумывайте то, чего нет в требовании.

5. Общепринятые названия

Хорошо, когда в команде все разговаривают на одном языке, используют общую терминологию

Если один тестировщик в команде называет линию, разделяющую элементы на странице, дивайдером, а остальные - сепаратором, может возникнуть недопонимание.

### Оформление чек-листов
Разбор на проекте:

Есть экран товара пользователя. Пользователь может перейти на карточку своего товара из профиля. На карточке есть слайдер, кнопки продвижения (поднятия товара в выдече), шеринга товара (возможность подельться в соц.сетях), а так же цена, название и описание товара.

Лично опредеоить, в каком модуле будет находиться карточка товара, затем определить название модуля - карточка товара. После идукт сами проверки.

**Важно!** Напротив каждой из проверок есть статусы. Тестировщик ставит их только после выполнения каждого из пунктов чек-листа.

### Варианты колонок в чек-листе
В зависимости от того, что принято на проекте и как удобнее команде, есть несколько видов оформления чек-листов.

#### простейший

В чек-листе две колонки: действие и результат - пройдено (passed) или не пройдено (failed). Исполнитель самостоятельно подбирает тестовые данные. Их необязательно фиксировать в чек-листе. Преимущества - быстрое составление.

#### простейший с комментарием

Похож на простейший, но с дополнительной колонкой для комментария. В ней указываются примечания, ссылки на созданные дефекты и прочая полезная информация.

#### С тестовыми данными

Кроме действия и результата в чек-листе указано, на каких тестовых данных бедт проводиться тестирование.

#### Проверки с детализацией по тестовым данным

Тестовые данные, на которых тестировщик выполняет проверку, могут указываться в столбце "действие"

#### Проверка с детализацией по версиям

В чек-листе хранится история прохождения для разных версий ПО. Это полезно для отслеживания: в одних местах чаще возникают ошибки, а в других всё относительно стабильно.

#### Проверка с детализацие по окружениям

Задача тестирования - проверять работу ПО в разных условиях, то есть с разными окружениями. Веб-приложения должны работать без ошибок во всех браузераз, а мобильные - на всех устройствах и разных операционных системах.

### Виды чек-листов

#### Специальные и универсальные

**Специальные** чек-листы создают и использую для конкретных проектов. Их пункты соответствуют его специфике. По специальному чек-листу тестировщик проверяет возможность выполнить уникальное действие, предусмотренное требованиями.

**Универсальные** чек-листы подходят для тестирования проектов одного типа.

Проверка по универсальному чек-листу не привязывается к графическим элементам или конкретной реальзации. Проверяется сама возможность выполнить действие.

Для универсального чек-листа составляется абстрактный список проверок.

Пример:
- Переход в профиль пользователя
- Отображается аватарка пользователя
- Отображается имя пользователя

#### Связанные и несвязанные чек-листы

Пункты чек-листа могут быть в разной степени связаны друг с другом. В зависимости от этого выделяются три типа чек-листов:

- Подробный перечень
- Связанный чек-лист
- Несвязанный чек-лист

**Подробный перечень** (Laundry list) - упрощает понимание и восприятие информации. Элементы списка группируются по критериям, порядрок не влияет на точность данных.

По сути, главная ценность подробного списка - верно подобранные категории, по которым происходит группировка. Его можно сравнить с сортировкой белья разных цветов при стирке. Альтернативный перевод Laundry list - список белья, отданный в стирку.

Пример:
1. Вёрстка
- вёрска не "едет" во всех утверждённых ТЗ браузерах.
- Работают динамические элементы, нет явных ошибок отображения.
- нет горизонтального скролла
- Прочее

2. Содержимое
- нет орфографических и грамматических ошибок
- Удалены тексты заглушки
- Навсез страницах есть контент
- Есть политика конфеденциальности и подтверждения согласия на обработку персональных данных от пользователей при сборе любых данных
- прочее

3. Функциональность
- Нет битых ссылок
- все страницы сайта доступны из главной навигации
- ссылка на открытую страницу подсвечивается в меню
- прочее

4. Безопасность и быстродействие
- нет визуальных проблем с быстродействием
- установлены последние версии используемы библиотек
- Настроено резервное копирование
- у посторонних пользователей нет доступа к закрытым файлам
- прочее

Для проверки сайта не важно, будет ли сначала проверяться вёрстка, а потом содержимое, или наоборот. Важнее сгруппировать проверки таким образом, чтобы:
- одну группу проверок выполнял один человек
- была возможность распараллелить проверки (взять разные проверки разным тестировщиками), что бы повысить скорость работы.

**в связанном чек-листе** ( strongly sequential checklist) - последовательность влияет на результат. Ключевой этап работы над созданием связанного чек-листа - корректное размещение информации

Пример - предполётная контрольная таблица, которую использует персонал авиакомпаний. Её задача - определить, можно ли эксплуатировать конкретный самолёт. В ней важна строгая последовательность характеристик для адекватной оценки машины.

Пример связанного чек-листа для проверки поведения окна программы.

1. новое окно открывается при двойном клике на ярлык.
2. окно сворачивается в панель задач при нажатии кнопки "свернуть"
3. окно разворачивается из панель задач при нажатии на ярлык панели задач
4. окно закрывается при нажатии кнопки "закрыть"

Пункты 2 и 3 нельзя поменять местами. Нельзя развернуть открытое окно, а на свёрнутом окне не будет кнопки "закрыть"

**в несвязанном чек-листе** (weakly sequebtial checklist) - последовательность размещения данных играет скорее психологическую роль, нежели логическую.

Несвязанный чек-лист - среднее между пробным перечнем и связынным чек-листом. Связать между элементами есть, но изменение порядка не повлияет на результат проверки.

Пример несвязанного чек-листа для тестирования социальной сети:

1. пользователь может создать публикацию
2. пользователь видит публикации открытых аккаунтов, независимо от нгаличия подписки.
3. пользователь видит публикации закрытых аккаунтов, на которые он подписан
4. пользователь не видит публикации закрытых аккаунтов, на которые он не подписан
5. пользователь может удалить публикацию.

Эти действия тестируются в любом порядке независимо друг от друга. Но психологически комфортнее идти именно в таком порядке.


### Правила выполнения чек-листа

1. Не пропускать проверки чек-листа. Если какие-то пункты нельзя проверить тз-за багов или недоступности среды, надо отметить их и вернуться к ним позже.
2. Если указываются тестовые данные, нужно использовать именно их.
3. Указывать результат и комментарий.

### Резолюция

Когда исследуемый объект протестирован, нужно выставить кейсу резолюцию, то есть вердикт - прошл он проверку или нет.

Распространённые статусы:
- passed - успешно пройден
- failed - кейс не прошёл проверку
- skipped - пропуск проверки
- blocked - проверка заблокирована
- untested - кейс ещё не брали в работу

passed - ставится, когда исследуемый объект проходит проверку в соответствии с ТЗ.

failed - исследуемый объект не соответствует ТЗ. Например, функционал поломан, не работает или его нет

skipped - пропуск проверки кейса. Наример, из-за  нехватки времени или если в кейсе есть неточности: он устарел, из документации вы понимаете, что его уже изменили в проекте

blocked - проверка заблокирована поломанным функционалом, от которого прямо или косвенно зависит тестируемый. Например, есть функционал "авторизация пользователя" и функционал "редактирование данных пользователя". Разработчик допустил ошибку в коде и функционал авторизации поломан - ему мы выносим резолюцию failed. Проверить редактирование данных пользователя не можем - выставляем статус blocked/ В комментарии указываем, почему не можем протестировать этот функционал

## Преимущества и недостатки чек-листа
Плюсы:

- Чек-листы затрагивают большее кольчество кейсов, так как при прохождении их можно по - разному выполнять.
- Сокращают затраты на содержание и поддержку тестов.
- Обеспечтвают высокую скорость тестирования: не нужно отмечать результат каждого шага тестировщика, достаточно общего результата проверки.
- Позволяют проходить и комбинировать тесты по-разному, в зависимости от предпостений сотрудников. Показывают статистику: кто, когда и что проходил - с детализацией по сборке продукта и окружению, на котором проводилось тестирование.
- Улучшают представление о системе в целом, показывают статус её готовности.
- показывают объём проделанной работы по тестированию

Минусы: 
- Начинающие тестировщики не всегда эффективно проводят тесты без достаточно подробной документации.
- чек-листы не возможно использовать для обучения начинающих сотрудников, так как в них недостаточно подробных сведений.
- руководителю или заказчику может быть недостаточно того уровня детализации, который предлагают чек-листы.
- неопределённость тестового набора: каждый тестировщик выполняет пункт чек-листа по-своему.

### Распространённые ошибки
1. Не атомарные проверки:
- не верно:

  1. авторизовался в профиле пользователя и изменил имя пользователя
  2. редактирование номера телефона

  <br>

- верно:

  1. авторизация по номеру телефона
  2. переход в профиль пользователя
  3. редактирование имени пользователя
  4. редактирование номера телефона пользователя
  5. редактирование почты пользователя.

  <br>

2. Не корректная форма глагола
- не верно:

  1. авторизовался в профиле пользователя
  2. отредактировал номер телефона

  <br>

- верно:

  1. авторизация по номеру телефона
  2. редактирование номера телефона

  <br>

3. Нет разделителя по модулям

- не верно:

  1. авторизация по номеру телефона
  2. редактирование номера телефона
  3. редактирование имени пользователя

  <br>

- верно:

  1. Авторизация
      - авторизация по номеру телефона
  2. Профиль пользователя
      - редактирование номера телефона
      - редактирование имени пользователя


## Программы для составления и хранения чек-листов

### Google - таблицы
Чек-листы наглядные, действия и результаты распределены
по ячейкам.

Минусы:
- Google-таблицы могут быть запрещены политикой безопасности;
- Документы Excel неудобно модифицировать.

  <br>

### TMS - системы — Test Management System

Чек-листы можно составлять в таблицах Excel — на некоторых проектах так и делают. Но общепринято использовать специальные инструменты — Test Management System (TMS) или системы управления тестированием.

Популярные системы управления тестированием:
- Test Link
- Test IT
- Zephyr
- qTest
- PractiTest
- TestLodge
- TestRail
- Qase.io
- Tematoo
- Test Collab
- HP ALM
- Testuff
- XQual

плюсы:
- удобное оформление тестовой
документации
- структурированное отображение
- удобное выполнение кейсов
- наглядный отчёт после
прохождения

минусы:
- дополнительный инструмент в
команде, который может
требовать настройки
- большинство TMS — платные

### RMS - системы - Requirements Management Systems

это средства поддержки и
автоматизации работы с требованиями на протяжении всего жизненного цикла
разработки программного продукта. В них тоже можно составлять и хранить
чек-листы, но это не очень удобно и затратно по времени
___

<br>

# Тест - кейсы

Тестовый случай (тест-кейс) — это совокупность шагов, конкретных условий и
параметров, нужных для проверки работы тестируемой функции или её части.

тест-кейс — это небольшая инструкция по проверке работы функции.

В нём описывается:
- какие шаги нужно выполнить (например, какие кнопки нажать, чекбоксы
активировать, данные внести), чтобы проверить работу участка системы;
- какой результат должен быть у каждого шага.

В тест-кейсе есть подробная детализация для каждой из проверок, а в чек-листе —
нет.

## Атрибуты тест-кейса
У тест-кейса есть обязательные атрибуты (необходимые поля). Большая часть
заполняется на этапе проектирования тест-кейса, несколько — после прохождения
теста.

### Атрибуты на этапе проектирования тест-кейсов

1. **ID тест-кейса** — уникальный идентификатор, присваивается автоматически.
2. **Название** — краткое описание сценария, который проверяет тест-кейс.
3. **Шаги** — последовательность действий, чтобы проверить работу функции или
выполнение сценария.
4. **Ожидаемый результат** — как должна вести себя система после каждого шага
тест-кейса, то есть то поведение, которое мы ожидаем получить после
выполнения конкретного действия или последовательности действий.
5. **Приоритет тест-кейса** зависит от приоритета функций и сценариев, которые он
проверяет. Определяет очерёдность выполнения теста во время тестирования.
Например, при высоком приоритете тест-кейс будет в начале очереди на
выполнение, а при низком — в конце. Если во втором случае что-то сломано, для
нас это не так критично, как в первом.
6. **Тестовые данные** — данные, которые используются для проверки. Могут
указываться в шагах тест-кейса или в отдельном файле с указанием ссылки на
них. Это, например, данные для авторизации пользователя или данные тестовой
карты для оплаты заказа.
7. **Предусловия** — действия, которые нужно выполнить, прежде чем приступать к
тест-кейсу, а также настройки приложения и тестовой среды.

    Например, если мы проверяем отправку сообщения в чате с другом в
    социальной сети, мы точно знаем, что пользователь должен быть авторизован.
    Но сама авторизация как набор действий с вводом логина/пароля не имеет
    отношения к отправке сообщения другу. Таким образом, правильно будет
    указать в предусловии этого кейса, что пользователь должен быть авторизован,
    а страница чата — открыта. В самих шагах мы будем описывать действия,
    имеющие непосредственное отношение к отправке сообщения другу.
8. **Постусловия** — выполнение тест-кейса, как правило, переводит систему из
одного состояния в другое: меняются настройки, производятся расчёты.
Состояние, в которое нужно привести систему после прохождения тест-кейса,
указывается в постусловии.
 
    Допустим, мы проводили тестирование кейса с редактированием данных
пользователя на боевом сервере (на окружении, которым пользуются обычные пользователи) и в процессе тестирования изменили часть данных на
ненастоящие: вместо имени указали странную последовательность букв, в
описании интересов написали несвязный текст, вместо фотографии человека
прикрепили небо.
Но, так как мы тестируем на продакшене, наш тестовый профиль может попасть
в выдачу обычным пользователям, и это будет выглядеть странно. Чтобы этого
избежать, мы можем в постусловиях указать, что все изменённые значения надо
вернуть в исходное состояние и указать, какие данные надо ввести в каждое
поле.

### Атрибуты на этапе исполнения тест-кейсов

1. **Фактический результат** — то, что мы получаем после выполнения всего
тест-кейса или его конкретного шага. Это необязательный атрибут, его можно не
указывать. Но если он указывается, в нём может быть как краткое описание
того, что мы получили по факту прохождения шага / шагов, так и статус для
каждого фактического результата.

    Если фактический результат совпадает с ожидаемым, в графе с фактическим
    ставится статус passed — тест-кейс успешно пройден, ошибок не обнаружено.
    Если результат отличается от ожидаемого — статус failed — проверка провалена,
    полученный результат не соответствует ожидаемому. Во втором случае
    тестировщик создаёт отчёт о дефекте. К тест-кейсу
    обязательно добавляется ссылка на дефект, обнаруженный при исполнении.

2. **Статус тест-кейса**

- passed — успешно пройден
- failed — кейс не прошел проверку
- skipped — пропуск проверки
- blocked — проверка заблокирована
- untested — кейс еще не брали в работу


## Составление тест-кейсов
Как писать тест-кейсы по требованиям - зависит от того, в каком виде они будут представлены — в виде текста разной
степени детализации, в виде схем, майнд-карт или use case (пользовательских
сценариев).

Вне зависимости от вида требований можно выделить общий алгоритм:

1. Продумайте, какие именно сценарии и функции нужно покрыть тест-кейсами.
Для этого определите, какие новые возможности и сценарии появятся за счёт
новой фичи, с какими функциями из существующих связана новая фича.
2. Сформулируйте названия для тест-кейсов.
3. Определите для каждого сценария нужные предусловия: например,
пользователь или другой объект системы должен быть в определённом
состоянии.
4. Опишите шаги, по которым будете проверять сценарий, в соответствии с
требованиями. Всегда внимательно следите, чтобы не было пропусков.
5. Опишите ожидаемый результат в соответствии с требованиями.
6. Заполните остальные атрибуты этапа, если нужно.

Тест-кейс готов. Ничего сложного, если знать правила составления и работы.

## Правила работы с тест-кейсами
1. Один тест-кейс — одна проверка или один сценарий.

2. Заголовок точно описывает суть тест-кейса. По нему можно определить
характер проверок, не открывая шаги теста: то есть что конкретно
проверяется в функциональности. Если мы говорим про кейс с отправкой сообщения, заголовок может быть следующим: «Отправка сообщения другу
из раздела “Чаты”»

3. Названия для элементов приложения (кнопок, чекбоксов, элементов меню)
точные. Тест-кейсы используют разные люди, всем должно быть понятно их
содержание. Не общепринятые названия элементов допускаются только в тех
случаях, когда они понятны для всей команды.

4. Простой технический стиль без объяснений базовых понятий работы ПО.
Подробности описываются в требованиях или спецификации. Тест-кейс не
должен быть сочинением, иначе его будет трудно и долго читать.

5. Нет пропущенных шагов: каждое следующее действие вытекает из
предыдущего. Например, в кейсе на проверку подписки на пользователя
сразу после шага «Запустить приложение» не должно быть шага
«Подписаться на пользователя», ведь нужно ещё перейти на страницу
пользователя, на которого будем подписываться.

    Простой способ проверить, нет ли пропуска — пройти тест-кейс строго по
описанным шагам, ничего не додумывая.

6. Нет описания очевидных действий (например, разблокировки девайса).
Лучше начинать с ненулевого состояния и определённого экрана. О них
сообщить в предусловии.

7. Нет зависимостей от других тест-кейсов. Часто для выполнения тест-кейса
нужно попасть в определённое состояние пользователя. В таких случаях
высок соблазн в предусловии сослаться на тест-кейс, в котором мы как раз
попадаем в нужное состояние. Но это неправильно: спустя время тест-кейс,
на который мы ссылаемся, может быть удален или изменён. Поэтому чётко
описываем в предусловии, что должно быть сделано до выполнения
тест-кейса, в шагах чётко прописываем все действия, даже если они частично
дублируют действия из другого тест-кейса

8. Каждый тест-кейс уникален и не дублирует другой.

9. Обнаруженная ошибка становится очевидной. Шаги тест-кейса и ожидаемые
результаты описываются таким образом, чтобы отклонение от них явно
свидетельствовало о дефекте.

10. Гибкость для модификации. В тест-кейсе легко добавить, изменить или
убрать шаг, в том числе в середине теста, а также изменить тестовые данные.

## Ошибки в тест - кейсах

1. Заголовка нет или он сформулирован некорректно. Например, из заголовка
«Кнопка “Сохранить”» или «Чат с поддержкой» непонятно, что мы проверяем
в кейсе. То, что они есть, или их функциональность?

2. Ссылки ведут на разные или недействительные требования. В тест-кейсах
можно ссылаться на требования, но если мы используем несколько ссылок,
стоит убедиться, что их содержимое актуально и не противоречит друг другу.

3. Используются личные формы глаголов: «нажми», «перейдите», «укажи». В
тест-кейсах, как и в чек-листах, следует использовать обезличенные формы
глаголов: «нажать», «перейти», «указать».

4. Пунктуационные, орфографические, синтаксические ошибки. Текст с
ошибками и опечатками читать сложнее, чем текст, не нарушающий правила
языка.

5. «Выдумывание» особенностей поведения приложения без отсылки к
требованиям. Тест-кейс должен описывать сценарий и ожидаемые
результаты чётко в соответствии с требованиями. Тестировщик ничего не
выдумывает.

6. Нет описания приготовления к выполнению тест-кейса, если требуются
предусловия. Например, для проверки фишек верифицированного
пользователя в соцсети нам нужен такой верифицированный пользователь.
При тестировании у нас есть возможность создать его через админку (не так,
как это происходит у обычного пользователя). Нам подойдёт этот вариант, так
как мы проверяем не верификацию, а функцию, доступную такому
пользователю.

    Соответственно, верификация пользователя — наше предусловие. В нём
обязательно нужно либо сказать, что надо верифицировать пользователя по
такой-то ссылке, либо дать конкретные данные для авторизации
пользователем

## Примеры тест-кейсов
Тест-кейсы составляются исходя из требования. Поэтому сперва внимательно
ознакомимся с требованием, а потом уже составим тест-кейсы.

Представим, что есть форма регистрации. Заголовок формы — «Начни бесплатно».
Шрифт — Sans Serif, размер текста — 40px. Есть три поля:

1. **«Имя и фамилия»**. Принимает на вход русский и английский текст. Когда
пользователь начинает заполнять поле, плейсхолдер (текст-подсказка)
скрывается.
2. **«Email»**. Принимает на вход адрес электронной почты в формате
email@mail.ru. Когда пользователь начинает заполнять поле, плейсхолдер
скрывается.
3. **«Номер телефона»**. Пользователь может выбрать страну и ввести свой
номер телефона. При вводе номера автоматически добавится код выбранной
страны. Вводимый номер будет разделяться пробелами.

Для отправки формы есть кнопка «Начать». Она становится активной (на неё можно
нажать), если заполнены все поля.

Есть два чекбокса:
- «Я подтверждаю согласие на обработку персональных данных в соответствии
с условиями Политики конфиденциальности, ознакомился и согласен с
условиями Пользовательского соглашения»;
- «Я согласен получать уведомления о новых продуктах и предложениях
GeekBrains и его партнеров»

При определённых условиях отображаются ошибки:
- если поле «Имя и фамилия» не заполнено — «Заполните поле Имя и
фамилия»;
- если поле «Email» не заполнено — «Заполните поле Email»;
- Если поле «Номер телефона» не заполнено — «Заполните поле Номер
телефона».

Размер текста ошибки — 12px, шрифт — Sans Serif, цвет — #f2363b.

___

Первый тест-кейс будет проверять наличие заголовка формы «Начни бесплатно»

> **ID**: 1
>
>**Название**: отображение заголовка формы регистрации
>
>**Предусловие**: открыта форма регистрации
>
>**Шаг 1**: проверить отображение и наличие заголовка формы
>
>**Ожидаемый результат 1**: заголовок формы «Начни бесплатно» отображается.
Шрифт — Sans Serif, размер текста — 40px.

<br>

Теперь составим второй тест-кейс. Проверим заполнение и отображение поля «Имя
и фамилия». Будет два разных тест-кейса. Начнём с отображения:

>**ID**: 2
>
>**Название**: отображение поля «Имя и фамилия»
>
>**Предусловие**: открыта форма регистрации
>
>**Шаг 1**: проверить наличие поля «Имя и фамилия»
>
>**Ожидаемый результат 1**: поле «Имя и фамилия» отображается в соответствии с
макетом
>
>**Шаг 2**: проверить наличие плейсхолдера в поле «Имя и фамилия»
>
>**Ожидаемый результат 2**: плейсхолдер «Имя и фамилия» отображается в поле,
размер шрифта — 14px

<br>

Далее проверим заполнение поля:

>ID: 3
>
>Название: заполнение поля «Имя и фамилия»
>
>Предусловие: открыта форма регистрации
>
>Шаг 1: клик в поле «Имя и фамилия»
>
>Ожидаемый результат 1: в поле отображается курсор
>
>Шаг 2: ввести в поле Иван Иванов
>
>Ожидаемый результат 2: плейсхолдер скрывается, введённый текст
отображается

<br>

А если пользователь заполнил поле невалидными данными или оставил поле
пустым?

>ID: 4
>
>Название: отображение ошибки «Заполните поле Имя и фамилия»
>
>Предусловие: открыта форма регистрации
>
>Шаг 1: клик на кнопку «Начать»
>
>Ожидаемый результат 1: отображение ошибка «Заполните поле Имя и фамилия».
Размер текста — 12px, шрифт — Sans Serif, цвет — #f2363b
___

## Преимущества и недостатки тест-кейсов

Преимущества:
- За счёт полной детализации шагов тест-кейсы может проходить новичок. По
ним удобно знакомиться с продуктом.
- Достаточно подробное описание бизнес-логики. При неидеальной
организации хранения требований уточнение некоторых моментов проще
будет найти в тест-кейсах.

Недостатки:
- Нужно больше времени на написание, чем для чек-листов.
- Сложно поддерживать. Если изменится бизнес-логика, будут переименованы
разделы или произойдут другие изменения, затрагивающие
пользовательский интерфейс и сценарии использования системы, нужно
будет актуализировать все тест-кейсы, связанные с измененной частью.

## Инструменты для работы с тест-кейсами

Тест-кейсы нужно структурировать, хранить и поддерживать. У тестировщиков
должна быть возможность работать с ними совместно.

Системы для работы с тест-кейсами (test-case management system, TMS) —
автоматизированные приложения, которые позволяют управлять тест-кейсами. К
ним относятся:

- Jira + Zephyr,
- TestRail,
- Allure,
- Test IT,
- TestLink,
- Прочие.

Основные функции инструментов:
1. Создание тест-кейсов — приложения содержат специальные формы и
шаблоны, которые ускоряют процесс разработки тест-кейсов.
2. Выполнение тест-кейсов и запись результатов — тест-кейсы запускаются с
использованием приложения, и результат их исполнения записывается в
систему.
3. Отслеживание дефектов — возможность прикреплять ссылку на дефект,
который обнаружен тест-кейсом. Это позволяет эффективнее отслеживать
исправление дефектов.
4. Отслеживание требований и других проектных документов — в
приложениях можно прикреплять ссылки на требования, по которым
разрабатывается тест-кейс, и отслеживать полноту покрытия требований
тест-кейсами
5. Защита тест-кейсов — тест-кейсы создают для многократного
использования, поэтому их важно защитить от несанкционированных
изменений и удалений. Все действия тестировщиков с тест-кейсами
отслеживаются и сохраняются в истории версий.

## Наборы тест-кейсов

Test case — атомарный элемент тест-плана. Тест-план включает в себя следующие
компоненты:

- **Test suite** — список кейсов, объединённых общим фактором: весь продукт,
конкретная фича и так далее.
- **Test plan** — список тест-сьютов, выбранных для теста.
- **Test run** — проход («прогон») тест-сьютов, выбранных для тестирования в
соответствии с тест-планом.


# Тест-кейс и чек-лист
И тест-кейс, и чек-лист — это упорядоченная последовательность проверок работы
программы. Они представляют собой документацию к продукту и содержат
информацию о его функциональности.

Различия тест-кейса и чек-листа:

- Детализация:
  - тест-кейс - Проверки детализированы,
расписаны по шагам
  - чек-лист - Проверки формулируются в
общем виде. Часто пункт
чек-листа = заголовок тест-кейса

- Понятность:
  - тест-кейс - Понятен любому человеку 
  - чек-лист - Понятен человеку, который
знаком с продуктом

- Эффект пестицида (пропуск ошибок):
  - тест-кейс - Есть риск возникновения,
так как каждый раз
воспроизводятся одни и те
же шаги

  - чек-лист - Риск снижается, так как каждый
выполняет проверку по-своему

## Ценность тест-кейсов и чек-листов
1. **Структурируют и систематизирую подход к тестированию**. Позволяют
оценить объём предстоящей работы, распределить задачи между
тестировщиками в команде, не пропустить важных проверок.
2. **Основа для метрик тестового покрытия.** Помогают оценить, сколько
процентов требований протестируют, а на какие требования тесты ещё не
появились. Иными словами, какой процент технического задания покрыт
тестами.
3. **Основа для увеличения тестового покрытия**. Если тест-кейсов
недостаточно, нужно добавить.
4. **Показатель соответствия ситуации плану**:
- сколько тестов уже выполнено;
- какие из них прошли успешно;
- как много осталось проверить;
- какие функциональности тестировались или нет.
5. **Поддерживают взаимопонимание между заказчиком, разработчиками и тестировщиком**. Написание тест-кейсов часто приводит к дополнительным
вопросам по работе приложения. Это закрывает пробелы в знаниях о
системе, устраняет недопонимание с заказчиком или разработчиком.
6. **Хранят информацию для длительного использования и обмена опытом**
между сотрудниками и командами. Тест-кейсы и чек-листы используются,
чтобы удобно передавать знания о системе другим членам команды, а также
обращаться к ним при решении спорных вопросов — при условии, что
тест-кейсы написаны качественно и корректно.
7. **Основа регрессионного тестирования**. Тест-кейсы делают повторные
проверки регулярными и полноценными.

# Регрессионное тестирование

В течение всего жизненного цикла продукта в него вносят изменения — правки,
доработки, рефакторинг кода и новые фичи. Прежде чем отправить любые
изменения в коде в релиз, нужно убедиться, что работа системы не стала хуже. То
есть перед релизом мы проверяем не только что внесённые изменения
действительно есть и работают корректно, но и проверяем, что старый функционал
не был поломан.

Регрессионное тестирование (regression testing) — тестирование уже проверенной
функциональности после внесения изменений в код для уверенности, что эти
изменения не внесли или не активизировали ошибки в областях, которые не
подвергались изменениям.
Для регрессионного тестирования выбирают уже ранее составленные тест-кейсы

# Тест-дизайн

Тест-дизайн — этап тестирования ПО, на котором проектируются и создаются
тестовые случаи (тест-кейсы). Они соответствуют определённым ранее критериям
качества и целям тестирования.

В начале тестирования мы анализируем требования: определяем, насколько они
полные, чёткие, тестируемые. Когда требования проверены, проанализированы и
приоритизированы, начинается этап написания тест-кейсов — это и есть
тест-дизайн.


Важно, что критерии качества и цели тестирования должны быть определены до
начала написания тест-кейсов. От этих критериев и целей зависит, какими будут
тест-кейсы, для каких модулей они будут описаны в первую очередь, проверка
каких функций будет приоритетной.

Когда мы пишем тест-кейсы, одна из основных задач — создать оптимальное
тестовое покрытие функциональности, то есть не допустить «слепых зон» в
системе, которые не покрываются проверками

Задачи тест-дизайна на проекте:
- максимально покрыть функциональность тестами;
- обнаружить серьёзные баги;
- сократить количество тестов, исключив непродуктивные;
- не пропустить важные тесты.

Не возможно провести исчерпывающее тестирование. Поэтому
нужно применять разные техники, чтобы выполнить его эффективно и вовремя,
избежав при этом проверки лишних кейсов. При этом вся функциональность
должна быть покрыта тестами.

Кроме того, нужно попытаться составить тесты так, чтобы с их помощью можно
было обнаружить критичные дефекты. Нельзя выявить все баги и убедиться в их
отсутствии, но усилия и внимание тестировщиков должны быть направлены на
поиск самых серьёзных дефектов.

Если времени и специалистов мало, важно исключать из работы непродуктивные
тесты, которые не обнаруживают ошибок. В этом тоже помогут техники
тест-дизайна.

## Техники тест-дизайна

1. Классы эквивалентности (эквивалентное разделение).
2. Граничные значения (анализ граничных значений, метод граничных
значений).
3. Попарное тестирование (тестовая комбинаторика, pairwise).
4. Тестирование состояний и переходов.
5. Таблицы принятия решений.
6. Исследовательское тестирование.

### Классы эквивалентности
Класс эквивалентности — набор данных, которые обрабатываются одинаковым
образом и приводят к одному результату

Если известно, что есть группа данных, использование которых приводит систему в
одно и то же состояние, нет необходимости проверять каждое значение из этой
группы отдельно. Исключения возможны, но мы не можем проверять все данные,
так что приходится прибегать к подобным допущениям.

Например, в требованиях есть условие для посещения онлайн-кинотеатра:
«Возраст пользователя — от 16 лет и старше». Результат для пользователей,
которые указывают возраст меньше 16 лет (не важно, 5 или 15), всегда должен
быть одинаковым — сообщение «Извините, в связи с политикой сайта вы не можете
пользоваться сервисом». Так же и со значениями от 16 и выше — не важно, какой
возраст укажет пользователь (16, 23, 75, 99 лет), результат будет одинаковым:
«Добро пожаловать в наш кинотеатр. Желаем приятного просмотра!»

**Тестирование на основе классов эквивалентности**(equivalence partitioning) —
техника тест-дизайна на основе метода чёрного ящика: специалист не знает, как
устроена система, и проходит все шаги тестов, используя только те инструменты,
которые доступны пользователю.

**Цель техники** — обеспечить максимальную проверку всех требований тестами.
Разделяя данные на классы эквивалентности и выбирая лишь несколько значений
из каждого, можно существенно повысить эффективность и скорость тестирования,
разрабатывать и выполнять меньше тест-кейсов.

Есть два признака, что данные в тесте относятся к одному классу эквивалентности:

1. **Если один тест выявит ошибку, остальные, скорее всего, тоже это сделают.** Если в тестах используются значения из одного класса
эквивалентности, и один из тестов выявляет ошибку, остальные тесты,
построенные на данных из этого класса, тоже должны обнаружить эту
ошибку. Например, если онлайн-кинотеатр позволяет пользователю в
возрасте 14 лет зарегистрироваться на сайте, то, вероятнее всего,
регистрация будет возможна и для пользователей, указавших возраст 5, 10,
12 лет. А по требованиям это ошибка.

2. **Если один из тестов не выявит ошибку, остальные, скорее всего, тоже этого не сделают.** Если пользователю, указавшему возраст 15 лет, было
отказано в регистрации на сайте, то нет смысла перебирать все значения от 0
до 15 лет. Вероятнее всего, они тоже обработаются корректно.

Так как в тестировании нельзя быть уверенным в наличии или отсутствии ошибок, в
описаниях часто встречаются комментарии «скорее всего», «с большой долей
вероятности».

Если проводить исчерпывающее тестирование и проверять все варианты,
количество тестов составит минимум 100. Выполнить их
невозможно, поэтому нужно:
1. Разделить данные на классы эквивалентности.
2. Выбрать хотя бы одно значение из каждого класса эквивалентности для
проверки

Например выборка:

от 0 до 15 - вывети "нет"

от 16 до 17 - вывести "да, но"

от 18 до 64 - вывасти "да"

от 65 - 99 - вывести "нет"


Получаем следующие проверки:
- 1-й класс эквивалентности — 0;
- 2-й класс эквивалентности — 16;
- 3-й класс эквивалентности — 18;
- 4-й класс эквивалентности — 65.

Из каждого класса эквивалентности мы выбрали значения, чтобы сократить
количество тестов (теперь их 4 вместо 100). Любые другие значения из класса
эквивалентности должны давать те же результаты, что и выбранные.


Мы рассмотрели данные, которые можно расположить на числовой
прямой — классы эквивалентности этих данных будут **линейными**. Их можно
разбить на диапазоны с точными границами начала и конца (от 0 до 15, от 16 до 18
и так далее).

**Нелинейные** классы эквивалентности — это набор неупорядоченных данных. У них
нет границ, они являются частью множества данных. Пример — расширения
файлов, операционные системы, группы пользователей с различными правами
(пользователь, модератор, администратор) и так далее. В этом случае можно
выделить только два класса эквивалентности:

- валидный — соответствует требованиям,
- невалидный — не соответствует требованиям или обрабатывается системой
отличным от валидного класса образом.

Например, приложение обрабатывает только файлы в форматах MP3, APE, WAV.
Остальные форматы файлов системой не поддерживаются. В этом случае
невозможно выделить диапазоны и определить их границы. Можно выделить
только валидный класс эквивалентности, то есть допустимые форматы файлов, и
невалидный — все остальные форматы, которые система не поддерживает. Так как
в валидном классе всего три значения, их можно проверить все, а из невалидного
класса выбрать несколько вариантов.

Кроме чисел, на классы эквивалентности можно разбить:
- **символы** — они могут быть валидными (@ в адресе электронной почты) и
невалидными (?, %,*);
- **длину строки** — например, валидный класс от 1 до 30 знаков, невалидный —
всё остальное (меньше 1 и больше 30);
- **объём памяти**, который необходим приложению для стабильной работы;
- **разрешение экрана** — всё, что меньше или больше заявленных требований к
разрешению экрана, будет относиться к невалидным классам;
- **версии операционных систем, библиотек** — также определяются согласно
требованиям. Например, приложение должно работать на ОС Windows 7, но
поддержка Windows Nt уже не требуется.
- **объём передаваемых данных** — по требованиям. Например, если мощности
сервера не позволяют обработать объём данных больше определённого
значения.

Классы эквивалентности — одна из основных техник тест-дизайна. Именно с ней
тестировщики и тест-дизайнеры работают чаще всего. Она сокращает число тестов
(можно выбрать только несколько значений из класса эквивалентности), но к
использованию нужно подходить внимательно: если неверно выделить класс
эквивалентности, можно получить некорректные результаты тестирования и
пропустить ошибку.

### Граничные значения

**Граничное значение** (border condition, boundary condition) — значение на границе
классов эквивалентности.

Когда тестировщик работает с линейными классами эквивалентности (диапазонами
значений), может потребоваться определить границы диапазона, чтобы точно
отнести значение к конкретному классу эквивалентности.

У каждого диапазона будет начальная и конечная граница — это места
повышенного риска ошибок, так как разработчик может указать некорректный знак
неравенства или задать ошибочную границу диапазона.

**Техника анализа граничных значений** (boundary value testing) — проверка
поведения продукта на граничных значениях входных данных.

Граничные значения обязательно использовать при написании тестов, так как
именно на границе классов эквивалентности чаще всего и обнаруживаются
ошибки. Например, если в требованиях указано, что пользователь сайта должен
быть старше 16 лет, тестировщику следует уточнить у аналитика, входит ли
значение «16 лет» в валидный класс эквивалентности. А затем — проверить,
действительно ли это реализовано в приложении. Может оказаться, что
разработчик понял требования иначе и указал в коде, что сайтом могут
пользоваться лица с 17 лет (>16 вместо >=16)

Алгоритм определения граничных значений:
1. Выделить классы эквивалентности.
2. Определить граничные значения этих классов.
3. Определить, к какому классу будет относиться каждая граница.
4. Для каждой границы провести тесты: проверить значения до границы, на ней
и сразу после неё.

применение:

1. Определяем граничные классы эквивалентности:
- 1-й класс эквивалентности — 0–15;
- 2-й класс эквивалентности — 16–17;
- 3-й класс эквивалентности — 18–64;
- 4-й класс эквивалентности — 65–99.

2. Выделяем граничные значения:


|............. нет............ |...... да, но...... |......................... да ........................ | ........ нет ............ |

0-----------------16-------------18-----------------------------65---------------99

4. Для каждой границы выделяем три значения:
- {-1, 0, 1},
- {15, 16, 17},
- {17, 18, 19},
- {64, 65, 66},
- {98, 99, 100}.

5. Исключаем дубликаты (в нашем случае 17) и добавляем негативные
проверки, например: {-36, 1001, FRED, %$#@}

На основании этих данных можно проводить тестирование.


### Попарное тестирование

Попарное тестирование (pairwise testing) — техника формирования наборов
тестовых данных, при которой каждое тестируемое значение каждого из проверяемых параметров хотя бы раз сочетается с каждым из тестируемых
значений всех остальных проверяемых параметров

Попарное тестирование — разработка тестов методом чёрного ящика, в которой
тестовые сценарии разрабатываются таким образом, чтобы выполнить все
возможные отдельные комбинации каждой пары входных параметров.

Попарное тестирование — техника тестирования, в которой вместо проверки всех
возможных комбинаций значений всех параметров проверяются только
комбинации значений каждой пары параметров.

Техника применяется на проектах, где много параметров и их значений. Для
примера возьмём сайт по поиску автомобилей.

Для поиска автомобиля пользователь может указать марку, модель, цену, тип
автомобиля и другие параметры. У каждого из них множество возможных значений.
У параметра «Коробка передач» — четыре: механика, автомат, робот, вариатор. У
«Типа кузова» — седан, хетчбэк, универсал и другие. У параметров «Марка» и
«Модель» несколько десятков значений. Если и другие параметры, проверить все
варианты и их сочетания невозможно.

Есть теория, что большинство дефектов возникают при комбинации двух
параметров. Если проверка будет состоять из параметров BMW + Х6 + от 1 500 000 руб. до 4 000 000 руб. + с пробегом + от 2001 до 2019 года + автомат + хетчбэк +
бензин, то ошибка с большей вероятностью возникнет из-за сочетания только двух
из вышеперечисленных параметров

Например, при совпадении пары «хетчбэк + бензин», а не из-за сочетания всех
параметров одновременно. Поэтому есть смысл проверять сочетания двух значений
разных параметров. Это сократит количество тестов и увеличит вероятность
выявления дефектов.

Рассмотрим пример: нужно проверить форму, содержащую 20 чекбоксов
(элементов страницы с двумя значениями — выключен/включен). Если проводить
полный перебор для проверки сочетания всех значений, может потребоваться
1 048 576 тестов. Выполнить столько физически невозможно. Попарное
тестирование позволяет сократить количество проверок до 10.

В примере хорошо прослеживаются особенности техники попарного тестирования:
она наиболее эффективна при большом количестве параметров, которые имеют
ограниченное количество значений. В примере 20 чекбоксов, по два значения для
каждого — это позволило ощутимо сократить количество тестов

Если у параметра очень много значений, как у «Марки» в примере с сайтом по
поиску автомобилей, сокращение проверок при применении техники попарного
тестирования может быть незначительным. В этом случае удобнее разделить
значения на два класса эквивалентности — валидный и невалидный. К
невалидному классу будет относиться пустое поле или некорректные значения, а к
валидному — все корректные значения.

Учитывая огромное количество тестируемых параметров и значений в
приложениях, сгруппировать их по технике pairwise вручную невозможно либо
очень трудозатратно. Для этого есть специальные инструменты, и один из
популярных — PICT.

### Тестирование состояний и переходов

**Тестирование на основе состояний и переходов** (State-Transition Testing)
используют для фиксирования требований и описания дизайна приложения.

В проекте может быть большой набор требований с описанием состояния системы и
условий, при которых она в них переходит. Без визуального представления этих
состояний трудно увидеть всю цепочку событий. А это может привести к дефектам
архитектуры и дизайна приложения уже на уровне требований. Например, теперь в
мессенджерах можно удалять сообщения как у отправителя, так и у получателя. То
есть для состояния сообщения «Отправлено» или «Прочитано» должен быть
предусмотрен переход в состояние «Удалено». Если он будет упущен при
составлении требований, приложение получится неудобным для пользователей,
вряд ли его станут часто запускать.

Чтобы избежать таких ошибок, можно использовать технику тест-дизайна
«Тестирование состояний и переходов». Она позволяет составлять тестовые
сценарии, основываясь на визуальном представлении состояний и переходов
системы.

основне понятия,
которые используются при составлении диаграмм переходов и состояний:

**Точка входа** — старт работы системы или приложения.

**Переход** (transition) — переход системы из одного состояния в другое. Происходит в
результате действий пользователя или при определённых условиях.

**Событие** (event) — действие пользователя, которые он выполнил для перевода
системы в другое состояние. Или действия самой системы, меняющие её состояние.

**Действие** (action) — реакция приложения на действия пользователя или самой
системы (на событие).

**Условия перехода** (transition conditions) — условия, которые необходимы для
перехода системы в другое состояние. Например, изменение даты для начисления
процентов на вклад.

**Состояние** (state) — состояние системы до или после перехода в результате
действий пользователя или при определённых условиях.

**Точка выхода** — успешное окончание полного цикла работы приложения, то есть
выполнение всех переходов и состояний.

**Роли пользователей** (actors) — пользователи, которые могут по-разному влиять на
систему в зависимости от уровня прав доступа (зарегистрированный пользователь,
менеджер, администратор).


Классический пример — бронирование авиабилетов. Начнём с позитивного
сценария: пользователь успешно проходит весь цикл бронирования, включая
оплату и использование билета. Всегда стоит начинать с позитивных проверок,
чтобы убедиться, что система работоспособна и выполняет ключевые функции.

Если это не так, дальнейшее тестирование не имеет смысла до устранения
дефектов

 
1. Точкой старта будет вход в систему бронирования и выбор нужного билета.
Затем пользователь передаёт информацию, нужную для бронирования (имя и
фамилию, паспортные данные), и нажимает кнопку «Забронировать».
Нажатие можно считать событием. После него стартует таймер до окончания
срока оплаты. Система перешла в первое состояние — «Билет
забронирован».
2. Дальнейшее событие — «Оплата билета». Переводит систему в следующее
состояние — «Билет оплачен».
3. Затем по событию «Получить билет» система должна выполнить действие
«Отправка билета по email» и перейти в другое состояние — «Билет получен».
4. Последним звеном в этой цепочке будет событие «Предъявление билета при
посадке» (в примере часть событий пропущена — в реальных проектах их,
конечно, может быть намного больше). Состояние «Билет использован» —
цикл бронирования успешно завершён, система попадает в точку выхода.

--Передача данных/старт таймера--> |Билет забронирован| --оплата--> |Билет оплачен| --Получить/Отправка по email--> |Билет получен| --Предъявить на посадке--> |Билет использован| -->конец 

Рассмотренный сценарий — позитивный, он не предполагает дополнительных
действий пользователя. Это, конечно, невозможно, так как не всегда бронирование
билета должно заканчиваться его использованием. Пользователь может не
оплатить билет или оплатить, но потом отменить и прочее. Эти состояния также
нужно отразить на диаграмме.

При построении диаграмм состояний и переходов важно:
- не допускать пересечения линий переходов — это усложняет визуальное
восприятие диаграммы и может привести к ошибочному переходу;
- сложные процессы лучше представлять в виде нескольких диаграмм — если
охватить всё одной схемой, она будет слишком трудной для понимания;
- главную последовательность состояний следует размещать на одной
горизонтальной линии, чтобы прослеживался позитивный сценарий работы
системы. Дополнительные состояния можно представить в виде ответвлений
и разместить по бокам от основной последовательности.

Плюсы диаграмм состояний:
- позволяют визуализировать состояния продукта;
- демонстрируют варианты переходов, которые можно пропустить;
- помогают отследить дефект, сужая его локацию до конкретного перехода;
- показывают внутреннюю механику продукта

Минусы:
- можно пропустить неочевидные переходы;
- при слишком сложной структуре продукта диаграммы могут стать
громоздкими и запутанными;
- являются только основой к применению других методов;
- бесполезны при плохом знании продукта.

### Таблицы принятия решений
**Таблицы принятия решений** (таблицы решений) — способ компактно представить
модели со сложной логикой. А ещё это техника тестирования чёрного ящика,
которая применяется для систем со сложной логикой.

Таблицы принятия решений используют, чтобы упорядочить и задокументировать
сложную логику приложения, а также протестировать все комбинации условий и
состояний

Часто аналитики создают требования в виде сплошного текста с множеством
условий вида «если …, то ...». Например, «если пользователь старше 16 лет, то
доступ на сайт разрешён», «если пользователь авторизован в системе, то его
личные данные в форме заказа должны быть заполнены автоматически».
Тестирование таких требований и создание на их основе тест-кейсов трудоёмкое,
нужно повышенное внимание. Для таких случаев можно использовать технику
тест-дизайна «Таблицы принятия решений»


Состовляющие таблицы принятия решений:

**Условия** (conditions) — короткое описание входных условий (данных),
сформулированное в виде вопроса. Ответ — либо «да/нет», либо ограниченный
набор значений. Например: «Пользователь авторизован в системе?», «Вид
документа, предоставленный клиентом, — паспорт, водительские права,
загранпаспорт?»

**Действия**(actions) — чёткое описание ожидаемого результата, действия системы.
Формулировка действия — утвердительное предложение. Одно предложение
обязательно описывает только одно действие. Например: «Данные заполнены
автоматически», «Сообщение об ошибке отображается на экране».

**Значения** (values) — значения, допустимые для входных данных, указанных в
условии. Например: «да/нет», «паспорт, водительские права, загранпаспорт».

**Правила** (rules) — комбинации входных данных, которые отражены в таблице.

Пример:

Требование: для поддержания системы лояльности провести информационную
рассылку постоянным клиентам.

Содержание писем зависит от следующих условий:
1. Клиенты типа А, В получают стандартное письмо.
2. Клиенты типа С получают специальное письмо.
3. Клиентам, совершившим пять и более покупок или купившим на сумму более
500 долларов, в письме сообщается о дополнительной скидке 20% на
следующий заказ

Начнём составлять таблицу по плану:
1. Разбить требование на условия.
2. Посчитать количество возможных правил (комбинаций).
3. Составить таблицу принятия решений.
4. Исключить лишние комбинации, если они есть.
5. Создать тесты.

Теперь разберём каждый пункт.
1. Разбить требование на условия.

Можно выделить три условия:
- тип клиента;
- пять и более покупок;
- сумма больше 500 долларов.

2. Посчитать количество возможных правил (комбинаций).

Расчёт можно выполнить по формуле X = Y1 ⋅ Y2 ⋅ … ⋅ Yn, где:

- Х — вычисляемое количество комбинаций;
- Y1...Yn — количество вариантов каждого условия;
- N — количество условий

Таким образом, получим:
- Y1 = 4 (четыре значения для условия «Тип клиента» — «A, B, C, D»);
- Y2 = 2 и Y3 = 2 (по два значения для условий «Пять и более покупок» и «Сумма
больше 500 долларов» — «YES/NO»);
- N = 3 (требование содержит три условия);
- X = 4 ⋅ 2 ⋅ 2;
- Х = 16 правил (комбинаций условий).

3. Составить таблицу принятия решений.

Заносим в таблицу условия, значения и правила следующим образом:

| Условия               | Значеня | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
|-----------------------|---------|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|
| Тип клиента           | А,B,С,D | А | А | А | А | B | B | B | B | С | С  | С  | С  | D  | D  | D  | D  |
| 5 и более покупок     | Y,N     | Y | Y | N | N | Y | Y | N | N | Y | Y  | N  | N  | Y  | Y  | N  | N  |
| Сумма больше 500 дол. | Y,N     | Y | N | Y | N | Y | N | Y | N | Y | N  | Y  | N  | Y  | N  | Y  | N  |
| **Действия:**              |         |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |
| Стандартное письмо    |         | x | x | x | x | x | x | x | x |   |    |    |    | ?  | ?  | ?  | ?  |
| Cпециальное письмо    |         |   |   |   |   |   |   |   |   | x | x  | x  | x  | ?  | ?  | ?  | ?  |
| Сообщение о скидке    |         | ? | x | x |   | ? | x | x |   | ? | x  | x  |    | ?  | ?  | ?  | ?  |
| Не получают письмо    |         |   |   |   |   |   |   |   |   |   |    |    |    | ?  | ?  | ?  | ?  |

В таблицу добавили тип клиента «D» — это все остальные типы клиентов, если будут
выявлены те, которые не подпадают под характеристики для клиентов типа «А, В,
С».

Для правил, которые не отражены в требованиях, использован «?» (в требованиях
не указано, какое письмо должно быть отправлено, когда сочетаются условия
«более пяти покупок» и «сумма больше 500 долларов», а также как поступить с
клиентами типа D). Ситуации, помеченные знаком вопроса, надо прояснить с
аналитиком или заказчиком.

Первая строка в таблице формируется так: количество всех правил (комбинаций)
делится на количество значений первого условия. То есть 16 (число правил) делим
на 4 (число значений для условия «Тип клиента»). Получаем ряд из четырёх
одинаковых значений подряд (см. таблицу выше). Заполняя остальные строки,
нужно соблюдать последовательность: каждая следующая строка — это
предыдущая строка, разделённая пополам. То есть в первой строке каждое
значение повторялось четыре раза подряд, во второй — два раза, в третьей
происходит чередование значений. Если бы в таблице было ещё одно условие, то в
следующей строке каждое значение снова повторялось бы четыре раза, потом два
раза и так далее.

Также в таблице указываем действия, которые произойдут при совпадении тех или
иных условий. И отмечаем, какое именно действие выполняется при совпадении
условий. В данном случае выделим четыре действия: «Стандартное письмо»,
«Специальное письмо», «Сообщение о скидке», «Не получают письмо».

4. Исключить/добавить комбинации.

В этом случае были добавлены комбинации для дополнительного типа клиента «D».
Могут возникать ситуации, когда в таблице появятся комбинации условий, которые
на практике невозможны. Например, если тестируется форма с двумя кнопками
«Сохранить» и «Отменить», каждая кнопка имеет два значения: «Нажата» / «Не
нажата». Одновременно обе кнопки не могут принимать значение «Нажата» —
значит, такая комбинация должна быть исключена из таблицы.

5. Создать тесты.
В результате получаем тестовые сценарии, которые можно либо перенести в
тест-кейсы, либо оставить в таблице и добавить строку с результатом проверки.

В этом случае:
- Draft — тест, который требует уточнения условий;
- Failed — тест, который прошёл неуспешно, например, был выявлен дефект;
- Passed — тест, который прошёл успешно, функциональность работает.

Плюсы таблиц принятия решений:
- помогают быстро составлять тестовые сценарии;
- позволяют выявить неполноту требований;
- их можно использовать при отсутствии требований;
- можно быстро проверить покрытие требований тест-кейсами;
- позволяют предугадывать возможные ошибки.

Минусы:
- при большом количестве условий таблицы могут быть громоздкими — их
сложно составлять и использовать;
- сложность в корректном определении условий, действий и значений при
первоначальном проектировании.

### Исследовательское тестирование

Исследовательское тестирование — это подход, когда тестировщик
не использует тест-кейсы, а тестирует приложение по определённому сценарию,
который часто составляется прямо во время проверки.

Тестировщик проводит исследовательское тестирование приложения, в результате
которого выявляются дефекты. Тот сценарий (тест), который выявил дефект, нужно
задокументировать (создать тест-кейс), чтобы в дальнейшем проверять, что дефект
исправлен и не появился вновь. Кроме того, стоит создать тест-кейсы (если их нет)
и для проверки похожих сценариев, чтобы обнаружить другие подобные дефекты. В
некоторых случаях проверки, проведённые при исследовательском тестировании,
следует документировать (создавать тест-кейс), даже если они не обнаружили
дефект. Это нужно, чтобы повторять проверки в будущем, в том числе при
регрессионном тестировании

Исследовательское тестирование также используют как вспомогательный подход к
тестированию по тест-кейсам. Оно помогает исключить эффект пестицида (когда тест-кейсы перестают выявлять дефекты) при частом использовании одних и тех же
тест-кейсов.

Ещё случаи, когда исследовательское тестирование может быть эффективным:
1. Нужно быстро понять, насколько качественно выполнена новая
функциональность: проверить, что в ней нет критических дефектов.
2. Нужно быстро изучить тестируемый продукт (например, новому
тестировщику на проекте) и получить общую информацию о его основной
функциональности.
3. Нужно проконтролировать работу других тестировщиков: проверить без
использования тест-кейсов, что приложение работает (с позиции
пользователя).
4. Недостаточно времени для составления тест-кейсов.
5. Отсутствуют требования, на основании которых можно составить тест-кейсы.
6. Тестируется небольшой проект, для которого не требуется
структурированного подхода к тестированию.
7. В проекте произошли внезапные изменения, которые требуют быстрой
проверки.

Плюсы исследовательского тестирования:
- не нужно тратить время на предварительное описание всех сценариев;
- не нужна поддержка тестовых сценариев;
- нет привыкания к тестовым сценариям, их прохождение не происходит «не
глядя»;
- не теряется цельное видение продукта;
- критические дефекты находятся быстрее;
- повышается скорость тестирования;
- можно сразу начинать тестировать продукт, даже если требований нет
вообще;
- исследовательское тестирование интереснее и креативнее (тесты
ограничиваются только фантазией и глубиной знаний о продукте).

Минусы:
- сложно планировать время на проведение тестирования без
задокументированных заранее сценариев;
- вероятность пропустить ключевые проверки, так как отсутствует
ранжирование сценариев по степени важности;
- сложность оценки полноты покрытия требований тестами;
- требуется высокая квалификация тестировщиков и хорошее знание
тестируемого приложения;
- сложно использовать для регрессионного тестирования;
- невозможно автоматизировать такое тестирование.

Важно понимать, что исследовательское тестирование — не хаотичное без
документации и подготовки. Оно требует планирования и профессиональных
навыков тестировщика.

 Есть решения, позволяющие сделать исследовательское
тестирование более структурированным:

- использование чит-листов — списков базовых проверок, которые можно
применять для тестирования однотипных приложений;
- сессионное тестирование — установка временного интервала для
проведения исследовательского тестирования, например, сессии в 90 минут;
- парное тестирование — проверка одного блока или модуля двумя
тестировщиками, один из которых может проводить тестирование, а второй
— описывать найденные дефекты;
- тест-туры Джеймса Уиттакера — отдельная тема в исследовательском
тестировании.

**Тест-туры** — неформальный подход, который позволяет сделать исследовательское
тестирование ещё более осмысленным и интересным. Они содержат инструкции по
исследованию приложения — по аналогии с тем, как турист изучает город.
Подробнее с этим способом работы с приложением можно познакомиться в статьях:
- Исследовательское тестирование и исследовательские туры Виттакера
https://www.software-testing.by/blog/exploratory-testing-exploratory-tours/
-  Как искать баги — исследовательские туры Уиттакера
http://okiseleva.blogspot.com/2015/01/blog-post_64.html
