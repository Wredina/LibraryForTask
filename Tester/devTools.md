# DevTools

**DevTools** — это набор инструментов для веб-разработчиков, встроенных непосредственно в браузер.
Этот набор инструментов позволяет тестировать, отлаживать, профилировать, проверять код на
соответствие стандартам и делать многое другое. Инструменты для разработчиков имеются во всех
современных браузерах, таких как Chrome, Mozilla Firefox, Safari и многих других.

Есть несколько способов открыть Chrome DevTools в зависимости от того, к какому инструменту мы
хотим получить доступ:

1. Кликнуть правой кнопкой мыши в любом месте страницы и выбрать пункт «Просмотреть код
элемента» (Inspect в английской версии браузера)
2. Воспользоваться комбинацией клавиш Ctrl + Shift + I или F12 для Windows и Linux, или Cmd +
Opt + I для операционной системы MacOS

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/1.jpg?raw=true">

Чтобы открыть DevTools в Mozilla Firefox:

1. Кликнуть правой кнопкой мыши в любом месте страницы и выбрать пункт «Исследовать
элемент»
2. Воспользоваться комбинацией клавиш Ctrl + Shift + I или F12 для Windows и Linux, или для
Mac OS X (сочетание клавиш — ⌘ + ⌥ + I)

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/2.jpg?raw=true">

Чтобы открыть DevTools в Safari:

1. Выберите меню «Safari» > «Настройки», нажмите «Дополнения», затем установите флажок
«Показывать меню «Разработка» в строке меню»
2. Затем сочетание клавиш — ⌘ + ⌥ + I или кликнуть правой кнопкой мыши в любом месте
страницы и выбрать пункт «Проверить объект»

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/3.jpg?raw=true">

При переходе в инструменты разработчика в любом браузере появится панель для работы с
веб-страницей. Панель может располагаться и слева, и внизу, и справа. Можно расположить панель
в отдельном окне и, например, перенести на второй монитор.

Варианты расположения, слева направо:

1. Открепить DevTools и открыть их в другом окне.
2. Прикрепить к левому краю.
3. Прикрепить к нижнему краю.
4. Прикрепить к правому краю.

Например, DevTools для Safari можно расположить по правому краю, по нижнему краю и в отдельном
окне:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/4.jpg?raw=true">

Вариант отображения по правому краю:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/5.jpg?raw=true">
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/6.jpg?raw=true">

Варианты отображения панели DevTools в браузере Chrome (чтобы вызвать контекстное меню,
необходимо нажать на экшен меню (три точки), которые находятся слева от крестика):

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/7.jpg?raw=true">

Панель открывается только для текущей вкладки.

## Структура DevTools

Мы рассмотрим инструменты разработчика на примере Chrome DevTools. В DevTools вкладки самого
верхнего уровня называются «Панели»:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/8.jpg?raw=true">

Слева, перед панелями, располагаются кнопки выбора элемента на странице и выбора устройства
для отображения:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/9.jpg?raw=true">

Панель **Elements** используется для выбора и редактирования любых HTML-элементов на странице.
Позволяет свободно манипулировать DOM и CSS.

Панель **Console** применяется для логирования диагностической информации в процессе разработки
или взаимодействия с JavaScript на странице.

Панель **Recorder** применяется для записи, воспроизведения и измерения пользовательских
действий.

Панель **Sources** показывает все файлы, подключённые к текущей странице.

Панель **Network** позволяет мониторить процесс загрузки страницы и всех файлов, которые
подгружаются при её загрузке

Панель **Performance** отображает таймлайн использования сети, выполнения JavaScript-кода и
загрузки памяти, применяется для оценки производительности работы страницы в целом

Панель **Memory** используется для отслеживания нагрузки, которую оказывает выполнение JS-кода
на систему.

Панель **Application** содержит инструменты для просмотра всех загруженных ресурсов и работы с
ними: cookie, кеша приложения, изображений, шрифтов, таблиц стилей, локального хранилища.

На панели **Security** отображается информация о протоколе безопасности, данные о сертификате,
если он есть, безопасной загрузке ресурсов. Инструмент используется для обнаружения проблем
безопасного или небезопасного содержимого, проблем сертификатов и так далее.

Панель **Lighthouse:** после выбора параметров и запуска системы аудита происходит анализ
загружаемой страницы и предоставляются предложения по оптимизации страницы для уменьшения
времени её загрузки и увеличения отзывчивости.

## Device Toolbar

Функция Device Toolbar служит для эмуляции внутри браузера различных разрешений экрана и
разных устройств, например, телефонов или планшетов. Они используются для базового
тестирования совместимости сайта с разными устройствами.

Активация Device Toolbar происходит при клике на кнопку Device Toolbar или комбинацией клавиш
Ctrl+Shift+M:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/10.jpg?raw=true">

В Chrome есть готовые пресеты для разных мобильных устройств, но также можно добавить
собственное, указав размер экрана.

Режим выбора устройства Device Toolbar:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/11.jpg?raw=true">

Список устройство можно редактировать, для этого выберите Edit… и в нижнем меню можно
управлять устройствами:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/12.jpg?raw=true">

Режим просмотра на разных устройствах позволяет быстро проверить, как страница будет
выглядеть на мониторах с разным разрешением или на мобильных телефонах. Функция выбора
устройства пригодится при разработке адаптивных веб-интерфейсов, мобильных версий сайтов или
для тестирования страниц на разных разрешениях монитора.

Разные режимы просмотра полезны при тестировании приложений, имеющих разный
инструментарий для веб-версии и настольного компьютера. Можно также управлять ориентаций
экрана:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/13.jpg?raw=true">

А также имеется возможность эмулировать тип подключения к Интернету:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/14.jpg?raw=true">

Доступно несколько режимов подключения:

- Mid-tier mobile (средняя скорость соединения)
- Low-end mobile (слабая скорость соединения)
- Offline (без сети)

У режима есть собственные настройки. Кнопка с меню располагается прямо под кнопкой основного
меню:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/15.jpg?raw=true">

Show/Hide device frame включает и отключает отображение рамки для некоторых устройств.

Show/Hide media queries включает наглядный график отображения загрузки медиа запросов:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/16.jpg?raw=true">

Show/Hide rules включает отображение линейки:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/17.jpg?raw=true">

Также можно сделать скриншот страницы видимой части (Capture screenshot) или же полностью всей
страницы (Capture full size screenshot):

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/18.jpg?raw=true">

Далее переходим к следующей панели, Elements.

## Elements

При активном пункте меню Elements можно видеть всё DOM-дерево веб-страницы, изменять
свойства HTML-элемента и отслеживать изменения на веб-странице без перезагрузки,
просматривать ссылки и многое другое:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/19.jpg?raw=true">

1. Выберем режим Select an element…
2. Далее выберем любой необходимый элемент на странице
3. Строка с кодом выбранного элемента подсвечивается

При выборе любого DOM-элемента на вкладке Styles отобразятся все CSS-правила, применяемые к
нему, в том числе и неактивные. Все правила разбиты на блоки и упорядочены по убыванию
специфичности селектора. Можно на лету менять значения, деактивировать и дописывать новые
правила и смотреть, как это влияет на отображение.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/20.jpg?raw=true">

Давайте попробуем изменить у номера телефона стиль, изменив размер шрифта и цвет:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/21.jpg?raw=true">

После изменения размера и цвета номер телефона будет иметь следующий вид:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/22.jpg?raw=true">

Для выбранного элемента DOM доступно ещё несколько вкладок:

1. Event Listeners — содержит все события, относящиеся к конкретному элементу. Например, у
активного элемента прописывается выполнение определённого JavaScript-кода при нажатии
на элемент. Тогда такое событие будет описано как click в этой вкладке:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/23.jpg?raw=true">

2. DOM Breakpoints — точки останова для элемента. Используются программистами для
отладки JavaScript-кода. Программист может добавить остановку выполнения скрипта при изменении DOM, затрагивающем этот элемент: изменении атрибутов этого элемента,
дочерней структуры DOM или при полном удалении элемента:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/24.jpg?raw=true">

3. Properties — список всех свойств элемента:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/25.jpg?raw=true">

Возникают также дополнительные вкладки, добавляемые расширениями для Chrome.

Ключевые возможности

1. Просмотр и редактирование в live-режиме любого элемента DOM.
2. Просмотр и изменение CSS-правил, применяемых к любому выбранному элементу в панели
Styles.
3. Просмотр всего списка событий и свойств для элемента на соответствующих вкладках.

### Выбор элемента для работы

Способы поиска подходящего элемента:

1. При наведении курсора на код соответствующий элемент на самой странице автоматически
подсвечивается, а также указывается название тега и его размер в пикселях:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/26.jpg?raw=true">

Если у элемента есть внутренние и внешние поля, они выделяются цветом:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/27.jpg?raw=true">

2. Поиском по DOM-дереву. На панели инструментов нажимаем Ctrl+F и вводим строку для
поиска, например, тег, CSS-класс или XPath:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/28.jpg?raw=true">

### Работа с конкретным элементом

Выбрав конкретный элемент, можно менять его свойства и смотреть, как это влияет на страницу.

Например, так меняется имя тега. Закрывающий тег автоматически изменится. Аналогично
меняются названия классов, параметры высоты и ширины, отступы — все поля доступны для
редактирования. Изменения применяются сразу после клика вне тега.

Дополнительные функции редактирования доступны по правому клику на элемент:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/29.jpg?raw=true">

Через это меню можно быстро отредактировать элемент как HTML в текстовом поле для ввода,
удалить элемент, спрятать его или добавить к нему атрибуты

### Активация псевдоклассов

Псевдоклассы на элементах вызываются, чтобы исследовать, как элемент отреагирует, если на
него, например, навести мышку. Мы можем активировать псевдоклассы active, focus, hover и
visited.

Активировать псевдокласс можно через меню, доступное по правому клику на элемент:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/30.jpg?raw=true">

Когда к элементу применяется какое-то состояние, мы видим небольшой визуальный индикатор
слева от открывающего тега, а в некоторых случаях, если они далеко друг от друга, и от
закрывающего.

### Наглядное изменение стилей

Для каждого элемента в Elements открывается панель Styles, где можно менять, например, включать
и выключать или редактировать, стили, цвета элементов, просматривать параметры внешних и
внутренних отступов:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/31.jpg?raw=true">

Все параметры доступны для редактирования по двойному клику

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/32.jpg?raw=true">

Боковое меню доступно для просмотра, если кликнуть на кнопку:
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/33.jpg?raw=true">
Но надо помнить, что эти изменения нигде не сохраняются. Всё, что мы отредактировали, потеряется
при перезагрузке страницы.

### DOM

DOM (Document Object Model) — «объектная модель документа». Это программный интерфейс,
позволяющий программам и скриптам представлять содержимое HTML, XHTML и XML-документов в
виде дерева, изменять содержимое, структуру и оформление таких документов.

Когда мы загружаем страницу из интернета, браузер в ответе на GET-запрос получает исходный код
страницы, которую надо отобразить. Компонент браузера, отвечающий за работу с HTML,
анализирует этот исходный код и из него собирает собственную модель страницы в памяти,
используя DOM. DOM необязательно будет соответствовать исходному коду страницы.

Во-первых, в HTML-коде встречаются ошибки вёрстки. Браузер их обнаруживает, автоматически
исправляет (насколько может) и создаёт корректную объектную модель документа. Во-вторых, при
анализе страницы браузер обнаруживает и выполняет JavaScript-код, который также может
повлиять на структуру и отображение страницы, и только после этого страница отобразится на
экране

Максимально близкое к DOM отображение структуры страницы есть в инструментах разработчика
Google Chrome во вкладке Elements:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/34.jpg?raw=true">

### XPath

XPath — это язык запросов, позволяющий найти определённый элемент в дереве элементов DOM
(HTML, XML)

XPath использует обозначение пути (как в URL-адресах) для навигации по структуре
HTML-документа.

Путь XPath состоит из шагов адресации, разделённых символом «/».

Путь может быть абсолютным (или полным) и относительным. Полный путь всегда начинается с
корневого элемента — HTML, и он в общем случае определяет строго один элемент. В начале полного
пути ставится знак «/».

>Например: /html/body/div/table[@id=”data”]/tr/td/span — и мы найдём один конкретный span.

Относительный путь начинается с символов «//» и определяет некоторую последовательность
элементов внутри дерева DOM.

>Например: //table/tr[1]/td[1]/span.

Этот код найдёт все элементы span, расположенные в первой ячейке первой строки таблицы. Если
на странице несколько таких таблиц, то и элементов span будет найдено несколько. Это важный
момент, который стоит учитывать при создании автоматизированных тестов.

Каждый шаг адресации состоит из трёх частей:

1. Ось, представляющая собой направление, в котором происходит поиск по дереву элементов.
По умолчанию значение оси child::, то есть осуществляется переход к дочерним элементам,
и зачастую этого варианта достаточно, но есть и другие варианты осей:
    - child:: — множество элементов-потомков, расположенных на один уровень ниже.
Это название можно опускать, оно считается значением по умолчанию.
    - descendant:: — рекурсивное множество всех элементов-потомков.
    - descendant-or-self:: — полное множество элементов-потомков и текущий элемент.
Основа для поиска относительного пути: ось /descendant-or-self::node()/
записывается как //.
    - ancestor:: — множество элементов-предков.
    - ancestor-or-self:: — множество элементов-предков и текущий элемент.
    - parent:: — родительский элемент. Это обращение можно заменить на ..
    - self:: — текущий элемент. Это обращение заменяется на .
    - following:: — множество элементов, расположенных ниже текущего элемента по
дереву, на всех уровнях и слоях, исключая собственных потомков.
    - following-sibling:: — содержит множество братских элементов того же уровня,
следующих за текущим слоем.
    - preceding:: — множество элементов, расположенных выше текущего элемента по
дереву, на всех уровнях и слоях, исключая множество собственных предков.
    - preceding-sibling:: — множество братских элементов того же уровня,
предшествующих текущему слою.
    - attribute:: — множество атрибутов текущего элемента, обычно заменяется символом
@.
    - namespace:: — содержит множество элементов, относящихся к тому или иному
пространству имён, то есть содержится атрибут xmlns.
2. Выражение, определяющее отбираемые элементы, например, имя тега (html), значения
атрибута (@id=”form”), все элементы (*).
3. Предикаты — дополнительные условия отбора. Их может быть несколько. Каждый предикат
заключается в квадратные скобки [ ] и подразумевает логическое выражение для проверки
отбираемых элементов. Если предиката нет, то отбираются все подходящие элементы.
Наиболее популярные варианты предикатов:
    - [N], где N — любое натуральное число, выберет элемент с порядковым номером N,
например, подходящую строку таблицы или элемент списка.
    - [last()] — выберет последний элемент из множества.
    - [@attribute=”value”] — выберет элемент, у которого есть атрибут attribute и его
значение равно value.
    - [contains(@class, “name”)] — выберет элемент, у которого есть атрибут class, и его
значение содержит подстроку name.

Для поиска XPath используются инструменты разработчика в Google Chrome. Но они не всегда дают
хороший результат, так что зачастую приходится строить локатор вручную.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/35.jpg?raw=true">

Пример скопированного XPath:

>/html/body/div[1]/div/div/div/div[2]/ul/li[1]/a

### Абсолютный и относительный путь

Часто в интернете встречаются два разных термина для описания гиперссылки: URI (Uniform
Resource Identifier) — унифицированный идентификатор ресурса, и URL (Uniform Resource Locator) —
унифицированный локатор ресурса. По сути, они описывают одно и то же: по какому адресу найти
ресурс. Это различие, как некоторое недопонимание, появилось на заре интернета, в первой
половине 90-х годов. Сейчас URI и URL по факту считаются синонимами, но стандарты рекомендуют
именно термин URI. Подробности — в <a href="https://www.ietf.org/rfc/rfc3305">документе RFC 3305</a> (на английском языке).

### Структура URI
>
><схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<путь>][?<параметры>][#<якорь>]

**Схема** — схема обращения к ресурсу. В большинстве случаев имеется в виду сетевой протокол,
например, http.

**Логин** — имя пользователя, используемое для доступа к ресурсу.

**Пароль** — пароль указанного пользователя.

**Хост** — доменное имя (site.com) или IP-адрес (127.0.0.1).

**Порт** — порт для подключения.

**Путь** — информация о месте нахождения ресурса на конкретном хосте.

**Параметры** — строка запроса с передаваемыми на сервер методом GET параметрами. Начинается с
символа «?», в качестве разделителя используется &. Пример:

>?параметр1=значение1&параметр2=значение_2.

**Якорь** — идентификатор якоря внутри документа.

**Примеры адресов:**

>ftp://user:<password@hosting.org>:20/transfer/incoming/data

><https://forum.justforfun.net/forums/view/page.php?skip=20&order=desc>

><http://reader.boooks.ru/read/book/127/chapter3.html#top>

><http://10.20.57.14:8080/resources/>

Эти ссылки — примеры абсолютных путей, то есть они указывают всегда на один и тот же ресурс, где
бы мы ни находились. Кроме них, есть ещё и относительные: ресурс, на который они указывают,
зависит от того, где сейчас находится пользователь.

Абсолютные ссылки указывают полный путь к ресурсу, например,
<http://mysite.com/images/photos/photo01.jpg>, и всегда работают одинаково, независимо от того, из
какого документа (и даже сайта) по ним переходят

Относительные ссылки указывают путь к ресурсу относительно текущего URI, то есть
местоположения на сайте. Таким образом, одна и та же ссылка, написанная одинаково, с разных
страниц ведёт на совершенно разные страницы.

Например, изображение находится на стороннем сервере, поэтому ссылка указана абсолютная:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/36.jpg?raw=true">
```html
<img src="http://mybiysk.ru/wp-content/uploads/2019/07/otkryvaem-konditerskuyu.jpg" alt=""
/>
```
Есть четыре типа относительных ссылок:

1. **Ссылка сетевого пути.** Например, //mysite.com/files/. Эта ссылка перенаправляет на
указанный адрес с использованием текущей схемы. То есть, если мы находимся на
<https://anysite.com>, откроется адрес <https://mysite.com/files/>, а если на ftp://anysite.com —
ftp://mysite.com/files. Полный адрес ресурса высчитывается относительно URI-схемы.
2. **Ссылка абсолютного пути.** Она имеет вид /path/to/some/uri и начинается с символа «/»,
который указывает, что отсчёт надо начинать с корня домена. В этом случае откроется ресурс
с этого же домена, но путь к конечному ресурсу будет одинаков для всех страниц на этом
домене.
3. **Ссылка относительного пути.** Такая ссылка высчитывается относительно текущего адреса.
Например, ссылка вида images/photos/photo01.jpg означает, что для подразделов сайта
mysite.com/events/ и mysite.com/tours/ она будет указывать на разные файлы. Строка «../»
говорит о переходе на один уровень вверх по структуре пути. Если ссылка
../images/photos/photo02.jpg находится на странице <http://mysite.com/events/about.html>, то
полный путь будет <http://mysite.com/images/photos/photo02.jpg>. А если на той же странице
есть ссылка images/photos/photo02.jpg, то полный путь —
<http://mysite.com/events/images/photos/photo02.jpg>.

Например, ссылка на логотип сайта в примере из предыдущего урока — images/logo.png:

```html
<a href="index.html"><img src="images/logo.png" /> </a>
```

4. Ссылка внутри документа. Она задаётся посредством якоря #. Например, можно в начале
документа присвоить какому-то элементу name="top”, тогда ссылка вида <a
href=”#top”>Наверх</a> перекинет нас в начало документа.

Переход в самую верхнюю часть сайта при клике на «Все права защищены»:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/37.jpg?raw=true">

```html
<a href="#top">Все права защищены</a>
```

Кроме ссылок типа http(s), есть множество других типов ссылок (схем) в веб-приложениях:

- mailto;
- tel;
- javascript;
- ftp;
- telnet;
- file;
- git;
- xmpp;
- skype;
- steam;
- tg;
- многие другие, зарегистрированные <a href="https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml">Uniform Resource Identifier (URI) Schemes.</a>

А ещё можно создать собственную схему и задать её обработку определённому приложению.
Для работы любого сайта важно, чтобы все ссылки были верными: как минимум не вели в никуда.
Если сайт небольшой, это можно проверить вручную, прокликав по всем ссылкам. Но если на сайте
сотни и тысячи ссылок, то надо воспользоваться автоматизированными инструментами для
проверки сайта.

### Console

Вкладка Console позволяет просматривать, отлаживать и выполнять JS-код для загруженной
страницы. В качестве примера откроем ресурс: <https://sprout-boulder-juniper.glitch.me/> и перейдём в
Console:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/38.jpg?raw=true">

В консоли мы видим ошибку, которая говорит нам, что не найден заголовок h2. Часто возникают
трудности при составлении баг-репорта на ошибки из консоли. Давай попробуем описать баг:

>Не найден заголовок h2 при переходе на страницу <https://sprout-boulder-juniper.glitch.me/>
>
>Шаги воспроизведения:
>
> 1. Открыть страницу <https://sprout-boulder-juniper.glitch.me/>
>
>Фактический результат:
>
>Отображается ошибка:
>
> Assertion failed: h2 not found!
>
> (anonymous) @ (index):12
>
>Ожидаемый результат:
>
>Заголовок h2 загружается при переходе на страницу <https://sprout-boulder-juniper.glitch.me/>
>
>Окружение: macOS BigSur, Chrome 101.0.4951.64

### Recorder

Панель Recorder применяется для записи, воспроизведения и измерения пользовательских
действий. Запишем действия пользователя на примере сайта: <https://coffee-cart.netlify.app/>

Чтобы записать действия, необходимо:

1. Открыть панель Recorder → Start New Recording

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/39.jpg?raw=true">

2. Зададим название нашей записи, например, add to cart и нажмём start a new recording:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/40.jpg?raw=true">

3. Часть наших действий, а именно: добавление всех позиций в корзину, переход на страницу
корзины, увеличение количества позиций — всё это мы записываем и после нажимаем на
кнопку Stop recording:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/41.jpg?raw=true">

4. Все записанные действия отображаются в списке действий и мы можем теперь
воспроизвести их, нажав на Replay:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/42.jpg?raw=true">

5. Все записанные действия воспроизводятся и за ходом воспроизведения также можно
следить на панели рекордера:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/43.jpg?raw=true">

6. Также мы можем задать необходимую нам скорость соединения:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/44.jpg?raw=true">

Также можно редактировать шаги, для этого достаточно просто выбрать необходимый шаг:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/45.jpg?raw=true">

Вы можете также измерить производительность, нажав кнопку Measure performance. Сначала
запустится воспроизведение пользовательского сценария, а затем откроется страница с отчётом
производительности на панели Performance:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/46.jpg?raw=true">

### Sources

Основное назначение этой вкладки — работать с исходным кодом файлов веб-приложения.

Эта вкладка имеет несколько вложенных вкладок: Page, Filesystem, Overrides, Content Scripts,
Snippets

Вкладка Page показывает все файлы, которые используются на этой странице — сам исходный код,
файлы стилей, код на JavaScript, изображения, шрифты и так далее. Так выглядит список файлов для
сайта <https://gb.ru>:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/47.jpg?raw=true">

На вкладке Filesystem можно добавить папки с диска и посмотреть содержимое текстовых файлов
(html, css, js), отредактировать код, скопировать его или сохранить изменённый файл как новый. Эта
вкладка используется и как полноценный редактор кода, если подключиться к локальным файлам:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/48.jpg?raw=true">

### Network

Эта вкладка позволяет мониторить процесс загрузки страницы и всех файлов, которые
подгружаются при загрузке, в качестве примера откроем профиль пользователя на сервисе
объявлений Юла <https://youla.ru/user/60c36ce0ab44953f8f6fed6a>:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/49.jpg?raw=true">

Её удобно использовать для оптимизации загрузки страниц и мониторинга запросов и ответов.
Например, запрос на пользователя находится во вкладке Payload:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/50.jpg?raw=true">

Ответ от сервера с информацией по пользователю в формате JSON:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/52.jpg?raw=true">

На панели отображается таблица всех запросов к данным и файлам, над ней располагаются кнопки
для фильтрации запросов, очистки таблицы или включения и отключения записи запросов, кнопки
управления отображением таблицы:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/53.jpg?raw=true">

Есть также дополнительные переключатели:

1. Preserve log — не очищать таблицу при перезагрузке страницы.
2. Disable cache — отключить кеш браузера — будет работать только при открытом DevTools.
3. Offline — эмулирует отсутствие интернета, также позволяет эмулировать скорость
скачивания и загрузки данных и пинг для различных типов сетей.

Под таблицей указывается количество всех запросов, общее количество загруженных данных,
общее время загрузки всех данных, время загрузки и построения DOM-дерева и время загрузки всех
ресурсов, влияющих на отображение этой страницы.

**Ключевые возможности**

1. Возможность отключить кеширование или установить ограничения пропускной способности.
2. Получение подробной таблицы с информацией о каждом запросе.
3. Фильтрация и поиск по всему списку запросов.

### Время загрузки страницы

В инструментах разработчика можно увидеть время DOMContentLoaded и общее время загрузки.
Чтобы его отобразить, выбираем панель Network и нажимаем Ctrl + R для обновления страницы.
Появится синяя линия для DOMContentLoaded и красная — для общего времени загрузки. Обычно
всё, что находится справа от синей линии или касается её, — это данные, которые блокируют DOM.
Они называются ресурсами блокировки рендеринга.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/54.jpg?raw=true">

### Режим диафильма

Функция захвата скриншотов позволяет видеть, как страница отображается от начала до конца. Она
создаёт скриншоты в процессе загрузки. Это отличный способ увидеть, как рендерится страница в
браузере при загрузке

Для этого кликаем на панель Network, открываем настройки, включаем Capture screenshots и
нажимаем клавиши Ctrl + R для обновления страницы. Затем панель покажет, как страница
отображается в процессе загрузки.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/55.jpg?raw=true">

### Фильтры

Раздел фильтров позволяет показывать только элементы, удовлетворяющие определённым
условиям.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/56.jpg?raw=true">

В инструментах разработчика есть набор предустановленных фильтров для быстрой фильтрации
элементов определённых типов:

1. All — все элементы, без фильтрации.
2. XHR (XMLHttpRequest) — запросы к серверу из JavaScript-кода.
3. JS — только файлы JavaScript (*.js).
4. CSS — только файлы стилей (*.css).
5. Img — только изображения: JPEG, GIF, PNG, SVG и другие.
6. Media — аудио- и видеоматериалы.
7. Font — шрифты.
8. Doc — документы, под которыми обычно подразумеваются сами HTML-страницы (text/html).
9. WS (WebSocket) — запросы по технологии веб-сокетов. Могут быть, например, в чатах.
10. Manifest — файлы манифеста. Специальные файлы для настройки отображения сайта на
мобильных устройствах.
11. Other — остальное.

В поле Filter можно вводить специальные строки, чтобы отфильтровать результаты по конкретному
запросу, например, Is:running — для просмотра всё ещё выполняющихся на странице запросов,
larger-than:1024 — для просмотра ресурсов размером более 1024 байт, status-code:200 — для
просмотра всех успешно загруженных ресурсов.

Можно использовать несколько свойств одновременно, разделяя их пробелами. Например,
mime-type:image/gif larger-than:1K отображает все GIF-файлы, размер которых превышает один
килобайт. Эти фильтры с несколькими свойствами эквивалентны операциям «и». Операции «или» в
настоящее время не поддерживаются.

Все поддерживаемые свойства

1. domain: — отображать только ресурсы из указанного домена. Маска (*) используется для
отображения нескольких доменов. Например,* .com отображает ресурсы со всех доменов,
заканчивающихся на .com. DevTools автоматически подтягивает все домены, запрошенные
сайтом, и добавляет их в подсказки.
2. has-response-header: — показать ресурсы, которые содержат указанный HTTP-заголовок в
ответе.
3. is:running — позволяет найти ресурсы типа WebSocket.
4. larger-than: — показать ресурсы, размер которых превышает указанный размер в байтах.
Установка значения 1 000 эквивалентна установке значения 1k.
5. method: — показать ресурсы, которые получены с использованием указанного HTTP-метода:
GET, POST и так далее.
6. mime-type: — показать ресурсы с выбранным MIME-типом.
7. mixed-content: — показать все ресурсы со смешанным контентом (mixed-content: all) или
только те, что отображаются сейчас (mixed-content: display).
8. scheme: — показать ресурсы, полученные по HTTP (scheme:http) или HTTPS (scheme:https).
9. set-cookie-domain: — показать ресурсы, которые имеют заголовок Set-Cookie с указанным
доменом.
10. set-cookie-name: — показать ресурсы с заголовком Set-Cookie с именем, соответствующим
указанному значению.
11. set-cookie-value: — показать ресурсы, которые имеют заголовок Set-Cookie со значением,
соответствующее указанному в фильтре значению.
12. status-code: — отображать только те ресурсы, HTTP-код состояния которых соответствует
указанному коду: 200, 301, 404 и так далее.

#### Профили сети

Мы можем добавить настраиваемые профили сети. Это полезно, если надо протестировать свой
проект на определённой скорости загрузки:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/57.jpg?raw=true">

Чтобы добавить настраиваемый профиль, кликаем на панель Network и выбираем раскрывающийся
список Online. Затем кликаем на Custom — Add — Add custom profile и вводим название, скорость
скачивания и загрузки, задержку.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/58.jpg?raw=true">

#### Performance

Панель отображает таймлайн использования сети, выполнения JavaScript-кода и загрузки памяти.
После первоначального построения графиков таймлайна станут доступны подробные данные о
выполнении кода и обо всём жизненном цикле страницы. Можно будет ознакомиться со временем
исполнения отдельных частей кода, появится возможность выбрать отдельный промежуток на
временной шкале и ознакомиться с тем, какие процессы происходили в этот момент.

Инструмент применяется для улучшения производительности страницы в целом.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/59.jpg?raw=true">

Ключевые возможности

1. Возможность сделать запись, чтобы проанализировать каждое событие, которое произошло
после загрузки страницы или взаимодействия с пользователем.
2. Возможность просмотреть FPS, загрузку CPU и сетевые запросы в области Overview.
3. Возможность посмотреть детали по каждому событию.
4. Возможность изменить масштаб таймлайна, чтобы сделать анализ проще.

#### Memory

Панель «Память» в Chrome Developer Tools предоставляет информацию о том, как страница
использует память. Утечки памяти происходят, когда веб-сайт потребляет больше ресурсов, чем
необходимо. Серьёзные утечки памяти могут даже сделать сайты непригодными для использования.

Открыв вкладку Chrome Memory, мы познакомимся с тремя вариантами исследования по
использованию памяти веб-сайта:

1. Heap snapshot — распределение памяти по DOM.
2. Allocation instrumentation on timeline — выделение памяти в процессе загрузки страницы.
3. Allocation sampling — измерение выделенной памяти для «долгоиграющих» запросов.

Ключевые возможности

1. <a href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/">Исправление проблем с памятью.</a>
2. <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Профилирование CPU при работе с JavaScript.</a>

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/60.jpg?raw=true">

#### Application

Вкладка для инспектирования и очистки всех загруженных ресурсов, в том числе IndexedDB или
Web SQL баз данных, local и session storage, cookie, кеша приложения, изображений, шрифтов и
таблиц стилей

Ключевые возможности

1. Быстрая очистка хранилищ и кеша.
2. Инспектирование хранилищ, баз данных и кеша, управление ими.
3. Инспектирование и удаление файлов cookie.

#### Кеш браузера

У каждого браузера есть особая папка на жёстком диске, в которую сохраняются элементы
веб-страниц, запрашиваемых в браузере. К этим элементам относятся изображения, видео, стили,
скрипты и многое другое — в общем, всё, что нечасто меняется и часто имеет значительный объём.
При загрузке страницы браузер сбрасывает этот контент на жёсткий диск. Эта особая папка
называется кеш браузера, а сохранённые на диск данные — закешированными данными.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/61.jpg?raw=true">

В большинстве случаев кеш используется, чтобы ускорить загрузку страниц, которые мы уже
посещали. Если элементы сайта уже сохранились в кеше браузера, то при его повторном открытии
часть информации, что занимает большой объём, будет загружаться не из сети, а прямо из кеша
браузера (с компьютера). Такая страница откроется очень быстро.

Как правило, папка кеша содержится внутри папки текущего пользователя. Например, для Google
Chrome путь к кешу выглядит так:

>C:\Users\<Username>\AppData\Local\Google\Chrome\User Data\Default\Cache

А для Firefox — так:

>C:\Users\<Username>\AppData\Local\Mozilla\Firefox\Profiles\<Profile>\cache2

Кеш браузера — удобная и полезная вещь, но она имеет свои ограничения по использованию. При
активном интернет-сёрфинге кеш быстро увеличивается в размерах. Большой объём сохранённых
файлов начинает негативно влиять на производительность браузера. Многим пользователям
кажется, что компьютер тормозит и медленно обрабатывает запросы. Чтобы такого не было, кеш
требуется время от времени чистить.

У тестировщиков в повседневной работе возникают и другие проблемы, связанные с кешированием.
Если стили, изображения или скрипты закешированы, а разработчики внесли незначительные
изменения в код и выложили новую версию, есть вероятность, что браузер тестировщика будет
брать старую версию стилей, скриптов и изображений из кеша. А это создаст проблемы при
тестировании.

Как «почистить» кеш

Для Chrome:

1. Нажать кнопку «Меню» — «Дополнительно» — «Очистить историю» или Ctrl + Shift + Del.
2. В списке «Удалить записи» выбрать период, за который надо удалить кеш.
3. Включить опцию «Файлы, сохранённые в кеше».
4. Отключить остальные опции, если надо очистить только кеш браузера.
5. Нажать «Очистить».

Для Firefox:

1. Нажать кнопку «Меню» — «Настройки» — «Приватность и защита» — «История» — «Удалить
историю» или Ctrl + Shift + Del.
2. В списке «Удалить» выбрать период, за который надо удалить кеш.
3. Включить опцию «Кеш».
4. Отключить остальные опции, если надо очистить только кеш браузера.
5. Нажать «Удалить сейчас».

Кроме дискового кеша, есть и более «быстрый» кеш в оперативной памяти, где браузер также
временно хранит информацию об открытых страницах и загруженном контенте. Он очищается
довольно просто: надо закрыть браузер, дождаться завершения процесса и запустить его снова.

Также почистить кеш можно через панель Application → Cache. Например, наш пользователь
просматривал в гипермаркете электроники интересующие его позиции, страницы кешируются:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/62.jpg?raw=true">
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/63.jpg?raw=true">

Чтобы обновить содержимое закешированной страницы или удалить страницу из кеша, можно
выбрать в экшен меню или Refresh (обновить) или Delete (удалить) соответственно:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/64.jpg?raw=true">

### Cookie

HTTP-cookie — это небольшой фрагмент данных, отправляемых с веб-сайта и сохраняемых
браузером на пользовательском компьютере во время просмотра сайта. Cookie разработаны, чтобы
сайты:

надёжно запоминали информацию о состоянии, например, товары, добавленные в корзину
интернет-магазина;

или сохраняли информацию о действиях пользователя на сайте, включая нажатие на конкретные
кнопки, вход в систему или посещённые страницы;

запоминали информацию, которую пользователь ранее вводил в поля формы — имена, адреса,
пароли.

Cookie выполняют важные функции в современном интернете. Возможно, самая важная: cookie — это
наиболее распространённый метод, которым веб-серверы определяют, вошёл пользователь в
систему или нет, и если да, то с какой учётной записью. Без такого механизма сайт не знал бы,
отправлять ли страницы, содержащие конфиденциальную информацию, или требовать от
пользователя аутентификацию при входе в систему.

Безопасность cookie-аутентификации обычно зависит от безопасности сайта и браузера
пользователя, а также от того, зашифрованы ли данные cookie при передаче. Уязвимости в
безопасности приведут к тому, что хакер прочтёт cookie и использует их для получения доступа к
пользовательским данным или входа на сайт с учётными данными пользователя. Одна из самых
распространённых уязвимостей в веб-приложениях — межсайтовый скриптинг — завязана на
получении пользовательских cookie.

Cookie также используются для отслеживания действий пользователей на сайте. Как правило, это
требуется для сбора статистики, на основе которой рекламные компании формируют анонимные
профили пользователей для более точного таргетирования рекламы.

#### Типы cookie

**Сессионные cookie**

Сессионные (временные) cookie есть только в оперативной памяти и только пока пользователь
находится на сайте. Браузеры обычно удаляют сессионные cookie после закрытия окна браузера. В
отличие от других типов cookie, сессионные cookie не имеют истечения срока действия, и поэтому
браузеры понимают их как временные.

**Постоянные cookie**

Постоянные cookie-файлы удаляются в конкретную дату или через определённый промежуток
времени. Это означает, что информация о cookie будет передаваться на сервер каждый раз, когда
пользователь посещает веб-сайт, которому эти cookie принадлежат. Такие cookie иногда называются
следящими, поскольку рекламодатели обычно записывают с их помощью предпочтения
пользователя в течение долгого времени. Однако cookie используются и в «мирных» целях,
например, чтобы избежать повторного ввода данных при каждом посещении сайта.

**Сторонние cookie**

Как правило, атрибут домена cookie совпадает с доменом, отображаемым в адресной строке
браузера, однако сторонний cookie принадлежит не тому домену, который указан в адресной строке.
Такой тип файлов, как cookie обычно появляется, когда веб-страницы содержат контент с других
сайтов, например, рекламные баннеры. Это позволяет отслеживать историю посещений
пользователя, что часто используют рекламодатели для предоставления релевантной рекламы.
В качестве примера предположим, что пользователь посещает <www.example.org>. Этот веб-сайт
содержит рекламу от ad.tracking.com, которая при загрузке устанавливает файл cookie,
принадлежащий домену рекламы (ad.tracking.com). Затем пользователь посещает другой веб-сайт,
<www.foo.com>, который также содержит рекламу от ad.tracking.com, и устанавливает файл cookie,
принадлежащий этому домену (ad.tracking.com). В результате оба этих cookie отправятся
рекламодателю при загрузке их рекламы или посещении веб-сайта. Далее рекламодатель
использует эти cookie для создания истории просмотров пользователя на всех веб-сайтах, где
размещается реклама этого рекламодателя.

**Зомби-cookie**

Поскольку cookie можно легко удалить, программисты ищут способы идентифицировать
пользователей даже после полной очистки истории браузера. Одно из таких решений —
зомби-cookie — evercookie, или persistent cookie — не удаляемые или трудноудаляемые cookie,
которые восстанавливаются в браузере через JavaScript.
Это возможно потому, что для хранения cookie сайт одновременно использует все доступные
хранилища браузера — HTTP ETag, Session Storage, Local Storage, IndexedDB. В этот список также
входят хранилища приложений, таких как:

1. Flash Player (Local Shared Objects);
2. Microsoft Silverlight (Isolated Storage);
3. Java (Java persistence API).
Когда программа обнаруживает отсутствие в браузере cookie-файла, информация о котором есть в
других хранилищах, она тут же восстанавливает его на место, идентифицируя пользователя для
сайта.

#### Управление cookie

Работа с Cookie в DevTools позволяет добавлять, изменять и удалять cookie для каждого сайта.

**Подмена cookie**

Авторизуемся под логином user, паролем Password! на сайте <http://testingcourse.ru/docs/start> в
браузере Google Chrome. Скопируем полученные cookie и подставим их для авторизации на этом же
сайте только в другом браузере (те без фактической авторизации). Кстати, подобный метод
используют и злоумышленники: они похищают cookie через уязвимости на сайте или незащищённое
интернет-соединение.

Нам понадобится два браузера, например, Chrome и Firefox. Первоначальные условия: пользователь
не авторизован на портале ни в одном из браузеров

1. Открываем начальную страницу <http://testingcourse.ru/docs/start> в любом браузере,
например, Chrome.
2. Вводим логин user, пароль Password!.
3. Открываем инструменты разработчика, в них — вкладку с cookie.
4. Находим cookie с именем DW0b99b027724d9fff9b6347d01f4e2033 и DokuWiki и копируем их
значения (лучше сразу перейти к следующему шагу и копировать ключ и значение по
отдельности).
5. Открываем второй браузер, например, Firefox.
6. Во втором браузере также переходим на <http://testingcourse.ru/docs/start>.
7. Открываем инструменты разработчика во втором браузере, в них — вкладку с cookie.
8. Добавляем скопированные cookie по отдельности:

Chrome (где мы авторизовались по логину и паролю):
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/65.jpg?raw=true">

Mozilla (где мы не авторизованы):
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/66.jpg?raw=true">

После добавления в Mozilla значений будет примерно следующий вид:
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/67.jpg?raw=true">
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/68.jpg?raw=true">

9. Пользователь оказывается авторизован, хотя логин и пароль мы не вводили

Также управлять Cookie можно с помощью инструмента Edit This Cookie — это расширение для
браузеров Chrome, Yandex и Opera, которое позволяет изменять данные в этих файлах.

После установки расширения Edit This Cookie в интерфейсе браузера появится значок в виде
«печеньки», нажав на который появится доступ к функциям и настройкам. Чтобы посмотреть
куки-файлы, надо зайти на сайт, и при нажатии на значок «изменить этот файл Cookie» появится
окно, где отобразятся все активные файлы cookie.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/69.jpg?raw=true">

### Сессии

HTTP — stateless-протокол, то есть он не хранит информацию о предыдущем состоянии клиента или
сервера, об их актуальном статусе. Каждый HTTP-запрос обрабатывается как новый запрос,
соответственно, имеющимися средствами HTTP невозможно понять, идут ли запросы от одного
пользователя или разных, нельзя сохранить какие-либо данные между запросами. Поэтому для
длительного взаимодействия появился механизм сессий. Когда мы открываем сайт и отправляем
первый GET HTTP-запрос, сервер его обрабатывает и вместе с ответом передаёт конкретный
параметр — идентификатор сессии, который хранится на клиенте и в дальнейшем передаётся с
каждым запросом. Таким образом, сервер понимает, что запрос относится к той или иной сессии, и
не требует повторной авторизации

Существует два вида сессий: Local Storage и Session Storage.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/70.jpg?raw=true">

Session Storage похож на Local Storage, но разница в том, что для Local Storage срок действия данных
не истекает, данные Session Storage очищаются по завершении сеанса.

Можно выбрать требуемое значение и, например, поменять его:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/71.jpg?raw=true">

### Security

На вкладке можно ознакомиться с протоколом безопасности при его наличии и просмотреть данные
о сертификате безопасности, если он есть.

Инструмент используется для отладки проблем смешанного контента, проблем сертификатов и так
далее.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/72.jpg?raw=true">
Ключевые возможности

1. Окно Security Overview быстро подскажет, безопасна текущая страница или нет.
2. Есть возможность ознакомиться с отдельными источниками, чтобы:
    - просмотреть соединение и детали сертификата (для безопасных источников);
    - или узнать, какие запросы не защищаются (для небезопасных источников)

### Lighthouse

После выбора настроек и нажатия кнопки Generate report панель аудита анализирует, как
загружается страница, и затем предоставляет предложения по оптимизации для уменьшения
времени загрузки страницы и увеличения её отзывчивости.
<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/73.jpg?raw=true">

Анализируются такие параметры: кеширование ресурсов, gzip-сжатие, наличие неиспользуемых
частей JS-кода и CSS-правил и многое другое. Далее пользователю выводится сгруппированный
список рекомендаций, благодаря выполнению которых можно существенно оптимизировать
скорость загрузки и отзывчивость страницы.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img/DevTools/74.jpg?raw=true">
