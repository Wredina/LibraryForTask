# ТЕСТ-ДИЗАЙН И ТЕСТ-АНАЛИТИКА
# ТРЕБОВАНИЯ

**Требование** - описание функции и условий, которые выполняет приложение в процессе решения задачи. Это отправная точка для процесса разработки.

Тестировщик участвует в проверке и анальзе требований, находит неясности и противоречия, предоставляет отзыв о функциях и удобстве использования будущего приложения.

Требования создаёт заказчик, аналитик или технические специалисты на этапе
планирования.

**Задача требования** — зафиксировать ожидания заказчика о том, какой продукт
планируется разработать.

Как только появляются требования, может начинаться процесс тестирования.
Тестировщик участвует в проверке и анализе требований, находит неясности и
противоречия, предоставляет отзыв о функциях и об удобстве использования
будущего приложения.

## Классификация требований
По характеру требования делятся на функциональные и нефункциональные.

**Функциональные требования:**
- бизнес-требования;
- пользовательские требования;
- системные требования.

**Нефункциональные требования:**
- бизнес-правила;
- внешние интерфейсы;
- атрибуты качества.

### Функциональные требования
Отвечают на вопрос: «Что должна делать программа?». Например, показывать
прогноз погоды или воспроизводить видео.

**Бизнес-требования** — это обобщённое описание функций продукта без
технической детализации (например, без требований к аппаратному обеспечению).
Они отвечают на вопрос: «Какую потребность пользователя закроет ПО?».

_Пример:_ для привлечения новых клиентов надо разработать сайт с описанием
преимуществ компании «ОПТИМА КОНСАЛТИНГ ПЛЮС».

**Пользовательские требования** - описание задач, которые пользователь сможет
решить, используя приложение. Эти требования более детализированные, чем
бизнес-требования, но не содержат технических подробностей.

Пример:
1. Пользователь заходит на сайт и видит список услуг, которые предоставляет
компания «ОПТИМА КОНСАЛТИНГ ПЛЮС».
2. Пользователь может скачать прейскурант услуг.
3. Пользователь может оставить заявку на обратный звонок:
    - Заполнить ФИО.
    - Заполнить номер телефона.
    - Согласиться с обработкой персональных данных.

**Системные требования** — описание технической реализации программы, а также
требуемое программное и аппаратное окружение.

Пример:
1. Сайт разрабатывается на платформе WordPress.
2. Для хранения пользовательских данных используется БД MySQL.
3. Сайт должен открываться в браузерах Chrome, Firefox, Safari.

### Нефункциональные требования

Отвечают на вопрос: «Как должна работать программа?». Связаны с
нефункциональными видами тестирования, то есть относятся к быстродействию,
внешнему виду, удобству использования, локализации и другим подобным
критериям.

Примеры нефункциональных требований:
- время обработки пользовательского запроса не выше 100 миллисекунд;
- размер загружаемых файлов не выше 10 Мб;
- размер шрифта на странице — 14 pt.

К нефункциональным требованиям относятся бизнес-правила и внешние
интерфейсы.

**Бизнес-правила** определяют, почему система должна работать именно так. Это
ссылки на законодательство, внутренние правила заказчика и другие причины.

Пример: табачные компании требуют постоянного доказательства, что
промосайтами пользуются люди, достигшие 18 лет. Это бизнес-правило возникает
по требованию этических комитетов заказчика, хотя и несколько противоречит
маркетинговым целям.

**Внешние интерфейсы** — интерфейсы пользователя (макеты) и протоколы
взаимодействия с другими системами

*Пример:* сайт должен взаимодействовать с CRM по HTTP.

**Атрибуты качества:**
- лёгкость и простота использования;
- производительность;
- удобство эксплуатации и технического обслуживания;
- надёжность и устойчивость к сбоям;
- взаимодействия системы с внешним миром;
- расширяемость;
- требования к пользовательским и программным интерфейсам.

## Атрибуты требований

Чтобы требования считались корректными и давали разработчику и тестировщику
однозначные указания по работе приложения, они должны быть:

- атомарными
- полными;
- однозначными;
- непротиворечивыми;
- необходимыми;
- осуществимыми;
- тестируемыми.
___
### Атомарность
___
Требование нельзя разбить на отдельные части без потери деталей.

**Неправильно:**

Если пользователь оформляет заказ и
редактирует в нём товары или меняет
дату доставки, то выполняется запрос
на создание или редактирование
заказа.

*Запрос выполняется при комбинации
всех условий? Какой именно запрос в
каком случае должен выполниться?
Из-за объединения нескольких частей в
одно требование его трудно понять.*

**Правильно:**

Если пользователь оформляет заказ,
выполняется запрос на создание
заказа.

Если пользователь редактирует
товары в заказе, выполняется запрос
на редактирование заказа.

Если пользователь меняет дату
доставки заказа, выполняется запрос
на редактирование заказа.
___
### Полнота
___
Требования должны учитывать все возможные пользовательские действия,
входные параметры, сообщения об ошибках. Если требование неполное, в этом
месте возникают дефекты.

Лучший способ проверить требования на полноту — начать писать тесты. При
планировании проверок «белые пятна» станут очевидны.

**Неправильно:**
1. При регистрации пользователь
указывает дату рождения.
2. Если дата рождения указана, то
возраст указывается в анкете.

*А если дата не указана? Поле «Возраст»
пустое? Или не отображается вообще?
Обязательное ли поле даты рождения?*

**Правильно:**
1. При регистрации пользователь
указывает дату рождения, поле
необязательное.
2. Если дата рождения указана, то
возраст указывается в анкете.
3. Если пользователь не указал дату
рождения, то поле возраста
скрыто из анкеты
___
### Однозначность
___
Важно, чтобы требования не допускали двусмысленных формулировок. Все
требования, касающиеся субъективных параметров, например, скорости работы,
эстетики интерфейса и удобства использования, описываются в абсолютных
числах

**Неправильно:**

Требуется, чтобы страница
загружалась быстро

*Что значит «быстро»? Пять секунд —
это быстро или медленно? А если у
пользователя нестабильное
интернет-соединение?*

**Правильно:**

Страница должна загружаться не
более 5 секунд при стабильном
интернет-соединении.

___
### Непротиворечивость
___

Когда требований много, они противоречат сами себе. Например, поведение одного
и того же компонента описывается различными аналитиками в разных разделах
требований. И это поведение будет различаться.

**Пример**
1. Требуется, чтобы отчёт о продажах формировался за 5 секунд.
2. Формирование отчёта о продажах занимает около 15 минут.

*Какое требование считать верным?*

___
### Необходимость
___
Принцип составления документации: «Кратко, но ёмко». Важно, чтобы в ней было
всё необходимое, но без лишней детализации.

В **техническом задании** описывается инструментарий, основной сценарий и
альтернативы, типы ошибок.

В **пользовательской документации** описывается, как пользоваться системой, не
доходя до крайностей и обучения включению компьютера.
___
### Осуществимость
___

Важно, чтобы требования осуществлялись с учётом внутреннего устройства
программы и технологий, которые используются разработчиками.

**Пример:** требуется, чтобы отчёт о продажах за квартал агрегировал данные из пяти
таблиц и отображался на экране за одну секунду.

*Возможно, это требование невыполнимо, так как на выполнение запроса,
агрегацию данных и отрисовку на экране физически потребуется больше времени.*

___
### Тестируемость
___

Важно, чтобы у тестировщика была возможность проверить функциональность,
которую создал разработчик. Особенно это касается автотестов: может случиться,
что действующие библиотеки автоматизации не покроют новые функции, и их
придётся дорабатывать

**Пример:** 

Для регистрации пользователя требуется указать уникальный email.
1. Есть ли у тестировщика доступ к базе данных, в которой хранятся уже
зарегистрированные адреса?
2. Могут ли автотесты создавать уникальные адреса или проверять их
уникальность? Если нет, то требование становится не тестируемым.
___
## Дефекты в требованиях
___

Если требования не соответствуют атрибутам, значит, в них есть дефект. Дефекты
на требования заводятся при тестировании требований и сохраняются в
багтрекинговых системах, как и дефекты на функциональность.

**Пример:**

Требование: важно, чтобы группам выдавались проектные роли в
настройках проекта или в панели администрирования.

Требование неоднозначное — непонятно, где именно должны выдаваться
проектные роли: в настройках проекта, в панели администрирования или и там, и
там?

**Дефект на требование может выглядеть так:**
1. **Название.** Требование №1 — неоднозначное.
2. **Описание.** Непонятно, как именно выдаются проектные роли: в настройках
проекта, в панели администрирования или и там, и там?

В багах на требования не нужны шаги воспроизведения, ожидаемый и фактический
результат. Достаточно описать, какой атрибут не соблюдается.

Баги на требования сложно найти, просто прочитав документацию. Обычно они
обнаруживаются в процессе написания чек-листов или тест-кейсов. Поэтому лучше
начинать писать списки проверок сразу после получения документации: это ускорит
процесс создания тестовой документации и позволит найти требования как можно
быстрее.

Когда обнаружен баг в требовании (несоответствие атрибуту) и составлен
баг-репорт на это несоответствие, автор требований их правит, после чего
тестировщик перепроверяет требования и закрывает заведённый баг, если всё
исправлено. Или снова возвращает требование на доработку, если дефект остался

Один из популярных форматов оформления требований — пользовательские
истории и пользовательские сценарии.
___
## Форматы требований
___

Требования на проекте могут быть в разном виде:
- текст
- схематическое описание
- user story
- use case.

Вид требований на проекте определяет команда: с какими удобнее работать, те и
выбирают. Видов может быть несколько, чтобы они дополняли друг друга.

Давайте рассмотрим, как выглядят требования каждого из форматов:
___
### Текстовое описание
___
В тексте требований должна быть описана логика, внешний вид, допустимые и
недопустимые значения и так далее.

Формат удобный, но довольно сложный в составлении — легко упустить важные
детали, в требованиях часто встречаются баги.

Если функциональность меняется, могут быть сложности с актуализацией текста.

Пример текстового требования на раздел «Корзина»:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/basket.jpg?raw=true" alt="корзина">

Пример текстового требования раздела "Поиск":
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src.jpg?raw=true" alt="Поиск">
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src_no_internet.jpg?raw=true" alt="Поиск">

Тут уже отображено, что будет при потери интернет соединения.

Пример требования на весь проект - [foodbuzz](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit?usp=sharing)
___
### Схематичное описание
___
Описание функциональности представлено в виде схематичного изображения
требований из макетов с пояснениями и визуализацией переходов. Могут
использоваться таблицы, блок-схемы и так далее

Если нужно максимально полно описать функциональность, схематическое
описание может дополняться текстовым.

[Карта функциональности "Поиск"](https://miro.com/welcomeonboard/NjJ5NEw0UkdyZE8yZ1FOaGZWS3NiSmVvRno1bUZBSmdaQmN1Z3U4aHBydlg2elFTUENocFBQS0pvSUlDVVk2c3wzNDU4NzY0NTIzNjY0NTMwNzM2?share_link_id=282913234314)

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/map_function.jpg?raw=true" alt="карта поиска">

На схеме видно, как можно попасть в модальное окно "Поиск" для которого как рази с троится вся схема.

И уже когда открывается окно "Поиск" идёт первое ответвление: есть интернет соединение и нет интернет соединения.

Первым рассматривается позитивное развитие собитий и ввода валиднх данных, а потом уже негативных событий.
___
### User story — пользовательские истории
___
Пользовательские истории — способ описания требований к системе в одном или
нескольких предложениях. Для заказчиков (пользователей) пользовательские
истории — основной инструмент влияния на разработку программного
обеспечения.

Пользовательские истории — быстрый способ документировать требования клиента
без необходимости разрабатывать обширные формализованные документы и
тратить ресурсы на их поддержание. Цель пользовательских историй — оперативно
и без накладных затрат реагировать на быстро изменяющиеся требования
реального мира.

**Пользовательская история описывает:**
- человека, использующего систему (заказчик);
- то, что должно содержаться в этой системе (примечание);
- то, для чего она требуется пользователю (цель)

**Пример:**
1. Я как администратор хочу, чтобы в настройках проекта пользователям
выдавались проектные роли.
2. Я как тестировщик хочу присваивать автотестам лейблы.

<br>

Пользовательские истории — результат планирования. Они:
- определяют, что должно реализоваться в программе;
- приоритезируются клиентом по важности для системы;
- разбиваются на серию задач и оцениваются разработчиками.

___
### Use case — пользовательский сценарий
___

Пользовательский сценарий описывает взаимодействия участников, как правило,
пользователя и системы. Количество участников — от двух и больше. Пользователь
— человек или другая система. Оформляются в виде таблиц или диаграмм.

Сценарий — таблица:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/storys_table.jpg?raw=true" alt="сценарий-таблица">


Сценарий - диаграмма:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/storys_schema.jpg?raw=true" alt="сценарий-диаграмма">
Диаграмма написана с использованием нотации UML

[UML-диаграммы классов](https://prog-cpp.ru/uml-classes/)

Диаграмма пользовательских сценариев
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/peopole_story.jpg?raw=true" alt="пользовательские сценарии">

На ней обобщённо показано, какие участники вступают во
взаимодействия

**Пользовательские сценарии решают несколько задач:**
1. **Оценка трудоёмкость проекта** тем точнее, чем детальнее список предстоящих работ. Сценарии использования — первый этап разбивки системы на отдельные элементы. Каждый сценарий декомпозируется на основной или альтернативные потоки либо задачи, которые требуется выполнить программисту для реализации отдельного сценария.
2. **Планировка графика работ**. Когда определена трудоёмкость каждого сценария использования, менеджер устанавливает сроки работы над каждым из них. Таким образом, определяются вехи начала и окончания разработки и тестирования каждого сценария использования, процесс разработки становится прогнозируемым.
3. **Выявление пропущенных требований**. Когда заказчик озвучивает требования к будущей системе, он концентрируется на полезной функциональности и не упоминает «второстепенные вещи»: настройки системы или особенности управления учётными записями пользователей, хотя без них система не будет полноценно работать. Однако «второстепенные» функции могут потребовать больше времени, что серьёзно повлияет на планирование.

## Системы управления требованиями

Система управления требованиями (RMS, requirements management systems) — средство поддержки и автоматизации процесса работы с требованиями на протяжении всего жизненного цикла разработки программного продукта

Есть разные системы управления требованиями. 

[«10 Best Requirements Management Tools & Software Of 2022»](https://thedigitalprojectmanager.com/requirements-management-tools/)
___
### Задачи RMS
___
1. Хранение требований в одном месте.
2. Единое управление требованиями.
3. Повышение производительности труда благодаря контролю над
изменениями в требованиях и управлению ими.
4. Минимизация расходов и рисков благодаря оценке влияния происходящих
изменений.
5. Демонстрация соответствия требований благодаря полному отслеживанию
требований.
6. Сокращение объёма доработок и ускорение выхода на рынок благодаря
совместной работе с заинтересованными лицами.

Одна из самых популярных RMS систем — Confluence
___
#### Confluence
___
**Confluence** — внутренняя вики-система для организаций. Поможет создать единую
базу знаний. Написана на Java, разрабатывается компанией Atlassian.
Распространяется под проприетарной лицензией, бесплатна для некоммерческих
организаций и открытых проектов

Позволяет решать задачи:
1. Создание и хранение проектной и технической документации.
2. Создание и управление требованиями в более узком виде, чем RMS.
3. Экспорт и импорт документации (документов).
4. Создание связи (ссылок и меток) между документами.
5. Возможность комментирования и обсуждения требований и документации.
6. Возможность отслеживания версионности и внесения изменений, а также
сравнения разных версий документа.
7. Автоматические уведомления о внесении изменений в документах и
страницах, на которые подписаны.
8. Управление доступом к проектам.

[Confluence](https://www.atlassian.com/ru/software/confluence)

## Декомпозиция требований. Mind Map

Mind Map (диаграмма связей, интеллект-карта) — это способ представления и
хранения информации в виде некоторой схемы.

Когда нам в жизни нужно решить какую-то большую задачу (например, переехать),
мы разбиваем её на небольшие части: найти новое жилье, собрать вещи, сделать
уборку, перевезти вещи, разложить всё по местам.

Когда разработчик получает задачу на реализацию новой функциональности, он
также делит её на небольшие задачи: например, сверстать экран,
запрограммировать логику, поработать с API.

Так и при работе с требованиями — мы можем поделить большое описание
функциональности на мелкие части. Степень детализации будет зависеть от нужд
команды и предназначения такой декомпозиции. В результате тестировщик часто
составляет Mind Map (интеллект-карту) функциональности или всей системы.

Mind Map для переезда:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/mind_map.jpg?raw=true" alt="Mind Map">

Преимущества:
- структурированная информация;
- снижение риска пропустить дефекты за счёт наглядности;
- возможность проведения тестирования по интеллект-карте без тестовой
документации.

### Декомпозиция и создание Mind Map
___
#### Выделяем крупные блоки или компоненты
___
На этом этапе выделяем крупные модули или подсистемы программы, которые
могут существовать практически независимо друг от друга. На примере [Foodbuzz](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit)
- поиск;
- корзина;
- блог;
- баннер на главной странице;
- меню на сегодня
- и так далее.

Начнём создавать майнд-карту. В центр поместим главный объект — Foodbuzz. От
него пойдут ответвления — объекты первого уровня.

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/foodbuzz_mind_map.jpg?raw=true" alt="Mind Map foodbuzz">

___
#### Определяем страницы сайта или экраны мобильного приложения для блока
___

Рассмотрим раздел «Блог». Согласно [документации](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit), в этом разделе две страницы:

1. Наш блог
2. Страница опубликованного поста

Добавим их на майнд-карту.

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/block_mind_map.jpg?raw=true" alt="Mind Map foodbuzz block">

Иногда может быть так, что выделенный раздел в первом шаге слишком маленький,
но мы не можем объединить его с другим — в таком случае перейдём сразу к
третьему шагу и рассмотрим продолжение декомпозиции раздела «Блог» и
декомпозируем раздел «Поиск»

___
#### Содержание экранов
___

На экранах иногда появляются отдельные блоки с информацией, поля ввода,
кнопки, списки — всё, с чем взаимодействует или просто просматривает
пользователь.

На этом этапе декомпозиции важно отметить:
- элементы, расположенные на экране;
- действия, которые может совершить пользователь;
- параметры действий пользователя.

Добавляется также ожидаемое поведение системы. Главное, чтобы это не
перегружало карту. Делать это надо только в крайнем случае.

Рассмотрим экран «Наш блог». На нём есть:
- хедер,
- баннер,
- карточки постов,
- поиск по блогу,
- фильтр категорий,
- популярные посты,
- архив,
- наш Россграм,
- популярные теги,
- реклама,
- пагинация(нумерация страниц),
- футер.

Добавим всё это на нашу майнд-карту
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/our_block_mind_map.jpg?raw=true" alt="Mind Map foodbuzz block">

Проведем аналогичную последовательность действий для раздела «Поиск». Важно
учесть, что у раздела есть два разных состояния — работа с интернет-соединением
и работа без интернет-соединения. 

В итоге получаем такой вариант декомпозиции:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src_mind_map.jpg?raw=true" alt="Mind Map foodbuzz src internet">

Таким образом, майнд-карта заполняется до тех пор, пока не будут охвачены все
объекты. Третий уровень детализации — самый подробный, на нём важно ничего не
пропустить, так как майнд-карта станет основой для дальнейшего составления
чек-листов и тест-кейсов

Мы рассмотрели один из возможных вариантов декомпозиции требований и
составления майнд-карты. Можно выбрать другой подход и структуру майнд-карты:
при составлении ориентироваться на цель составления и тех, кто с ней будет
работать. Карта должна быть понятной и информативной для всех
заинтересованных лиц.

**Важно!** У элементов интерфейса интересные названия. Например, кнопки могут
называться:
- кнопка;
- radio button;
- burger menu;
- тоггл

Типы списков:
- чек-лист;
- аккордеон;
- select;
- dropdown.

Кроме бургеров и аккордеонов, на странице иногда появляются хлебные крошки,
карусели, маски и другое. Подробнее:
- [32 элемента User interface для UI-дизайнеров;](https://bool.dev/blog/detail/32-user-interface-elementov-dlya-ui-dizaynerov)
- [Элементы интерфейса сайта.](https://borodaboroda.com/blog/elementy-interfejsa-sajta/)

