# ТЕСТ-ДИЗАЙН И ТЕСТ-АНАЛИТИКА
# ТРЕБОВАНИЯ

**Требование** - описание функции и условий, которые выполняет приложение в процессе решения задачи. Это отправная точка для процесса разработки.

Тестировщик участвует в проверке и анальзе требований, находит неясности и противоречия, предоставляет отзыв о функциях и удобстве использования будущего приложения.

Требования создаёт заказчик, аналитик или технические специалисты на этапе
планирования.

**Задача требования** — зафиксировать ожидания заказчика о том, какой продукт
планируется разработать.

Как только появляются требования, может начинаться процесс тестирования.
Тестировщик участвует в проверке и анализе требований, находит неясности и
противоречия, предоставляет отзыв о функциях и об удобстве использования
будущего приложения.

## Классификация требований
По характеру требования делятся на функциональные и нефункциональные.

**Функциональные требования:**
- бизнес-требования;
- пользовательские требования;
- системные требования.

**Нефункциональные требования:**
- бизнес-правила;
- внешние интерфейсы;
- атрибуты качества.

### Функциональные требования
Отвечают на вопрос: «Что должна делать программа?». Например, показывать
прогноз погоды или воспроизводить видео.

**Бизнес-требования** — это обобщённое описание функций продукта без
технической детализации (например, без требований к аппаратному обеспечению).
Они отвечают на вопрос: «Какую потребность пользователя закроет ПО?».

_Пример:_ для привлечения новых клиентов надо разработать сайт с описанием
преимуществ компании «ОПТИМА КОНСАЛТИНГ ПЛЮС».

**Пользовательские требования** - описание задач, которые пользователь сможет
решить, используя приложение. Эти требования более детализированные, чем
бизнес-требования, но не содержат технических подробностей.

Пример:
1. Пользователь заходит на сайт и видит список услуг, которые предоставляет
компания «ОПТИМА КОНСАЛТИНГ ПЛЮС».
2. Пользователь может скачать прейскурант услуг.
3. Пользователь может оставить заявку на обратный звонок:
    - Заполнить ФИО.
    - Заполнить номер телефона.
    - Согласиться с обработкой персональных данных.

**Системные требования** — описание технической реализации программы, а также
требуемое программное и аппаратное окружение.

Пример:
1. Сайт разрабатывается на платформе WordPress.
2. Для хранения пользовательских данных используется БД MySQL.
3. Сайт должен открываться в браузерах Chrome, Firefox, Safari.

### Нефункциональные требования

Отвечают на вопрос: «Как должна работать программа?». Связаны с
нефункциональными видами тестирования, то есть относятся к быстродействию,
внешнему виду, удобству использования, локализации и другим подобным
критериям.

Примеры нефункциональных требований:
- время обработки пользовательского запроса не выше 100 миллисекунд;
- размер загружаемых файлов не выше 10 Мб;
- размер шрифта на странице — 14 pt.

К нефункциональным требованиям относятся бизнес-правила и внешние
интерфейсы.

**Бизнес-правила** определяют, почему система должна работать именно так. Это
ссылки на законодательство, внутренние правила заказчика и другие причины.

Пример: табачные компании требуют постоянного доказательства, что
промосайтами пользуются люди, достигшие 18 лет. Это бизнес-правило возникает
по требованию этических комитетов заказчика, хотя и несколько противоречит
маркетинговым целям.

**Внешние интерфейсы** — интерфейсы пользователя (макеты) и протоколы
взаимодействия с другими системами

*Пример:* сайт должен взаимодействовать с CRM по HTTP.

**Атрибуты качества:**
- лёгкость и простота использования;
- производительность;
- удобство эксплуатации и технического обслуживания;
- надёжность и устойчивость к сбоям;
- взаимодействия системы с внешним миром;
- расширяемость;
- требования к пользовательским и программным интерфейсам.

## Атрибуты требований

Чтобы требования считались корректными и давали разработчику и тестировщику
однозначные указания по работе приложения, они должны быть:

- атомарными
- полными;
- однозначными;
- непротиворечивыми;
- необходимыми;
- осуществимыми;
- тестируемыми.
___
### Атомарность
___
Требование нельзя разбить на отдельные части без потери деталей.

**Неправильно:**

Если пользователь оформляет заказ и
редактирует в нём товары или меняет
дату доставки, то выполняется запрос
на создание или редактирование
заказа.

*Запрос выполняется при комбинации
всех условий? Какой именно запрос в
каком случае должен выполниться?
Из-за объединения нескольких частей в
одно требование его трудно понять.*

**Правильно:**

Если пользователь оформляет заказ,
выполняется запрос на создание
заказа.

Если пользователь редактирует
товары в заказе, выполняется запрос
на редактирование заказа.

Если пользователь меняет дату
доставки заказа, выполняется запрос
на редактирование заказа.
___
### Полнота
___
Требования должны учитывать все возможные пользовательские действия,
входные параметры, сообщения об ошибках. Если требование неполное, в этом
месте возникают дефекты.

Лучший способ проверить требования на полноту — начать писать тесты. При
планировании проверок «белые пятна» станут очевидны.

**Неправильно:**
1. При регистрации пользователь
указывает дату рождения.
2. Если дата рождения указана, то
возраст указывается в анкете.

*А если дата не указана? Поле «Возраст»
пустое? Или не отображается вообще?
Обязательное ли поле даты рождения?*

**Правильно:**
1. При регистрации пользователь
указывает дату рождения, поле
необязательное.
2. Если дата рождения указана, то
возраст указывается в анкете.
3. Если пользователь не указал дату
рождения, то поле возраста
скрыто из анкеты
___
### Однозначность
___
Важно, чтобы требования не допускали двусмысленных формулировок. Все
требования, касающиеся субъективных параметров, например, скорости работы,
эстетики интерфейса и удобства использования, описываются в абсолютных
числах

**Неправильно:**

Требуется, чтобы страница
загружалась быстро

*Что значит «быстро»? Пять секунд —
это быстро или медленно? А если у
пользователя нестабильное
интернет-соединение?*

**Правильно:**

Страница должна загружаться не
более 5 секунд при стабильном
интернет-соединении.

___
### Непротиворечивость
___

Когда требований много, они противоречат сами себе. Например, поведение одного
и того же компонента описывается различными аналитиками в разных разделах
требований. И это поведение будет различаться.

**Пример**
1. Требуется, чтобы отчёт о продажах формировался за 5 секунд.
2. Формирование отчёта о продажах занимает около 15 минут.

*Какое требование считать верным?*

___
### Необходимость
___
Принцип составления документации: «Кратко, но ёмко». Важно, чтобы в ней было
всё необходимое, но без лишней детализации.

В **техническом задании** описывается инструментарий, основной сценарий и
альтернативы, типы ошибок.

В **пользовательской документации** описывается, как пользоваться системой, не
доходя до крайностей и обучения включению компьютера.
___
### Осуществимость
___

Важно, чтобы требования осуществлялись с учётом внутреннего устройства
программы и технологий, которые используются разработчиками.

**Пример:** требуется, чтобы отчёт о продажах за квартал агрегировал данные из пяти
таблиц и отображался на экране за одну секунду.

*Возможно, это требование невыполнимо, так как на выполнение запроса,
агрегацию данных и отрисовку на экране физически потребуется больше времени.*

___
### Тестируемость
___

Важно, чтобы у тестировщика была возможность проверить функциональность,
которую создал разработчик. Особенно это касается автотестов: может случиться,
что действующие библиотеки автоматизации не покроют новые функции, и их
придётся дорабатывать

**Пример:** 

Для регистрации пользователя требуется указать уникальный email.
1. Есть ли у тестировщика доступ к базе данных, в которой хранятся уже
зарегистрированные адреса?
2. Могут ли автотесты создавать уникальные адреса или проверять их
уникальность? Если нет, то требование становится не тестируемым.
___
## Дефекты в требованиях
___

Если требования не соответствуют атрибутам, значит, в них есть дефект. Дефекты
на требования заводятся при тестировании требований и сохраняются в
багтрекинговых системах, как и дефекты на функциональность.

**Пример:**

Требование: важно, чтобы группам выдавались проектные роли в
настройках проекта или в панели администрирования.

Требование неоднозначное — непонятно, где именно должны выдаваться
проектные роли: в настройках проекта, в панели администрирования или и там, и
там?

**Дефект на требование может выглядеть так:**
1. **Название.** Требование №1 — неоднозначное.
2. **Описание.** Непонятно, как именно выдаются проектные роли: в настройках
проекта, в панели администрирования или и там, и там?

В багах на требования не нужны шаги воспроизведения, ожидаемый и фактический
результат. Достаточно описать, какой атрибут не соблюдается.

Баги на требования сложно найти, просто прочитав документацию. Обычно они
обнаруживаются в процессе написания чек-листов или тест-кейсов. Поэтому лучше
начинать писать списки проверок сразу после получения документации: это ускорит
процесс создания тестовой документации и позволит найти требования как можно
быстрее.

Когда обнаружен баг в требовании (несоответствие атрибуту) и составлен
баг-репорт на это несоответствие, автор требований их правит, после чего
тестировщик перепроверяет требования и закрывает заведённый баг, если всё
исправлено. Или снова возвращает требование на доработку, если дефект остался

Один из популярных форматов оформления требований — пользовательские
истории и пользовательские сценарии.
___
## Форматы требований
___

Требования на проекте могут быть в разном виде:
- текст
- схематическое описание
- user story
- use case.

Вид требований на проекте определяет команда: с какими удобнее работать, те и
выбирают. Видов может быть несколько, чтобы они дополняли друг друга.

Давайте рассмотрим, как выглядят требования каждого из форматов:
___
### Текстовое описание
___
В тексте требований должна быть описана логика, внешний вид, допустимые и
недопустимые значения и так далее.

Формат удобный, но довольно сложный в составлении — легко упустить важные
детали, в требованиях часто встречаются баги.

Если функциональность меняется, могут быть сложности с актуализацией текста.

Пример текстового требования на раздел «Корзина»:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/basket.jpg?raw=true" alt="корзина">

Пример текстового требования раздела "Поиск":
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src.jpg?raw=true" alt="Поиск">
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src_no_internet.jpg?raw=true" alt="Поиск">

Тут уже отображено, что будет при потери интернет соединения.

Пример требования на весь проект - [foodbuzz](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit?usp=sharing)
___
### Схематичное описание
___
Описание функциональности представлено в виде схематичного изображения
требований из макетов с пояснениями и визуализацией переходов. Могут
использоваться таблицы, блок-схемы и так далее

Если нужно максимально полно описать функциональность, схематическое
описание может дополняться текстовым.

[Карта функциональности "Поиск"](https://miro.com/welcomeonboard/NjJ5NEw0UkdyZE8yZ1FOaGZWS3NiSmVvRno1bUZBSmdaQmN1Z3U4aHBydlg2elFTUENocFBQS0pvSUlDVVk2c3wzNDU4NzY0NTIzNjY0NTMwNzM2?share_link_id=282913234314)

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/map_function.jpg?raw=true" alt="карта поиска">

На схеме видно, как можно попасть в модальное окно "Поиск" для которого как рази с троится вся схема.

И уже когда открывается окно "Поиск" идёт первое ответвление: есть интернет соединение и нет интернет соединения.

Первым рассматривается позитивное развитие собитий и ввода валиднх данных, а потом уже негативных событий.
___
### User story — пользовательские истории
___
Пользовательские истории — способ описания требований к системе в одном или
нескольких предложениях. Для заказчиков (пользователей) пользовательские
истории — основной инструмент влияния на разработку программного
обеспечения.

Пользовательские истории — быстрый способ документировать требования клиента
без необходимости разрабатывать обширные формализованные документы и
тратить ресурсы на их поддержание. Цель пользовательских историй — оперативно
и без накладных затрат реагировать на быстро изменяющиеся требования
реального мира.

**Пользовательская история описывает:**
- человека, использующего систему (заказчик);
- то, что должно содержаться в этой системе (примечание);
- то, для чего она требуется пользователю (цель)

**Пример:**
1. Я как администратор хочу, чтобы в настройках проекта пользователям
выдавались проектные роли.
2. Я как тестировщик хочу присваивать автотестам лейблы.

<br>

Пользовательские истории — результат планирования. Они:
- определяют, что должно реализоваться в программе;
- приоритезируются клиентом по важности для системы;
- разбиваются на серию задач и оцениваются разработчиками.

___
### Use case — пользовательский сценарий
___

Пользовательский сценарий описывает взаимодействия участников, как правило,
пользователя и системы. Количество участников — от двух и больше. Пользователь
— человек или другая система. Оформляются в виде таблиц или диаграмм.

Сценарий — таблица:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/storys_table.jpg?raw=true" alt="сценарий-таблица">


Сценарий - диаграмма:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/storys_schema.jpg?raw=true" alt="сценарий-диаграмма">
Диаграмма написана с использованием нотации UML

[UML-диаграммы классов](https://prog-cpp.ru/uml-classes/)

Диаграмма пользовательских сценариев
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/peopole_story.jpg?raw=true" alt="пользовательские сценарии">

На ней обобщённо показано, какие участники вступают во
взаимодействия

**Пользовательские сценарии решают несколько задач:**
1. **Оценка трудоёмкость проекта** тем точнее, чем детальнее список предстоящих работ. Сценарии использования — первый этап разбивки системы на отдельные элементы. Каждый сценарий декомпозируется на основной или альтернативные потоки либо задачи, которые требуется выполнить программисту для реализации отдельного сценария.
2. **Планировка графика работ**. Когда определена трудоёмкость каждого сценария использования, менеджер устанавливает сроки работы над каждым из них. Таким образом, определяются вехи начала и окончания разработки и тестирования каждого сценария использования, процесс разработки становится прогнозируемым.
3. **Выявление пропущенных требований**. Когда заказчик озвучивает требования к будущей системе, он концентрируется на полезной функциональности и не упоминает «второстепенные вещи»: настройки системы или особенности управления учётными записями пользователей, хотя без них система не будет полноценно работать. Однако «второстепенные» функции могут потребовать больше времени, что серьёзно повлияет на планирование.

## Системы управления требованиями

Система управления требованиями (RMS, requirements management systems) — средство поддержки и автоматизации процесса работы с требованиями на протяжении всего жизненного цикла разработки программного продукта

Есть разные системы управления требованиями. 

[«10 Best Requirements Management Tools & Software Of 2022»](https://thedigitalprojectmanager.com/requirements-management-tools/)
___
### Задачи RMS
___
1. Хранение требований в одном месте.
2. Единое управление требованиями.
3. Повышение производительности труда благодаря контролю над
изменениями в требованиях и управлению ими.
4. Минимизация расходов и рисков благодаря оценке влияния происходящих
изменений.
5. Демонстрация соответствия требований благодаря полному отслеживанию
требований.
6. Сокращение объёма доработок и ускорение выхода на рынок благодаря
совместной работе с заинтересованными лицами.

Одна из самых популярных RMS систем — Confluence
___
#### Confluence
___
**Confluence** — внутренняя вики-система для организаций. Поможет создать единую
базу знаний. Написана на Java, разрабатывается компанией Atlassian.
Распространяется под проприетарной лицензией, бесплатна для некоммерческих
организаций и открытых проектов

Позволяет решать задачи:
1. Создание и хранение проектной и технической документации.
2. Создание и управление требованиями в более узком виде, чем RMS.
3. Экспорт и импорт документации (документов).
4. Создание связи (ссылок и меток) между документами.
5. Возможность комментирования и обсуждения требований и документации.
6. Возможность отслеживания версионности и внесения изменений, а также
сравнения разных версий документа.
7. Автоматические уведомления о внесении изменений в документах и
страницах, на которые подписаны.
8. Управление доступом к проектам.

[Confluence](https://www.atlassian.com/ru/software/confluence)

## Декомпозиция требований. Mind Map

Mind Map (диаграмма связей, интеллект-карта) — это способ представления и
хранения информации в виде некоторой схемы.

Когда нам в жизни нужно решить какую-то большую задачу (например, переехать),
мы разбиваем её на небольшие части: найти новое жилье, собрать вещи, сделать
уборку, перевезти вещи, разложить всё по местам.

Когда разработчик получает задачу на реализацию новой функциональности, он
также делит её на небольшие задачи: например, сверстать экран,
запрограммировать логику, поработать с API.

Так и при работе с требованиями — мы можем поделить большое описание
функциональности на мелкие части. Степень детализации будет зависеть от нужд
команды и предназначения такой декомпозиции. В результате тестировщик часто
составляет Mind Map (интеллект-карту) функциональности или всей системы.

Mind Map для переезда:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/mind_map.jpg?raw=true" alt="Mind Map">

Преимущества:
- структурированная информация;
- снижение риска пропустить дефекты за счёт наглядности;
- возможность проведения тестирования по интеллект-карте без тестовой
документации.

### Декомпозиция и создание Mind Map
___
#### Выделяем крупные блоки или компоненты
___
На этом этапе выделяем крупные модули или подсистемы программы, которые
могут существовать практически независимо друг от друга. На примере [Foodbuzz](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit)
- поиск;
- корзина;
- блог;
- баннер на главной странице;
- меню на сегодня
- и так далее.

Начнём создавать майнд-карту. В центр поместим главный объект — Foodbuzz. От
него пойдут ответвления — объекты первого уровня.

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/foodbuzz_mind_map.jpg?raw=true" alt="Mind Map foodbuzz">

___
#### Определяем страницы сайта или экраны мобильного приложения для блока
___

Рассмотрим раздел «Блог». 

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/fud_block_1.jpg?raw=true" alt="foodbuzz block 1">
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/fud_block_2.jpg?raw=true" alt="foodbuzz block 2">
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/fud_block_3.jpg?raw=true" alt="foodbuzz block 3">

Согласно [документации](https://docs.google.com/document/d/1-D5HPiVYN1fhEo_eEJVQ1kwkQ_NZd8scymr1YcY1qnA/edit), в этом разделе две страницы:

1. Наш блог
2. Страница опубликованного поста

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/food_block_elem.jpg?raw=true" alt="foodbuzz block elem 1">

<br>

Добавим их на майнд-карту.

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/block_mind_map.jpg?raw=true" alt="Mind Map foodbuzz block">

Иногда может быть так, что выделенный раздел в первом шаге слишком маленький,
но мы не можем объединить его с другим — в таком случае перейдём сразу к
третьему шагу и рассмотрим продолжение декомпозиции раздела «Блог» и
декомпозируем раздел «Поиск»

___
#### Содержание экранов
___

На экранах иногда появляются отдельные блоки с информацией, поля ввода,
кнопки, списки — всё, с чем взаимодействует или просто просматривает
пользователь.

На этом этапе декомпозиции важно отметить:
- элементы, расположенные на экране;
- действия, которые может совершить пользователь;
- параметры действий пользователя.

Добавляется также ожидаемое поведение системы. Главное, чтобы это не
перегружало карту. Делать это надо только в крайнем случае.

Рассмотрим экран «Наш блог». На нём есть:
- хедер,
- баннер,
- карточки постов,
- поиск по блогу,
- фильтр категорий,
- популярные посты,
- архив,
- наш Россграм,
- популярные теги,
- реклама,
- пагинация(нумерация страниц),
- футер.

<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/food_block_elem_2.jpg?raw=true" alt="foodbuzz block elem 2">

Добавим всё это на нашу майнд-карту
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/our_block_mind_map.jpg?raw=true" alt="Mind Map foodbuzz block">

Проведем аналогичную последовательность действий для раздела «Поиск». Важно
учесть, что у раздела есть два разных состояния — работа с интернет-соединением
и работа без интернет-соединения. 
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src.jpg?raw=true" alt="Поиск">
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src_no_internet.jpg?raw=true" alt="Поиск">

В итоге получаем такой вариант декомпозиции:
<image src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/src_mind_map.jpg?raw=true" alt="Mind Map foodbuzz src internet">

Таким образом, майнд-карта заполняется до тех пор, пока не будут охвачены все
объекты. Третий уровень детализации — самый подробный, на нём важно ничего не
пропустить, так как майнд-карта станет основой для дальнейшего составления
чек-листов и тест-кейсов

Мы рассмотрели один из возможных вариантов декомпозиции требований и
составления майнд-карты. Можно выбрать другой подход и структуру майнд-карты:
при составлении ориентироваться на цель составления и тех, кто с ней будет
работать. Карта должна быть понятной и информативной для всех
заинтересованных лиц.

**Важно!** У элементов интерфейса интересные названия. Например, кнопки могут
называться:
- кнопка;
- radio button;
- burger menu;
- тоггл

Типы списков:
- чек-лист;
- аккордеон;
- select;
- dropdown.

Кроме бургеров и аккордеонов, на странице иногда появляются хлебные крошки,
карусели, маски и другое. Подробнее:
- [32 элемента User interface для UI-дизайнеров;](https://bool.dev/blog/detail/32-user-interface-elementov-dlya-ui-dizaynerov)
- [Элементы интерфейса сайта.](https://borodaboroda.com/blog/elementy-interfejsa-sajta/)

# Глоссарий по Требованиям

**Бизнес-правила** — принципы, которые определяют, почему система должна
работать именно так: ссылки на законодательство, внутренние правила заказчика и
прочие причины.

**Бизнес-требования** — обобщённое описание функций продукта без технической
детализации. Отвечают на вопрос: «Какую потребность пользователя закроет ПО?».

**Внешние интерфейсы** — интерфейсы пользователя (макеты) и протоколы
взаимодействия с другими системами

**Требование** — описание функций и условий, выполняемых приложением в процессе
решения задачи. Это отправная точка для процесса разработки.

**Пользовательские истории** — способ описания требований к системе одним или
несколькими предложениями. Пользовательская история описывает:
- человека, использующего систему (заказчик);
- то, что содержится в этой системе (примечание);
- то, для чего она требуется пользователю (цель).

**Пользовательские требования** — описание задач, которые сможет решить
пользователь, используя приложение. Эти требования более детализированные,
чем бизнес-требования, но не содержат технических подробностей.

**Пользовательский сценарий** — описание взаимодействия участников, как правило,
пользователя и системы. Количество участников — от 2 и больше. Пользователь —
человек или другая система.

**Система управления требованиями (RMS, requirements management systems)** —
средства поддержки и автоматизации процесса работы с требованиями на
протяжении всего жизненного цикла разработки программного продукта.

**Системные требования** — описание технической реализации программы, а также
требуемое программное и аппаратное окружение.


# ТЕСТ - ДИЗАЙН

**Тест-дизайн** — это этап тестирования ПО, на котором проектируют и создают
тест-кейсы.

Допустим, есть задача: протестировать простейшую форму регистрации с двумя
полями: логином и паролем. Сколько тестов нужно, чтобы установить уровень
качества функциональности?

Можно предположить, что два:
- позитивный сценарий (логин test, пароль test1!);
- негативный сценарий (логин и пароль не заполнены).

Но что будет, если:
- логин уже занят;
- в логине есть спецсимволы */%;
- в логине есть пробелы;
- пароль состоит из одного символа.

А сколько ещё внештатных ситуаций может быть? Как покрыть их тест-кейсами?

Один из принципов тестирования: Исчерпывающее тестирование невозможно.

Полное тестирование с использованием всех комбинаций вводов и предусловий
невыполнимо, кроме тривиальных случаев. Вместо исчерпывающего тестирования
используется анализ рисков и расстановка приоритетов, чтобы точнее
сфокусировать усилия по тестированию.

При этом надо протестировать достаточно хорошо. Поэтому есть правила
составления тестов и подбора тестовых данных. Они вырабатывались на
протяжении всего существования IT-отрасли и сейчас представляют собой набор лучших практик, которых придерживается хороший тестировщик. Их соблюдение
гарантирует оптимальный охват тестируемой функциональности, при котором
бо́льшая часть дефектов будет обнаружена и не дойдёт до пользователя. Такие
правила называются техниками тест-дизайна.

Распространённые техники:
- Классы эквивалентности (эквивалентное разделение).
- Граничные значения (анализ граничных значений, метод граничных
значений).
- Попарное тестирование (тестовая комбинаторика, Pairwise).
- Тестирование состояний и переходов.
- Таблицы принятия решений.
- Исследовательское тестирование.

Техники тест-дизайна позволяют значительно сократить количество тестов. Они
концентрируются на уязвимых и важных участках функционала, не жертвуя при
этом качеством.

На этом уроке мы разберёмся с первой техникой — классами эквивалентности.

## Классы эквивалентности

Класс эквивалентности — набор входных значений, каждое из которых одинаково
обрабатывается и приводит к одному результату. У значений внутри класса одни
признаки, что приводит к их идентичной обработке.

### Пример: уровень шума домашних животных

Рассмотрим классы эквивалентности на примере домашних животных — кошек и
попугаев. Конечно, мир природы разнообразнее, чем программное обеспечение,
поэтому будем упрощать.

У всех кошек есть общие признаки:
- мурчат, когда их чешут за ушком;
- любят охотиться;
- делают тыгыдык по ночам.

У попугаев другие общие признаки:
- умеют летать;
- могут научится разговаривать;
- умеют петь.

Все кошки составляют один класс эквивалентности, а попугаи — другой. Любая
кошка будет мурчать, но не сможет летать. Любой попугай может петь, но не
охотится по ночам.

Допустим, перед нами стоит задача измерить уровень шума от разных домашних
животных. Зная, что все кошки и все попугаи производят примерно одинаковые
звуки, нам не придётся исследовать всех кошек и всех попугаев на планете.
Достаточно взять одну любую кошку и одного любого попугая, чтобы измерить их
уровень шума и с большой долей вероятности получить корректные результаты.

### Пример: найм на работу

В требованиях о найме у HR-отдела есть условие, которое автоматически
распределяет резюме кандидатов в разные категории:

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/table_res.jpg?raw=true" alt = "таблица условий кандидатов">

Как это могло бы выглядеть в коде приложения

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/code_res.jpg?raw=true" alt = "код условий кандидатов">

Если проводить исчерпывающее тестирование и проверять все варианты,
количество тестов составит минимум 100 (без учёта проверок отрицательных значений, значений больше 99, символов, пустого ввода и прочего). 

Выполнить их
невозможно, поэтому нужно:

1. Разделить данные на классы эквивалентности.
2. Выбрать хотя бы одно значение из каждого класса эквивалентности для
проверки.

<br>

Получаем следующие проверки:
- 1-й класс эквивалентности — 0 лет;
- 2-й класс эквивалентности — 16 лет;
- 3-й класс эквивалентности — 18 лет;
- 4-й класс эквивалентности — 65 лет.

Из каждого класса эквивалентности мы выбрали значения, чтобы сократить
количество тестов (теперь их 4 вместо 100). Любые другие значения из класса
эквивалентности должны давать те же результаты, что и выбранные.

*Если известно, что есть группа данных, использование
которых приводит систему в одно и то же состояние,
нет необходимости проверять каждое значение из этой группы отдельно.
Исключения возможны, но мы не можем проверять все данные,
поэтому приходится прибегать к подобным допущениям.*

Выделяют два вида классов эквивалентности:

- **линейные** (упорядоченные) — значения можно упорядочить и расположить
на шкале. У линейных классов эквивалентности всегда есть границы, где
заканчивается один класс и начинается другой. Границы могут входить в
класс, а могут быть самостоятельными единицами.
- **нелинейные** (неупорядоченные) — значения нельзя упорядочить, граничных
значений нет.

**Тестирование на основе классов эквивалентности** — техника тест-дизайна на
основе метода чёрного ящика, в ходе которой все данные делятся на классы эквивалентности, и затем тестирование проводится на одном значении из этого
класса.

Тестирование на основе классов эквивалентности основано на двух
умозаключениях:
1. Если одно значение из класса выявит ошибку, остальные, скорее всего, тоже
это сделают.
2. Если одно значение из класса не выявит ошибку, остальные, скорее всего,
тоже этого не сделают

*Исчерпывающее тестирование невозможно,
и есть вероятность, что отдельные значения в классе
эквивалентности поведут себя не так, как остальные.
Поэтому в описаниях часто встречаются комментарии
«скорее всего», «с большой долей вероятности».*

На классы эквивалентности можно разбить:

- **символы** — они могут быть валидными (@ в адресе электронной почты) и
невалидными (?, %,*);
- **длину строки** — например, валидный класс от 1 до 30 знаков, невалидный —
всё остальное (меньше 1 и больше 30);
- **объём памяти**, который необходим приложению для стабильной работы;
- **разрешение экрана** — всё, что меньше или больше заявленных требований к
разрешению экрана, будет относиться к невалидным классам;
- **версии операционных систем, библиотек** — также определяются согласно
требованиям. Например, приложение должно работать на ОС Windows 7, но
поддержка Windows Nt уже не требуется.
- **объём передаваемых данных** — по требованиям. Например, если мощности
сервера не позволяют обработать объём данных больше определённого
значения.

## Алгоритм работы с классами эквивалентности

1. На основе анализа нужно выбрать параметры, которые влияют на результат.
2. Для каждого параметра выделить классы эквивалентности.
3. Из каждого класса эквивалентности выбрать одно значение.
4. Обработать выбранные значение в соответствии с pairwise при
необходимости.

### Пример 1: отмена авиабилетов

Требование на фичу «Отмена авиабилетов»

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/avia_cancel.jpg?raw=true" alt = "отмена авиабилетов">

Подсчёт комиссии при отмене бронирования авиабилетов производится в
зависимости от времени отмены на следующих условиях:
- за 5 суток до вылета комиссия составляет 0% от стоимости билета;
- меньше 5 суток, но больше 24 часов — 50% от стоимости билета;
- меньше 24 часов, но до вылета рейса — 75% от стоимости билета;
- после вылета рейса — 100% от стоимости билета.

Сначала определим классы эквивалентности:
- 1-й класс эквивалентности: время до вылета > 5 суток;
- 2-й класс эквивалентности: 5 суток => время до вылета > 24 часа;
- 3-й класс эквивалентности: 24 часа => время до вылета > 0 часов;
- 4-й класс эквивалентности: время до вылета < 0 часов (рейс уже вылетел).

Затем из каждого класса эквивалентности выберем одно значение:

- 1-й класс эквивалентности = 10 суток до вылета;
- 2-й класс эквивалентности = 3 суток до вылета;
- 3-й класс эквивалентности = 12 часов до вылета;
- 4-й класс эквивалентности = 30 минут после вылета.

В результате получим следующие тесты:

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/avia_table.jpg?raw=true" alt = "тесты отмены">

В примерах выше были данные, которые можно расположить на числовой прямой —
их классы эквивалентности будут линейными. Такие классы можно разбить на
диапазоны с точными границами начала и конца (от 0 до 15, от 16 до 18 и далее).

Есть и нелинейные классы эквивалентности — это набор неупорядоченных данных,
которые не имеют границ и являются частью множества данных. Пример —
расширения файлов, операционные системы, группы пользователей с различными
правами (например, пользователь, модератор, администратор) и так далее. В этом
случае можно выделить только два класса эквивалентности:

- валидный — соответствует требованиям,
- невалидный — не соответствует требованиям или обрабатывается системой
отличным от валидного класса образом.

### Пример 2: знаки зодиака

User Story: Я как пользователь хочу определить свой знак зодиака по дате
рождения.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/zodiak_form.jpg?raw=true" alt = "знак зодиака">

Пользовательский сценарий:

**Пользователь:** заходит на страницу

**Пользователь:** заполняет день, месяц и год рождения

**Пользователь:** нажимает кнопку «Узнать»

**Система**: проверяет, что значение поля «Месяц» от 1 до 12

**Система:** проверяет значение поля «День»

**Система:** проверяет значение поля «Год» — високосный или нет

- от 1 до 28, если Месяц = 2 и год не високосный
- от 1 до 29, если Месяц = 2 и год високосный
- от 1 до 30, если Месяц = 4, 6, 9, 11
- от 1 до 31, если Месяц = 1, 3, 5, 7, 8, 10, 12

*Дата корректная*

**Система**: показывает знак зодиака, соответствующий дате.

*Дата некорректная*

**Система**: показывает сообщение «Указанная дата не существует»

Естественно, мы не будем тратить время и проверять каждый день в году, а
воспользуемся техникой классов эквивалентности. Сначала рассмотрим
позитивный сценарий, когда пользователь ввёл существующую валидную дату
(например, 31.03.2000). Код конвертирует дату в порядковый номер дня в году.

Какие классы эквивалентности можно выделить? Поскольку знаков зодиака 12, то
и классов эквивалентности будет столько же — по одному на каждый знак.
Присвоим каждому дню года порядковый номер, где 1 — это 1 января, а 365 — это
31 декабря (рассмотрим невисокосный год). Получим следующие классы:

1. 1-20 — козерог
2. 21-50 — водолей
3. 51-79 — рыбы
4. 80-110 — овен
5. 111-141 — телец
6. 142-172 — близнецы
7. 173-203 — рак
8. 204-233 — лев
9. 234-266 — дева
10. 267-296 — весы
11. 297-326 — скорпион
12. 327-356 — стрелец
13. 357-365 — козерог

Из-за того, что гороскоп не совпадает с календарным годом, получилось не 12, а 13
классов. Теперь для тестирования достаточно взять по одному значению из каждого
интервала и проверить его. Например, если мы укажем 30-й день года (30 января),
то результат будет «водолей». Получается, для минимального тестового покрытия
нам понадобится 13 тестов.

Рассмотрим альтернативный сценарий — пользователь ввёл невалидную дату.
Ожидаем получить сообщение о неверно введенных датах или (в случае с
несуществующими 32 числом и 14 месяцем) невозможность ввода. Возможны
несколько вариантов:

- 29.02.2001 (год невисокосный, 29 февраля в нём нет)
- 32.03.2000 (32 числа нет ни в одном месяце)
- 31.04.1999 (31 число бывает, но не в апреле)
- 25.14.1995 (нет 14 месяца)
- 00.00.0000 (если речь о цифрах, нули проверяем с особым пристрастием)

Можно проявить воображение и придумать ещё больше негативных проверок.
Таким образом, для тестирования простейшей странички нам понадобится
минимум 18 тестов. Так как эти классы эквивалентности линейны, у них есть
границы. Это элементы повышенного риска, и их тестирование мы рассмотрим в
теме «Доменный анализ». Это ещё немного увеличит наш список необходимых
проверок.

### Пример 3: загрузка фото

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/photo_add.jpg?raw=true" alt = "добавление фото">

На скриншоте видим — валидными форматами будут только JPG и PNG, можно
загрузить до 10 фото, максимальный размер фото — 25 MB. Определим параметры и
классы эквивалентности для каждого из них.

Получается три параметра:
- формат изображения;
- количество загружаемых фото;
- размер фото.

Составим для них классы эквивалентности. Обратите внимание, что фотографии —
обязательное поле (есть звёздочка), поэтому мы не можем оставить его пустым.

Также учтём, что количество фото и размер не могут быть отрицательными.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/photo_table_size.jpg?raw=true" alt = "таблица валидных данных">

Теперь выделим среди классов невалидные — то есть те, из-за которых будет
невозможно загрузить фото

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2/photo_no_valid.jpg?raw=true" alt = "таблица не валидных данных">

Для тестирования достаточно взять по одному значению из каждого класса:
получим 4 позитивных и 5 негативных проверок.

# Глоссарий
Тест-дизайн — этап тестирования ПО, на котором проектируют и создают
тест-кейсы.
Класс эквивалентности — набор входных значений, каждое из которых
обрабатывается одинаково и приводит к одному результату


# ПОПАРНОЕ ТЕСТИРОВАНИЕ (pairwise)

ISTQB (Международная квалификационная комиссия по тестированию
программного обеспечения) определяет попарное тестирование как технику
тест-дизайна методом чёрного ящика. Проверки создаются так, чтобы выполнить
все возможные комбинации каждой пары входных параметров.

Результат работы системы зависит от многих факторов. Часто — от комбинации
разных входных параметров. Например, в системе есть фильтр из нескольких
параметров, по результату сочетаний которых будет получен определённый
результат. Если параметров много, на тестирование всех возможных сочетаний
уйдёт много времени.

Большинство дефектов возникает при комбинации только двух параметров.
Поэтому для создания оптимального покрытия проверками функционала с большим
количеством входных параметров генерируются их определённые комбинации

Тесты разрабатываются таким образом, что для каждой пары входных параметров
существуют все возможные комбинации этих пар.

Pairwise не обеспечивает исчерпывающее тестирование,
но эффективен для поиска ошибок.

## Пример: прогноз погоды

User story: Я как пользователь хочу узнать прогноз погоды в указанном городе с
нужной степенью детализации.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather.jpg?raw=true" alt = "макет настроек погоды">

<br>

**Пользовательский сценарий:**
___
**Пользователь**: заходит на сайт

**Пользователь**: выбирает город из списка

**Пользователь:** выбирает язык (по умолчанию выбран русский)

**Пользователь**: выбирает детализацию по осадкам (по умолчанию выключено)

**Пользователь**: выбирает детализацию по времени (по умолчанию по дням)

**Система:** показывает пользователю прогноз в соответствии с указанными
значениями
___
<br>

Также известно, что используется три алгоритма расчёта прогноза.

1. Для городов федерального значения (Москва, Санкт-Петербург, Севастополь)
2. Для городов областного, республиканского, краевого, окружного значения
(Волгоград, Казань, Краснодар)
3. Для городов районного значения (Бологое, Суоярви)

Выделим классы эквивалентности для всех параметров

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table.jpg?raw=true" alt = "классы эквивалентности">

Сколько нужно тестов для прогноза погоды? Если протестировать все возможные
варианты комбинаций параметров, получится 3 * 2 * 2 * 2 = 24 теста. Довольно много и бессмысленно — количество тестов можно сократить техникой pairwise
(попарным тестированием).

Так как большинство дефектов возникают при комбинации только двух параметров,
нет смысла проверять все возможные сочетания. Если ошибка возникнет в
сочетании «Москва» + «Русский», вероятнее всего, она будет возникать и в
различных значениях детализации по осадкам, и со всем детализациями по
времени. Такой подход позволяет сократить количество проверок.

Создадим попарные наборы для фильтра прогноза погоды

Сначала создадим таблицу из 24 строк со всеми возможными комбинациями.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_24.jpg?raw=true" alt = "таблица с 1 по 19">
<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_24_2.jpg?raw=true" alt = "таблица с 20 по 24">

А теперь попробуем создать таблицу таким образом, чтобы перебрать все
возможные комбинации каждой пары параметров. Начнем с пары «Город — Язык».
Остальные ячейки пока заполнять не будем

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_city_l.jpg?raw=true" alt = "комбинация город - язык">

Теперь заполним колонку «Осадки», чтобы перебрать все возможные пары «Город —
Осадки»

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_city_re.jpg?raw=true" alt = "комбинация город - осадки">

Далее проверим пару «Язык — Осадки». Видим, что у нас есть пары «Русский — Да»
и «Английский — Нет», но не хватает пары «Русский — Нет», «Английский — Да». Это
легко исправить: просто поменяем местами значения осадков в строке 1 и 2. Теперь
у нас есть все возможные варианты пары «Язык — Осадки».

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_l_re.jpg?raw=true" alt = "комбинация язык - осадки">

Аналогично заполняем колонку «Детализация». Сначала сопоставляем её с
городом, затем проверяем, чтобы были все пары «Язык — Детализация», «Осадки —
Детализация» и при необходимости меняем значения в строках местами (но
следим, чтобы не разрушались нужные пары).

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/weather_table_det.jpg?raw=true" alt = "детализация">

Готово! Вместо 24 тестов осталось всего 6. Это в 4 раза сократит время на
тестирование.

Pairwise используется только для неупорядоченных классов эквивалентности. Для
упорядоченных классов эта техника может дать слишком много проверок на
выходе, так как нужно учитывать значения внутри класса и на границах.

## PICT и другие инструменты

Составлять таблицы попарного тестирования вручную долго и есть риск ошибок.
Можно использовать специальные программы, которые сами составляют таблицы
из исходных параметров:

- [pairwiseTool](https://pairwise.teremokgames.com/)
- [Pairwise Pict Online](https://pairwise.yuuniworks.com/)

Рассмотрим составление таблицы в pairwiseTool. Создадим колонки с нужными
значениями и нажмём Generate Pairwise:

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/pairw_tool_gen.jpg?raw=true" alt = "pairwiseTool">

В итоге получится файл, похожий на то, что мы сделали сами:

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/pairw_tool_table.jpg?raw=true" alt = "pairwiseTool файл">

Обратите внимание, программа сгенерировала 7 строк, а не 6, как мы вручную.
Почему так получилось? Дело в том, что в идеале матрица должна быть
сбалансирована. Это значит, что если какая-то пара значений двух столбцов
встречается несколько раз, то все возможные парные комбинации значений этих
столбцов должны встретится столько же раз. Матрица, составленная вручную, не
сбалансирована, так как пара «Английский — Нет» встречается 2 раза, а
«Английский — Да» — 1 раз.

## Pairwise и негативное тестирование

Составляя тестовые наборы для попарного тестирования, никогда не учитываются
негативные сценарии, то есть те, которые способны привести к ошибке или
невозможности обработать указанные значения. В случае с прогнозом погоды —
оставить пустым значение поля «Город».

Нужно ли добавлять еще одну строку «Поле незаполнено» в генератор pairwise?
Нет. Невалидные значения никогда не комбинируются друг с другом, так как если в
тесте будет два или более невалидных параметра, тестировщик не установит
причину возникновения ошибки.

Проверки с невалидными данными добавляются в таблицу по принципу «один
невалидный параметр в строке». Остальные параметры могут быть любыми
валидными.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/negative.jpg?raw=true" alt = "негативные строки">

### Пример: окружение для кроссбраузерного тестирования

В требованиях прописаны следующие характеристики окружения:
- сайт поддерживается в браузерах последних версий: Chrome, FireFox, Safari;
- сайт локализован на русском и английском языках;
- поддерживаются разрешения экранов: 1920x1080, 1536x864, 1440х900,
1366x768, 1280х720.

При составлении попарных комбинаций лучше начинать с параметра, у которого
больше всего вариантов значений. В нашем примере это «Разрешение». После него
по количеству значений следует параметр «Браузер»

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/size_table.jpg?raw=true" alt = "разрешение и браузеры">

Получили необходимые и возможные комбинации параметров «Разрешение» и
«Браузер». Теперь добавляем сюда параметр «Локализации». Важно, чтобы каждый
браузер хотя бы раз пересекался с каждым языком, и каждое разрешение также
хотя бы раз пересекалось с каждым языком.

В результате получим:
<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/size_table_loc.jpg?raw=true" alt = "добавление локализации">
<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/pairwise/size_table_loc_2.jpg?raw=true" alt = "добавление локализации_2">

Обратите внимание на языки в последнем разрешении — мы их поменяли местами,
чтобы у каждого браузера были комбинации с каждым из языков.
Набор окружений готов — учтены все возможные попарные комбинации каждых
двух параметров!

# Глоссарий

**Попарное тестирование (pairwise)** — техника подбора тестовых данных, основанная
на утверждении, что большинство дефектов возникают при комбинации только
двух параметров

# Граничный значения и доменный анализ

Пример про знаки зодиака:
1. 1-20 — козерог
2. 21-50 — водолей
3. 51-79 — рыбы
4. ...
5. 357-365 — козерог

Код, который написал программист для решения задачи, мог бы выглядеть так:

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/line.jpg?raw=true" alt = "код">

Если внимательно посмотреть на него, можно найти ошибку в условии else if
(dayOfYear > 21 && dayOfYear <= 50). Программист использовал знак > вместо >=.
Следовательно, если пользователь укажет дату рождения 21.01, программа не
сможет определить его знак. Это дефект в программе

Значения, которые разделяют линейные классы эквивалентности, называются
граничными. Это элементы повышенного риска, поэтому требуют пристального
внимания тестировщика.

Помимо границ, тестировать нужно и приграничные значения, которые лежат
максимально близко слева и справа от границы.

**Как определить ближайшее значение?** 

Это зависит от единиц измерения и
разрядности чисел, которые используются в программе.

Если переменная принимает только целые значения и граница = 10, то
ближайшими приграничными значениями будут 9 и 11.

Если переменная — десятичная дробь с 2 знаками после запятой, то граница =
10,00, а приграничные значения — 10,01 и 9,99 соответственно.

## Тестирование линейных классов эквивалентности
Линейные классы эквивалентности выделяются по значению и по структуре
данных.

### Примеры разбиения на классы эквивалентности по значению

Разбиение на классы эквивалентности по значению используется для числовых
переменных, как это было сделано в примере про знаки зодиака.

**Рассмотрим ещё один пример**: 

Банк принимает положительное решение о выдаче
кредита, если заёмщику от 18 до 50 лет, и доход не менее 50 000 рублей в месяц.

На решение влияет два параметра: возраст и ежемесячный доход. По значению они
разбиваются на классы:
- возраст: <span style="color:red">(0; 18)</span>, <span style="color:green">[18; 50]</span>, <span style="color:red">(50; +∞)</span>
- доход: <span style="color:red">[0; 50000)</span>,<span style="color:green"> [50000; +∞)</span>

Красным выделены интервалы, которые приведут к отрицательному результату, а
зелёным — к положительному. Также вспомним школьный курс математики:
квадратные скобки используются, если граница попадает в интервал, а круглые,
если не попадает.

### Пример разбиения на классы эквивалентности по структуре

Классы эквивалентности по структуре данных включают:
- длину строки;
- длину числа;
- размер файла;
- объём памяти;
- и прочие характеристики, которые выражаются в числовом эквиваленте.

**User story:** Я как пользователь хочу сохранить параметры поиска прогноза погоды,
чтобы в будущем получать прогноз быстрее.
```
Пользователь: указывает параметры для прогноза
Пользователь: нажимает кнопку «В избранное»

Система: показывает диалоговое окно «Укажите название шаблона»

Пользователь: вводит название

Название валидное (от 1 до 30 символов)
Система: сохраняет шаблон в избранное

Название невалидное
Система: показывает сообщение «Длина названия от 1 до 30 символов»
```

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/weather.jpg?raw=true" alt = "макет">

Параметр, для которого мы будем выделять классы эквивалентности, — длина
строки от 1 до 30 символов. Выделим классы эквивалентности:

- [0; 1) — негативный сценарий;
- [1; 30] — позитивный сценарий;
- (30; +∞) — негативный сценарий.

Представим в виде таблицы с учётом техники граничных значений

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/name.jpg?raw=true" alt = "таблица_1">

Таким образом, для тестирования одного текстового поля нужно минимум шесть
проверок. Если нужно сократить проверки до минимума, приграничные значения,
которые находятся внутри класса, можно не проверять, если граница класса входит
в рассматриваемый интервал.

## Алгоритм тестирования линейных классов эквивалентности

1. Для параметра определить классы эквивалентности по значению.
2. Для параметра определить классы эквивалентности по структуре.
3. Найти границы классов.
4. Найти приграничные значения.
5. Протестировать на граничных и приграничных значениях.

### Составление таблицы доменного анализа
Представим ситуацию: нужно одновременно протестировать несколько
параметров, для которых существуют линейные классы эквивалентности.

Сервис прогноза погоды развивается и обогащается функциональностью для
профессиональных путешественников.

**User story 1:** Я как пользователь хочу узнать прогноз погоды, указав координаты
точки на карте.

**User story 2:** Я как пользователь хочу узнать прогноз погоды на выбранное
количество дней.

```
Пользователь: заполняет поле «Широта» значением от -90,000000 до 90,000000
Пользователь: заполняет поле «Долгота» значением от -180,000000 до 180,000000
Пользователь: заполняет поле «Дней» значением от 1 до 3
Пользователь: выбирает язык
Пользователь: выбирает информацию по осадкам
Пользователь: выбирает детализацию по дням / часам

Данные валидные
Система: показывает прогноз погоды

Данные невалидные
Система: показывает сообщение об ошибке «Прогноз не найден. Уточните параметры поиска»
```

Сколько нужно тестов, чтобы обеспечить оптимальное покрытие с учётом
тестирования граничных значений?

- Поле «Широта» — 6 тестов:
    - -90,000000
    - -90,000001
    - -89,999999
    - 90,000000
    - 90,000001
    - 89,999999
- Поле «Долгота» — 6 тестов:
    - -180,000000
    - -180,000001
    - -179,999999
    - 180,000000
    - 180,000001
    - 179,999999
- Поле «Дней» — 5 тестов:
    - 0
    - 1
    - 2
    - 3
    - 4
- Язык, осадки, детализация по pairwise: 4 теста

Итого 21 тест, если проверять всё по отдельности. Но количество тестов можно
сократить при помощи **техники доменного анализа**

Основной принцип **доменного анализа** — скомбинировать значения на границах и
внутри интервалов и таким образом сократить количество тест-кейсов. Доменный
анализ оперирует понятиями:

- точка on — лежит строго на границе;
- точка off — лежит слева или справа от границы (то есть от точки on):
    - если интервал закрыт со стороны точки on, то точка off лежит вне
интервала;
    - если интервал открыт со стороны точки on, то точка off лежит внутри
интервала;
- точка in — любое значение внутри интервала ближе к середине (удалённое от
границ).

### Алгоритм доменного анализа

1. Создадим таблицу и внесем в неё:
    - параметры, для которых есть линейные классы эквивалентности;
    - для каждого параметра — граничные значения со знаками >, <, >=, <=;
    - для каждой границы — строки on, off;
    - для каждого параметра — значение in.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise.jpg?raw=true" alt = "анализ">

2. Заполняем только строки on и off для всех параметров по диагонали (то есть в
одной колонке должно быть только одно значение on или off для одного
параметра).

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise_2.jpg?raw=true" alt = "анализ_2">

3. Теперь заполняем значения in. В каждой колонке в итоге должно быть
значение on / off для одного параметра и значение in для остальных.

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise_3.jpg?raw=true" alt = "анализ_3">

4. Дополним таблицу оставшимися параметрами, которые были
предварительно скомбинированы по принципу pairwise

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise_4.jpg?raw=true" alt = "анализ_4">

5. Выделим красным цветом невалидные значения и добавим ожидаемый
результат

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise_5.jpg?raw=true" alt = "анализ_5">

6. При необходимости в таблицу можно добавить дополнительные
отрицательные проверки. Главное — придерживаться правила не
комбинировать невалидные значения. Один тест — одно невалидное
значение, остальные — валидные

<image src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD.%D0%B7%D0%BD%D0%B0%D1%87/analise_6.jpg?raw=true" alt = "анализ_6">

В итоге вместо 21 теста получилось 13. При этом проверяются и границы, и
значения внутри, и вне интервалов, а также негативные кейсы.

Таким образом, техника доменного анализа оптимизирует проверки и позволяет
выполнить минимум проверок для наиболее удачного, оптимального покрытия
функциональности.

# Глоссарий
**Граничные значения** — значения, которые отделяют линейные классы
эквивалентности. Являются элементами повышенного риска. В таблице доменного
анализа обозначаются «on».

**Приграничные значения** — значения, которые лежат максимально близко справа и
слева от границы. В таблице доменного анализа обозначаются «off».

**Техника доменного анализа** — это подход, основанный на разбиении диапазона
возможных значений параметра (или параметров) на поддиапазоны (или домены), с
последующим выбором одного или нескольких значений из каждого домена для
тестирования в соответствии с определёнными правилами. Доменное тестирование
во многом пересекается с техниками разбиения на классы эквивалентности и
анализа граничных значений.

# Диаграммы и таблицы перехода состояний

## Диаграмма переходов состояний
Диаграмма переходов состояний — это техника тест-дизайна для систем, которые
изменяют характеристики в зависимости от внешних стимулов. Иными словами,
система принимает то или иное состояние и находится в нём до тех пор, пока не
получит стимул для изменения.

Хрестоматийный пример переходов состояний приведён в книге Л. Копланда
«A Practitioner's Guide to Software Test Design». Рассмотрим пользовательский
сценарий «Покупка билета на самолёт»:
```
Вариант 1
Пользователь: оформляет заказ на билет (предоставляет данные)
Система: создаёт бронь
Система: запускает таймер, до истечения которого нужно оплатить билет
Пользователь: оплачивает билет
Система: выпускает билет
Контролер: принимает билет
Система: погашает билет

Вариант 2
Пользователь: оформляет заказ на билет (предоставляет данные)
Система: создаёт бронь
Система: запускает таймер, до истечения которого нужно оплатить билет
Пользователь: не оплатил билет до окончания таймера
Система: отменяет бронь

Вариант 3
Пользователь: оформляет заказ на билет (предоставляет данные)
Система: создаёт бронь
Система: запускает таймер, до истечения которого нужно оплатить билет
Пользователь: отменил заказ до окончания таймера
Система: отменяет бронь

Вариант 4
Пользователь: оформляет заказ на билет (предоставляет данные)
Система: создаёт бронь
Система: запускает таймер, до истечения которого нужно оплатить билет
Пользователь: оплачивает билет
Пользователь: возвращает билет
Система: оформляет возврат
```
Помимо агентов (системы, пользователя и контролера) в сценарии есть объект —
билет, над которым выполняются различные действия. Также мы видим ряд
условий: был ли оплачен заказ, истёк ли таймер. В этой ситуации четырёх
позитивных тестов (по одному на каждый вариант использования) недостаточно,
так как ошибки скрываются там, где условия нарушаются. Для более наглядного
представления сценариев и выявления негативных кейсов используются
диаграммы и таблицы переходов состояний.

Элементы диаграммы переходов состояний:
- **Точка входа** — пользователь ещё не начал взаимодействовать с системой.
- **Круг с названием состояний** — состояние, в которое система пришла из-за
действий пользователя.
- **Стрелки** обозначают переход от одного состояния к другому.
- **События** — то, что приходит в систему извне и запускает изменение
состояния (например, пользователь оплатил заказ). Пишется над стрелкой.
- **Действие** — то, что происходит внутри системы из-за смены состояния
(например, запуск таймера). Пишется над стрелкой после события.
Отделяется от события косой чертой — /.
- **Точка выхода** — взаимодействие с системой окончено, изменение состояния
невозможно.

В случае с билетом состояния, события и действия выглядят так:

**Состояния:**
- Забронирован,
- Оплачен,
- Выпущен,
- Использован,
- Отменен по неоплате,
- Отменен покупателем

**События:**
- Указать персональные данные,
- Оплатить,
- Использовать,
- Отмена,
- Истёк таймер.

**Действия:**
- Стартовать таймер,
- Выпустить,
- Возврат денег

Диаграмма переходов состояний:

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/diagram.jpg?raw=true" alt="диаграмма состояний">

Диаграмма наглядно иллюстрирует бизнес-правила и варианты взаимодействия
пользователя с системой. Если есть сложная логика, диаграммы обычно создаются
аналитиками как часть документации к ПО.

### Составление тестов

При составлении тест-кейсов по диаграммам переходов состояний, можно
выделить 4 уровня покрытия:
1. **Каждое состояние затрагивает хотя бы один тест**. Тестовое покрытие
неоптимально, так как тестируются не все действия.
2. **Каждое событие вызывается хотя бы в одном тесте**. Уровень покрытия
также не оптимален.
3. **Каждый путь исполняется хотя бы в одном тесте**. Предпочтительный
вариант, но бывает недостижимым. Если в диаграмме есть циклы, количество
возможных путей становится бесконечным. Например, если есть два
состояния (А и В), и есть переходы из состояния А в В и обратно из В в А, то
возможны пути:

    **a**. А → В

    **b**. А → В → А

    <img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/diagram_2.jpg?raw=true" alt="пути состояний">

    **c**. А → В → А → В → А → В → А → В → А …

    Важно тестировать циклы, так как в них могут накапливаться ошибки или происходить утечки памяти.

4. **Каждый переход используется хотя бы в одном тесте**. Уровень тестового
покрытия оптимален, так как затронет все состояния, действия и события. Он
может совпадать с покрытием всех возможных путей. В этом случае мы
получим следующий набор тестовых сценариев:
    - Использование оплаченного билета (*Забронирован — Оплачен —
Выпущен — Использован*)
    - Отмена брони по неоплате (*Забронирован — Отменен по неоплате*)
    - Отмена брони покупателем (*Забронирован — Отменен покупателем*)
    - Отмена покупателем после оплаты (*Забронирован — Оплачен —
Отменен*)
    - Отмена покупателем после выпуска (*Забронирован — Оплачен —
Выпущен — Отменен*)

Недостаток составления тестов по диаграмме — отсутствие негативных сценариев.
Что будет, если покупатель попробует использовать отменённый билет? Или
оплатит его после того, как истечет таймер? Эти переходы не предусмотрены на
схеме, так как при большом количестве стрелок она станет нечитаемой. Для
негативных тестов удобнее использовать таблицу переходов

## Таблицы переходов состояний

Диаграммы переходов состояний — не единственный способ показать поведение
системы. Они более понятны, но таблицы переходов состояний лучше
систематизируют сведения о системе. Состоят из четырёх колонок:

- Текущее состояние,
- Событие,
- Действие,
- Новое состояние.

Алгоритм составления таблицы переходов состояний:

1. Сопоставить состояния и события по принципу «все ко всем» и заполнить
столбцы «Текущее состояние», «Событие».
2. Там, где смена состояний вызывает действие, описать его в столбце
«Действия».
3. В каждой строке указать новое состояние. Если событие не ведёт к смене
состояния, то новое состояние совпадает с текущим.

Таблица переходов состояний для покупки билета:

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/ticket_table_1.jpg?raw=true" alt="таблица билетов состояний_1">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/ticket_table_2.jpg?raw=true" alt="таблица билетов состояний_2">

### Составление тестов
Алгоритм составления тестов по таблице:
1. Выделить зелёным все возможные переходы.
2. Выявить невозможные переходы, которые несут риски, и выделить их
красным. Это будут негативные проверки. Для выявления рисков
тестировщики советуются с разработчиками или аналитиками.

При покупке билета существуют риски:

- покупатель использует неоплаченный, невыпущенный, ранее
использованный или отменённый билет;
- покупатель оплатит билет после отмены брони.

Эти кейсы отмечены красным цветом.
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/case_ticket_table_1.jpg?raw=true" alt="таблица тестов состояний_1">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/case_ticket_table_2.jpg?raw=true" alt="таблица тестов состояний_2">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/case_ticket_table_3.jpg?raw=true" alt="таблица тестов состояний_3">

Диаграммы и переходы состояний не применимы, если система не изменяет
состояние и не должна реагировать на внешние стимулы определённым образом.

## Пример «Публикация поста»

В тестируемой системе есть функциональность публикации поста.

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/post.jpg?raw=true" alt="поле ввода и создания поста">

Поле создания поста выглядит так, как на скриншоте выше. Есть поле для ввода
текста, значок добавления эмоджи, выбор времени публикации (сейчас или в
определённое время), выбор тематики поста, выбор фона (можно выбрать картинку
из предложенных или загрузить свою), добавление фото, видео, музыки, статьи,
файла, карты, граффити, опроса (часть пунктов может быть скрыта в выпадающем
списке «ещё»), настройка публикации и кнопка «Опубликовать».

После ввода текста и нажатия на кнопку «Опубликовать», пост будет создан в
системе. Затем он будет автоматически отправлен на модерацию. Пока пост на
модерации, его не видят другие пользователи, но видит автор. В это время автор
может его удалить или отредактировать, но после сохранения изменений пост
повторно будет отправлен на модерацию.

Если модерация отклонила пост, он возвращается автору на исправление и
повторную публикацию.

Если пост был одобрен модерацией, он становится видимым всем пользователям
системы. Автор может удалить или отредактировать пост. После редактирования
пост снова отправляется на модерацию.

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_1.jpg?raw=true" alt="диаграмма создания и модерирования поста">

Для наглядности выделим зелёным статусы поста, когда он виден всем, и голубым,
когда он виден только автору. Получим такую диаграмму:

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_2.jpg?raw=true" alt="диаграмма создания и модерирования поста с выделениями">

Теперь построим таблицу переходов состояний — для каждого состояния нужно
рассмотреть каждое событие. Событие в паре с действием рассматриваем только
тогда, когда действие относится именно к текущему состоянию. В остальных
случаях указываем только событие. Там, где нет одного из вариантов, в
соответствующем столбце будем ставить прочерк. Так как модерация — это
какая-то интеграция в нашу систему, то ответ от модерации также считаем
событием. Получим:

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_1.jpg?raw=true" alt="таблица создания и модерирования поста 1">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_2.jpg?raw=true" alt="таблица создания и модерирования поста 2">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_3.jpg?raw=true" alt="таблица создания и модерирования поста 3">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_4.jpg?raw=true" alt="таблица создания и модерирования поста 4">

Теперь составим тесты по таблице. Все переходы с изменением состояния, которые
отражены на диаграмме, — положительные тесты, их выделим зелёным.

<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_case_1.jpg?raw=true" alt="таблица создания и модерирования поста с выделениями 1">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_case_2.jpg?raw=true" alt="таблица создания и модерирования поста с выделениями 2">
<img src="https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/diagram%20and%20table/moderation_post_table_case_3.jpg?raw=true" alt="таблица создания и модерирования поста с выделениями 3">

# Глоссарий

**Диаграмма переходов состояний** — техника тест-дизайна, основанная на методе
«чёрного ящика». Демонстрирует поведение системы при получении управляющих
воздействий извне.

**Таблица переходов состояний** - см. диаграмма переходов состояний.

# Таблицы принятия решений

Таблицы принятия решений используются для тестирования программ со сложной
бизнес-логикой. Они применимы в случаях, когда существует набор правил, и
выходные данные зависят от комбинации условий.

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_0.jpg?raw=true" alt = "прмиер с заёмщиком">

Если есть сложные бизнес-правила, самое важное — не запутаться и предусмотреть
все возможные сценарии. В примере выходные данные (сумма кредита) зависят от
трёх параметров:

- возраст заёмщика,
- ежемесячный доход
- возможность подтвердить доход справкой.

Параметры, которые будут влиять на конечный результат, будем считать условиями.

Нужно предусмотреть все возможные комбинации параметров, чтобы верно
рассчитать итоговое значение. Для этого составим таблицу принятия решений.

Сначала определим все условия, применив классы эквивалентности:

- возраст: до 18, 18-55, больше 55;
- доход не менее 20 000: да, нет;
- справка: есть, нет

И определим, какие решения принять. В данном случае это будет:

- максимальная сумма кредита (если выдать его невозможно, максимальная
сумма — 0);
- нужен ли созаёмщик;
- какой применить коэффициент

## Алгоритм составления таблицы

1. Выпишем все условия и действия:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions.jpg?raw=true" alt = "все условия">

2. Посчитаем общее количество столбцов в таблице. Для этого перемножим
количество вариантов для каждого условия. В нашем случае это 3 * 2 * 2 = 12.
Значит, всего будет 12 комбинаций.

3. Делим 12 на 3 (количество вариантов в первом условии), получается 4.
Заполняем по 4 ячейки каждым вариантом:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_1.jpg?raw=true" alt = "заполнение возраста">

4. Делим 4 (то, что получилось на шаге 3) на количество вариантов во втором
условии. Получается 2 — заполняем по две ячейки каждым вариантом ответа
(«да» или «нет»):

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_2.jpg?raw=true" alt = "заполнение еж.доход">

5. Повторяем для третьего параметра. 2/2 = 1. По 1 ячейке заполняем
вариантами «есть» или «нет»:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_3.jpg?raw=true" alt = "заполнение справки">

6. Опираясь на требования, заполняем строку «Коэффициент К», так как он
понадобится для дальнейших вычислений. Если ипотека недоступна, К = 0:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_4.jpg?raw=true" alt = "заполнение коэфф">

7. Вычислим максимальную сумму. Чтобы составлять формулу было проще, в
строке «Ежемесячный доход» заменим «Да» на 50 000, а «Нет» — на 10 000.
Формулу запишем в 1 ячейке и скопируем в остальные

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_5.jpg?raw=true" alt = "заполнение макс.суммы">

8. Заполним строку «Нужен созаёмщик?»:

<img src = "https://github.com/Wredina/LibraryForTask/blob/main/Tester/img%20test_des_and_analise/table_%20decision/conditions_6.jpg?raw=true" alt = "заполнение созаёмщ.">

Таблица принятия решений готова. Мы рассмотрели все возможные комбинации
условий и получили разные результаты для каждого случая.

Иногда бывает так, что комбинация условий не описана в документации, и
тестировщик не может определить корректное решение. В этом случае требования
неполные, и их нужно уточнять у аналитиков.

## Достоинства таблиц принятия решений

- Оперативное составление тестовых сценариев.
- Выявление неполноты требований.
- При отсутствии требований таблицы могут заменить их.
- Проверка полноты покрытия требований тест-кейсами.
- Дают возможность предугадывать дефекты

## Недостатки таблиц принятия решений

- Если продукт масштабный, таблицу трудно составлять и использовать. Есть
риск допустить ошибку при составлении.
- При первоначальном проектировании условия не всегда могут быть
определены корректно.


# Глоссарий

Таблица принятия решений — техника тест-дизайна для объектов со сложной
бизнес-логикой. Представляет набор условий, одновременное выполнение которых
приводит к определённому действию

# Тестирование по пользовательским сценариям

## Use case (сценарий использования)
**Use Case** (сценарий использования, пользовательский сценарий) — это сценарий,
по которому пользователь взаимодействует с приложением или программой для
выполнения действия или для достижения цели.

Тестирование по сценариям обнаруживает баги, которые сложно найти при
тестировании частей приложения отдельно друг от друга. Сценарное тестирование
может выполняться как часть приёмочного тестирования.

Бизнес-заказчик предоставляет сценарии использования наряду с другой
продуктовой документацией: user story, пользовательскими и системными
требованиями. Как правило, одной user story соответствует один или несколько
пользовательских сценариев. Тест-кейсы составляются таким образом, чтобы
покрыть все представленные сценарии использования.

Сценарии использования описываются в разных формах:
- список шагов;
- таблица с основными и альтернативными сценариями;
- диаграмма вариантов использования;
- диаграмма классов.

### Пример 1. Пользовательский сценарий — список шагов

**User story:** Я как администратор хочу настраивать проектные роли через панель
администратора.
