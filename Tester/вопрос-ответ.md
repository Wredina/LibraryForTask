# Что такое тестирование ПО?

проверка соответствия реального и ожидаемого поведения программы, а так же степени удовлетворённия потребностей пользователя.

# Что такое качество?

это степень того, насколько компонент, система или процесс соответствует требованиям и ожиданиям пользователя.

# Какие цели у тестирования?

- оценка соответствия стандартам компании рабочих продуктов: требований, пользовательских историй, проектирования и кода - что приложение будет работать правильно
- проверка выполнения требований - что приложение будет соответствовать требованиям
- поиск и предотвращение дефектов - что всегда будет актуальная информация о состоянии продукта в конкретный момент

# какой самый распространённый стандарт в области тестирования ПО

ISTQB

# Какие критерии качества есть?

- функциональность
- эффективность
- надёжность
- удобство использования
- поддерживаемость
- переностимость
- безопасность
- совместимость

# Какие принципы тестирования есть?

- тестирование демонстрирует наличие дефектов
- исчерпывающее тестирование
- раннее тестирование
- скопление дефектов
- парадокс пестицида
- тестирование зависит от контекста
- заблуждение об отстутсвии ошибок

# Что такое тестовая среда?

среда тестирования функциональности. Она наполнена
тестовыми данными, которые могут показывать случаи, редко возникающие
в рабочей среде или удобные для тестирования. Здесь идёт тестирование
того, что готовится в продакшен.

# Что такое тестовые данные?

это набор входных значений, нужных для выполнения тестов.
Тестировщики определяют данные в соответствии с требованиями.

# Чем отличаются между собой тестирование, QC и QA?

QC (Quality Control) — контроль качества: анализ результатов тестирования и
качества новых версий выпускаемого продукта.

- проверка готовности ПО к релизу;
- проверка соответствия требований и качества проекта.

QA (Quality Assurance) — обеспечение качества продукта: изучение возможностей
изменения и улучшения процесса разработки и коммуникаций в команде.
Тестирование — один из аспектов обеспечения качества.

- проверка технических характеристик и требований к ПО;
- оценка рисков;
- планирование задач для улучшения качества продукции;
- подготовка документации, тестового окружения и данных;
- тестирование;
- анализ результатов тестирования, а также составление отчётов и других
документов.

# Что такое чек-лист и зачем он нужен?

Чек-лист (Check List) – это список, содержащий ряд проверок во время
тестирования программного продукта.

# Какой алгоритм составления чек-листов

1. Определить все возможные проверки.
2. Сгруппировать проверки в разделы.
3. Определить тестовые данные, если они необходимы.
4. Подумать, какие колонки будут в чек-листе.

# Каким правилам надо следовать, чтобы получился хороший чек-лист?

1. Один пункт — одна операция.
2. Пункты всегда начинаются с существительного или глагола неопределённой
формы.
3. Соблюдайте структуру.
4. Ничего не придумывайте.
5. Общепринятые названия.

# Какие есть виды чек-листов по последовательности проверок?

## Специальные и универсальные

Специальные чек-листы создают и используют для конкретных проектов. Их
пункты соответствуют его специфике. По специальному чек-листу тестировщик
проверяет возможность выполнить уникальное действие, предусмотренное
требованиями.

Универсальные чек-листы подходят для тестирования проектов одного типа.

## Связанные и несвязанные

подробный перечень (англ. laundry list) упрощает понимание и восприятие
информации. Элементы списка группируются по категориям, порядок не влияет на
точность данных.

В связанном чек-листе (англ. strongly sequential checklist) последовательность
влияет на результат. Ключевой этап работы над созданием связанного чек-листа —
корректное размещение информации.

Несвязанный чек-лист — среднее между подробным перечнем и связанным
чек-листом. Связь между элементами есть, но изменение порядка не повлияет на
результат проверки

# В каком случае проверке ставится статус passed? failed? skipped? blocked?

- passed — успешно пройден
- failed — кейс не прошел проверку
- skipped — пропуск проверки
- blocked — проверка заблокирована
- untested — кейс еще не брали в работу

passed ставится, когда исследуемый объект проходит проверку в соответствии с ТЗ.

failed – исследуемый объект не соответствует ТЗ. Например, функционал поломан,
не работает или его нет (разработчик потерял кнопку).

skipped — пропуск проверки кейса. Например, из-за нехватки времени или если в
кейсе есть неточности: он устарел, из документации вы понимаете, что его уже
изменили в проекте.

blocked — проверка заблокирована поломанным функционалом, от которого прямо
или косвенно зависит тестируемый. Например, есть функционал «авторизация
пользователя» и функционал «редактирование данных пользователя». Разработчик
допустил ошибку в коде и функционал авторизации поломан — ему мы выносим
резолюцию failed. Проверить редактирование данных пользователя не можем —
выставляем статус blocked. В комментарии указываем, почему не можем
протестировать этот функционал.

# Какие плюсы у чек-листов?

1. Чек-листы затрагивают большее количество кейсов, так как при
прохождении их можно по-разному выполнять.
2. Сокращают затраты на содержание и поддержку тестов.
3. Обеспечивают высокую скорость тестирования: не нужно отмечать результат
каждого шага тестировщика, достаточно общего результата проверки.
4. Позволяют проходить и комбинировать тесты по-разному, в зависимости от
предпочтений сотрудников.
5. Показывают статистику: кто, когда и что проходил — с детализацией по
сборке продукта и окружению, на котором проводилось тестирование.
6. Улучшают представление о системе в целом, показывают статус её
готовности.
7. Показывают объём проделанной и предстоящей работы по тестированию.

# Какие минусы у чек-листов?

1. Начинающие тестировщики не всегда эффективно проводят тесты без
достаточно подробной документации.
2. Чек-листы невозможно использовать для обучения начинающих сотрудников,
так как в них недостаточно подробных сведений.
3. Заказчику или руководству может быть недостаточно того уровня
детализации, который предлагают чек-листы.
4. Неопределённость тестового набора: каждый тестировщик выполняет пункт
чек-листа по-своему

# Что такое тест-кейс и для чего он нужен?

Тестовый случай (тест-кейс) — это совокупность шагов, конкретных условий и
параметров, нужных для проверки работы тестируемой функции или её части.

В нём описывается:

- какие шаги нужно выполнить (например, какие кнопки нажать, чекбоксы
активировать, данные внести), чтобы проверить работу участка системы;
- какой результат должен быть у каждого шага.

 тест-кейс — это небольшая инструкция по проверке работы функции.

# Какие атрибуты заполняются на этапе создания тест-кейса?

1. ID тест-кейса — уникальный идентификатор, присваивается автоматически.
2. Название — краткое описание сценария, который проверяет тест-кейс.
3. Шаги — последовательность действий, чтобы проверить работу функции или
выполнение сценария.
4. Ожидаемый результат — как должна вести себя система после каждого шага
тест-кейса, то есть то поведение, которое мы ожидаем получить после
выполнения конкретного действия или последовательности действий.
5. Приоритет тест-кейса зависит от приоритета функций и сценариев, которые он
проверяет. Определяет очерёдность выполнения теста во время тестирования.
Например, при высоком приоритете тест-кейс будет в начале очереди на
выполнение, а при низком — в конце. Если во втором случае что-то сломано, для
нас это не так критично, как в первом.
6. Тестовые данные — данные, которые используются для проверки. Могут
указываться в шагах тест-кейса или в отдельном файле с указанием ссылки на
них. Это, например, данные для авторизации пользователя или данные тестовой
карты для оплаты заказа.
7. Предусловия — действия, которые нужно выполнить, прежде чем приступать к
тест-кейсу, а также настройки приложения и тестовой среды.
Например, если мы проверяем отправку сообщения в чате с другом в
социальной сети, мы точно знаем, что пользователь должен быть авторизован.
Но сама авторизация как набор действий с вводом логина/пароля не имеет
отношения к отправке сообщения другу. Таким образом, правильно будет
указать в предусловии этого кейса, что пользователь должен быть авторизован,
а страница чата — открыта. В самих шагах мы будем описывать действия,
имеющие непосредственное отношение к отправке сообщения другу.
8. Постусловия — выполнение тест-кейса, как правило, переводит систему из
одного состояния в другое: меняются настройки, производятся расчёты.
Состояние, в которое нужно привести систему после прохождения тест-кейса,
указывается в постусловии.

# Какие атрибуты заполняются на этапе выполнения тест-кейса?

1. Фактический результат — то, что мы получаем после выполнения всего
тест-кейса или его конкретного шага. Это необязательный атрибут, его можно не
указывать. Но если он указывается, в нём может быть как краткое описание
того, что мы получили по факту прохождения шага / шагов, так и статус для
каждого фактического результата.
Если фактический результат совпадает с ожидаемым, в графе с фактическим
ставится статус passed — тест-кейс успешно пройден, ошибок не обнаружено.
Если результат отличается от ожидаемого — статус failed — проверка провалена,
полученный результат не соответствует ожидаемому. Во втором случае
тестировщик создаёт отчёт о дефекте (о нём поговорим позже). К тест-кейсу
обязательно добавляется ссылка на дефект, обнаруженный при исполнении.
2. Статус тест-кейса обозначает результат исполнения этого кейса или причину,
по которой он не может исполняться. Основные статусы:

- passed — успешно пройден
- failed — кейс не прошел проверку
- skipped — пропуск проверки
- blocked — проверка заблокирована
- untested — кейс еще не брали в работу

# В каком случае проверке ставится статус passed? failed? skipped? blocked?

passed ставится, когда исследуемый объект проходит проверку в соответствии с ТЗ.

failed – исследуемый объект не соответствует ТЗ. Например, функционал поломан,
не работает или его нет (разработчик потерял кнопку).

skipped — пропуск проверки кейса. Например, из-за нехватки времени или если в
кейсе есть неточности: он устарел, из документации вы понимаете, что его уже
изменили в проекте.

blocked — проверка заблокирована поломанным функционалом, от которого прямо
или косвенно зависит тестируемый. Например, есть функционал «авторизация
пользователя» и функционал «редактирование данных пользователя». Разработчик
допустил ошибку в коде и функционал авторизации поломан — ему мы выносим
резолюцию failed. Проверить редактирование данных пользователя не можем —
выставляем статус blocked. В комментарии указываем, почему не можем
протестировать этот функционал.

# Какие есть плюсы у тест-кейсов?

- За счёт полной детализации шагов тест-кейсы может проходить новичок. По
ним удобно знакомиться с продуктом.
- Достаточно подробное описание бизнес-логики. При неидеальной
организации хранения требований уточнение некоторых моментов проще
будет найти в тест-кейсах.

# Какие минусы у тест-кейсов?

- Нужно больше времени на написание, чем для чек-листов.
- Сложно поддерживать. Если изменится бизнес-логика, будут переименованы
разделы или произойдут другие изменения, затрагивающие
пользовательский интерфейс и сценарии использования системы, нужно
будет актуализировать все тест-кейсы, связанные с измененной частью.

# Что такое test suite?

список кейсов, объединённых общим фактором: весь продукт,
конкретная фича и так далее

# Что такое test plan?

список тест-сьютов, выбранных для теста

# Что такое test run?

проход («прогон») тест-сьютов, выбранных для тестирования в
соответствии с тест-планом.

# Что такое регрессионное тестирование и когда его проводят?

тестирование уже проверенной
функциональности после внесения изменений в код для уверенности, что эти
изменения не внесли или не активизировали ошибки в областях, которые не
подвергались изменениям.

Для регрессионного тестирования выбирают уже ранее составленные тест-кейсы

# Что такое тест - дизайн?

этап тестирования ПО, на котором проектируются и создаются
тестовые случаи (тест-кейсы). Они соответствуют определённым ранее критериям
качества и целям тестирования.

# Для чего нужны техники тест-дизайна?

- максимально покрыть функциональность тестами;
- обнаружить серьёзные баги;
- сократить количество тестов, исключив непродуктивные;
- не пропустить важные тесты.

# Какая активность не выполняется на этапе тест-дизайна?

непосредственное тестирование

# В чем заключается техника эквивалентного разбиения?

набор входных значений, каждое из которых одинаково
обрабатывается и приводит к одному результату. У значений внутри класса одни
признаки, что приводит к их идентичной обработке.

# Алгоритм работы с классами эквивалентности

1. На основе анализа нужно выбрать параметры, которые влияют на результат.
2. Для каждого параметра выделить классы эквивалентности.
3. Из каждого класса эквивалентности выбрать одно значение.
4. Обработать выбранные значение в соответствии с pairwise при
необходимости — об этой технике поговорим в следующий раз

# Тестирование на основе классов эквивалентности

техника тест-дизайна на
основе метода чёрного ящика, в ходе которой все данные делятся на классыэквивалентности, и затем тестирование проводится на одном значении из этого
класса.

# Тестирование на основе классов эквивалентности основано на двух умозаключениях

1. Если одно значение из класса выявит ошибку, остальные, скорее всего, тоже
это сделают.
2. Если одно значение из класса не выявит ошибку, остальные, скорее всего,
тоже этого не сделают.

# два вида классов эквивалентности

- линейные (упорядоченные) — значения можно упорядочить и расположить
на шкале. У линейных классов эквивалентности всегда есть границы, где
заканчивается один класс и начинается другой. Границы могут входить в
класс, а могут быть самостоятельными единицами.
- нелинейные (неупорядоченные) — значения нельзя упорядочить, граничных
значений нет.
набор неупорядоченных данных,
которые не имеют границ и являются частью множества данных.

# Виды линейных классов

Линейные классы эквивалентности выделяются по значению и по структуре
данных.

# разбиения на классы эквивалентности по структуре

Классы эквивалентности по структуре данных включают:

- длину строки;
- длину числа;
- размер файла;
- объём памяти;
- и прочие характеристики, которые выражаются в числовом эквиваленте.

# Алгоритм тестирования линейных классов эквивалентности

1. Для параметра определить классы эквивалентности по значению.
2. Для параметра определить классы эквивалентности по структуре.
3. Найти границы классов.
4. Найти приграничные значения.
5. Протестировать на граничных и приграничных значениях.

# Граничные значения

значения, которые отделяют линейные классы
эквивалентности. Являются элементами повышенного риска. В таблице доменного
анализа обозначаются «on».

# В чем заключается техника граничных значений?

проверка
поведения продукта на граничных значениях входных данных.

# Приграничные значения

значения, которые лежат максимально близко справа и
слева от границы. В таблице доменного анализа обозначаются «off».

# Как определить ближайшее граничное значение значение?

 Это зависит от единиц измерения и
разрядности чисел, которые используются в программе.

Если переменная принимает только целые значения и граница = 10, то
ближайшими приграничными значениями будут 9 и 11.

Если переменная — десятичная дробь с 2 знаками после запятой, то граница =
10,00, а приграничные значения — 10,01 и 9,99 соответственно

# В чем заключается техника попарного тестирования?

техника формирования наборов
тестовых данных, при которой каждое тестируемое значение каждого из проверяемых параметров хотя бы раз сочетается с каждым из тестируемых
значений всех остальных проверяемых параметров.

разработка тестов методом чёрного ящика, в которой
тестовые сценарии разрабатываются таким образом, чтобы выполнить все
возможные отдельные комбинации каждой пары входных параметров.

техника тестирования, в которой вместо проверки всех
возможных комбинаций значений всех параметров проверяются только
комбинации значений каждой пары параметров.

# Какие данные классов эквивалентности используются для попарного тестирования

только нелинейных

# Основные инструменты для техники paireise

- pairwiseTool
- Pairwise Pict Online

# Техника доменного анализа

это подход, основанный на разбиении диапазона
возможных значений параметра (или параметров) на поддиапазоны (или домены), с
последующим выбором одного или нескольких значений из каждого домена для
тестирования в соответствии с определёнными правилами. Доменное тестирование
во многом пересекается с техниками разбиения на классы эквивалентности и
анализа граничных значений.

# Принцип доменного анализа

- скомбинировать значения на границах и
внутри интервалов и таким образом сократить количество тест-кейсов

# Алгоритм доменного анализа

1. Создадим таблицу и внесем в неё:
    - параметры, для которых есть линейные классы эквивалентности;
    - для каждого параметра — граничные значения со знаками >, <, >=, <=;
    - для каждой границы — строки on, off;
    - для каждого параметра — значение in.
2. Заполняем только строки on и off для всех параметров по диагонали (то есть в
одной колонке должно быть только одно значение on или off для одного
параметра).
3. Теперь заполняем значения in. В каждой колонке в итоге должно быть
значение on / off для одного параметра и значение in для остальных.
4. Дополним таблицу оставшимися параметрами, которые были
предварительно скомбинированы по принципу pairwise
5. Выделим красным цветом невалидные значения и добавим ожидаемый
результат
6. При необходимости в таблицу можно добавить дополнительные
отрицательные проверки. Главное — придерживаться правила не
комбинировать невалидные значения. Один тест — одно невалидное
значение, остальные — валидные.

# Диаграмма переходов состояний

это техника тест-дизайна для систем, которые
изменяют характеристики в зависимости от внешних стимулов. Иными словами,
система принимает то или иное состояние и находится в нём до тех пор, пока не
получит стимул для изменения.

# В чем заключается техника тестирования состояний и переходов?

используют для фиксирования требований и описания дизайна приложения.

Диаграмма наглядно иллюстрирует бизнес-правила и варианты взаимодействия
пользователя с системой. Если есть сложная логика, диаграммы обычно создаются
аналитиками как часть документации к ПО.

# Элементы диаграммы переходов состояний

- Точка входа — пользователь ещё не начал взаимодействовать с системой.
- Круг с названием состояний — состояние, в которое система пришла из-за
действий пользователя.
- Стрелки обозначают переход от одного состояния к другому.
- События — то, что приходит в систему извне и запускает изменение
состояния (например, пользователь оплатил заказ). Пишется над стрелкой.
- Действие — то, что происходит внутри системы из-за смены состояния
(например, запуск таймера). Пишется над стрелкой после события.
Отделяется от события косой чертой — /.
- Точка выхода — взаимодействие с системой окончено, изменение состояния
невозможно

# 4 уровня покрытия составления тест-кейсов по диаграммам перехода

1. Каждое состояние затрагивает хотя бы один тест. Тестовое покрытие
неоптимально, так как тестируются не все действия.
2. Каждое событие вызывается хотя бы в одном тесте. Уровень покрытия
также не оптимален.
3. Каждый путь исполняется хотя бы в одном тесте. Предпочтительный
вариант, но бывает недостижимым. Если в диаграмме есть циклы, количество
возможных путей становится бесконечным.Важно тестировать циклы, так как в них могут накапливаться ошибки или
происходить утечки памяти.
4. Каждый переход используется хотя бы в одном тесте. Уровень тестового
покрытия оптимален, так как затронет все состояния, действия и события. Он
может совпадать с покрытием всех возможных путей.

# Недостаток составления тестов по диаграмме

отсутствие негативных сценариев

# Таблицы переходов состояний

 техника тест-дизайна, основанная на методе
«чёрного ящика». Демонстрирует поведение системы при получении управляющих
воздействий извне.

# 4 колонки таблицы состояний

- Текущее состояние,
- Событие - внешнее событие которое побудило к действию
- Действие - которое ведёт к новому состоянию
- Новое состояние.

# Алгоритм составления таблицы переходов состояний

1. Сопоставить состояния и события по принципу «все ко всем» и заполнить
столбцы «Текущее состояние», «Событие».
2. Там, где смена состояний вызывает действие, описать его в столбце
«Действия».
3. В каждой строке указать новое состояние. Если событие не ведёт к смене
состояния, то новое состояние совпадает с текущим.

# Алгоритм составления тестов по таблице

1. Выделить зелёным все возможные переходы.
2. Выявить невозможные переходы, которые несут риски, и выделить их
красным. Это будут негативные проверки. Для выявления рисков
тестировщики советуются с разработчиками или аналитиками.

# Для чего нужны таблицы принятия решений?

 для тестирования программ со сложной
бизнес-логикой. Они применимы в случаях, когда существует набор правил, и
выходные данные зависят от комбинации условий.

способ компактно представить
модели со сложной логикой. А ещё это техника тестирования чёрного ящика,
которая применяется для систем со сложной логикой.

Таблицы принятия решений используют, чтобы упорядочить и задокументировать
сложную логику приложения, а также протестировать все комбинации условий и
состояний.

# Алгоритм составления таблицы

1. Выпишем все условия и действия:
2. Посчитаем общее количество столбцов в таблице. Для этого перемножим
количество вариантов для каждого условия
3. делим общее кол-во столбов в таблице на кол-во вариантов в первом условии, получаем количество по n ячеек, которые заполняются каждым вариантом (n ячеек один вариант, потом n ячеек второй вариант и т.д.)
4. делим то, что получилось на шаге 3 на кол-во вариантов во втором условии, получаем количество по z ячеек, которые заполняются каждым вариантом (z ячеек один вариант, потом z ячеек второй вариант и т.д.)
5. Повторяем для третьего параметра.
6. Опираясь на требования, заполняем строки

# Достоинства таблиц принятия решений

- Оперативное составление тестовых сценариев.
- Выявление неполноты требований.
- При отсутствии требований таблицы могут заменить их.
- Проверка полноты покрытия требований тест-кейсами.
- Дают возможность предугадывать дефекты.

# Недостатки таблиц принятия решений

- Если продукт масштабный, таблицу трудно составлять и использовать. Есть
риск допустить ошибку при составлении.
- При первоначальном проектировании условия не всегда могут быть
определены корректно.

# Как тестировать без требований?

варианты:

1. Работать с приложением, как будто вы его пользователь.
2. Опираться на бизнес-процессы.
3. Декомпозировать функциональность.
4. Уточнить информацию у других участников разработки.
5. Использовать оракулы, например, по методике FEW HICCUPS.
6. Проводить мозговой штурм.
7. Применять исследовательское тестирование.

# Что такое исследовательское тестирование?

одновременное изучение программы,
проектирование и выполнение тестов. Этот подход — противоположность
сценарного, когда список проверок составлен до проведения тестирования.
Исследовательские тесты не определены заранее и не выполняются в точном
соответствии с планом.

это не методика тестирования. Это подход или
образ мыслей, который можно применить к любой методике

частично
формализованный подход, при котором тестировщик работает с приложением по
сценарию. В процессе сценарий дорабатывается для более полного исследования
приложения.

Исследовательское тестирование проводится сессиями. Сессия — это выделенный
промежуток времени, в котором тестировщик исследует программу, ориентируясь
на поставленную цель.

# Когда применять исследовательское тестирование?

- Нужна быстрая обратная связь о новом продукте.
- Нужно быстро изучить продукт.
- Сценарное тестирование не находит баги, требует разнообразия.
- Нужно принять решение о необходимости покрытия области сценарными
тестами.
- Требований нет, они неполные или устарели.
- Продукт маленький, разработка тестовых сценариев займёт больше времени,
чем сам процесс тестирования.

# Преимущества сценарного тестирования

1. Тестирование можно планировать: тест-кейсы можно легко поделить между
различными тестировщиками или командами.
2. Важные кейсы гарантировано будут пройдены.
3. Можно оценить процент покрытия требований тестами.
4. Тестовые сценарии можно использовать для обучения новых сотрудников.
5. Тестовые сценарии помогают проводить приёмочные испытания и
определять критерии готовности

# Преимущества исследовательского тестирования

1. Нестандартные ходы выявляют нестандартные дефекты.
2. Не тратится время на описание всех сценариев.
3. Не нужна поддержка тестовых сценариев.
4. Не наступает «эффект пестицида».
5. Можно тестировать без требований.
6. Тесты могут стать интереснее и креативнее.

# Ограничения для исследовательского тестирования

Приложение стандартизированное — приложения, работающие по стандартам и
ГОСТам, для которых малейшее отклонение может быть критичным. Это банковские
продукты, сложные системы CRM, ERP, любые программы с высокими финансовыми
или иными рисками.

Интеграционное тестирование — обычно проводится для проверки
взаимодействия внутренних компонентов приложений. Эта работа хорошо покрыта
документацией и часто автоматизируется.

Тестовые сценарии на аутсорсе — нужно контролировать поставленную задачу и
процент ее выполнения проще по формализованным сценариям.

Длительный проект — тестировщики могут быть подключены к проекту на время
определённой фазы, а после, пока разработчики реализуют новый функционал,
заниматься другими проектами. Если долго не тестировать конкретную
функциональность, её специфика забывается, поэтому всё должно быть описано в
тестах

# Туры Дж. Уиттакера — подходы к исследовательскому тестированию

Он сравнивает
тестировщика-исследователя с туристом, который оказался в незнакомом городе. В
зависимости от того, какую цель преследует турист-тестировщик, приводятся:

- туры в бизнес-районах,
- туры в исторических районах,
- развлекательные туры,
- туристические достопримечательности,
- тур по отелям,
- туры по злачным местам,
- и так далее

# Тур по путеводителю

Цель — тестирование пользовательской документации. Тестировщик берёт
руководство пользователя и последовательно выполняет всё, что там написано. Это
открывает ошибки как в функциональности, так и в пользовательской
документации.

# Денежный тур

Цель денежного тура — протестировать всё, за что клиенты готовы заплатить,
платные возможности программы. В денежном туре также нужно проверять
маркетинговые артефакты: демо-режим, рекламные ролики, соответствие
маркетинговой документации реальности.

# Интеллектуальный тур

Цель тура — «озадачить» приложение, чтобы заставить его работать по максимуму.
Например, это может быть формирование очень сложного отчёта, оформление
очень большого заказа, допущение максимального количества ошибок при
выполнении операции и так далее.

# Эвристики тестирования

это быстрые способы решения проблемы или принятия решения.

технология тестирования
алгоритмов, приложений и программ, при использовании которой стратегия
тестирования основывается на предыдущем опыте и данных о вероятности
наступления различных событий.

# Эвристика Маша и медведи

Эвристика концентрируется на подходе «слишком много, слишком мало и в самый
раз»

# RCRCRC Мнемоника

Мнемоника RCRCRC поддерживает регрессионное тестирование. Расшифровка:

1. Recent (недавнее) — новый инструментарий или починка багов.
2. Core (ключевое) — главные функции, дымовое тестирование.
3. Risky (рискованное) — сложная логика или недостаточность требований.
4. Configuration (конфигурационное) — изменения в файлах настроек.
5. Repaired (исправленное) — починка багов.
6. Chronic (хроническое) — места, где баги возникают постоянно.

# Мнемоника FEW HICCUPS

это мнемоника, которая помогает запомнить ключевые слова для
источников ожидаемого результата тестирования. Иногда их называют оракулами.
Оракулы особенно полезны, если спецификация отсутствует или содержит
неадекватную информацию.
Расшифровка:

1. Familiar (известность) — ПО не воспроизводит известные проблемы других
программных продуктов.
2. Explainability (объяснимость) — работа ПО понятна, пользователь может её
объяснить.
3. World (мир) — ПО соответствует знаниям и фактам окружающей
действительности.
4. History (история) — новая версия ПО не противоречит предыдущей.
5. Image (имидж) — ПО соответствует имиджу компании, которая его
разрабатывает.
6. Comparable product (конкуренты) — ПО не хуже, чем аналогичные продукты
конкурентов.
7. Claims (заявления) — ПО выполняет то, что заявляется в рекламе,
пресс-релизах и так далее.
8. User Expectations (ожидания пользователя) — ПО отвечает ожиданиям
людей, которые его используют.
9. Product (продукт) — все элементы ПО работают как единое целое.
10. Purpose (цель) — ПО решает ту задачу, ради которой оно создавалось.
11. Standards (стандарты) — ПО соответствует стандартам, установленным в
отрасли.

# Личные эвристики тестирования

Практикующий тестировщик использует собственные эвристики, причём иногда
бессознательно. Это связано с двумя тезисами:

- использование и создание эвристик — интуитивный процесс,
- всё, чем заняты тестировщики в тестировании, рассматривается как
эвристика.

# Создать свою тест-эвристику

Первый шаг в осознании и разработке собственной тест-эвристики — определить,
где она уже используется. Это очень сложный процесс. Мы привыкли объяснять, что
делаем, но объяснить, почему мы это делаем, значительно сложнее. Там и прячутся
эвристики.

# Обдумывание

Обдумывание тестирования часто вскрывает паттерны. А они, возможно, результат
применения эвристик. Регулярное обдумывание во время каждой тест-сессии и
после неё повысит шансы на идентификацию эвристик. К примеру, можно
потратить несколько минут после каждой сессии, чтобы спросить себя «почему я
провёл именно эти тесты», и «почему я провёл их именно в таком порядке». Можно
выявить паттерны, делая заметки и пересматривая их.

# Вербализация

Вербализация — это проговаривание, объяснение тестирования другим людям. Этот
процесс поощряет обдумывание, так как мы ищем слова, чтобы объяснить, что
делаем или сделали. Обсуждая решения с другими людьми, мы обнаруживаем
нюансы, о которых не знали, и создаём новые связи между мыслями и идеями,
описывая их. Можно рассказывать это самим себе, используя эвристику резиновой
уточки.

# Применение теории на практике

Эвристики – мощный инструмент, и он ещё мощнее, если тестировщик отдаёт себе
отчёт в существовании эвристик, понимает их и может сознательно применять их в
тестировании.

# Почему исследовательское тестирование относится к техникам тест-дизайна?

Тестировщик проводит исследовательское тестирование приложения, в результате
которого выявляются дефекты. Тот сценарий (тест), который выявил дефект, нужно
задокументировать (создать тест-кейс), чтобы в дальнейшем проверять, что дефект
исправлен и не появился вновь. Кроме того, стоит создать тест-кейсы (если их нет)
и для проверки похожих сценариев, чтобы обнаружить другие подобные дефекты. В
некоторых случаях проверки, проведённые при исследовательском тестировании,
следует документировать (создавать тест-кейс), даже если они не обнаружили
дефект. Это нужно, чтобы повторять проверки в будущем, в том числе при
регрессионном тестировании.

Таким образом, исследовательское тестирование как техника тест-дизайна
позволяет дополнять наборы тест-кейсов новыми тестами, а также создавать
актуальные тест-кейсы, которые выявляют дефекты.

# Что такое свободное (интуитивное) тестирование?

неформальный подход, в
котором не предполагается использование тест-кейсов, чек-листов и сценариев.

Тестировщик полностью опирается на свой профессионализм и интуицию при
спонтанном выполнении проверок.

# Что такое функциональное тестирование?

это тестирование ПО, в процессе которого
проверяется реализация функциональных требований, то есть проверка работы
функциональностей, направленных на решение задач пользователя

# Что такое метод чёрного ящика?

Чёрный ящик — это система, внутреннее устройство и механизм работы которой
сложны, неизвестны или не важны в рамках решения задачи.

Метод чёрного ящика — метод исследования, при котором вместо свойств и
взаимосвязей составных частей системы изучается реакция системы как целого на
изменяющиеся условия.

# Как проводится тестирование методом чёрного ящика?

тестирование, основанное на
анализе функциональной или нефункциональной спецификации системы без
знания внутренней структуры.

У тестировщика нет доступа к коду, он видит приложение как пользователь.
Тестирование проводится через интерфейс приложения. Это ручное тестирование
без знания, что находится «за кулисами» интерфейса.

# Как проводится тестирование методом белого ящика

основано на анализе внутренней
структуры системы, на знании и понимании исходного кода. У тестировщика есть
полный доступ к исходному коду.

Для тестирования методом белого ящика нужно знать язык программирования, на
котором написано приложение. Обычно этот вид тестирования применяют
разработчики при написании юнит-тестов. Входные значения отбираются на основе
кода, который будет их обрабатывать.

# Как проводится тестирование методом серого ящика

тестирование в условиях, когда
часть внутренней структуры программы известна. Тестировщик работает не с
кодом приложения, а с часть его внутренней структуры: проверяет запись в базе
данных, лог-файлы, коды ответа от сервера.

Для тестирования веб-приложений методом серого ящика тестировщик использует
инструменты разработчика, например, Chrome DevTools.

# Какие есть методы тестирования серого ящика?

1. Матричное тестирование — определение всех переменных, которые есть в
программе.
2. Тестирование ортогональных массивов обеспечивает максимальное
покрытие кода с минимальным количеством тестов.
3. Pattern Testing выполняется на данных истории предыдущих дефектов
системы.

# Какие есть виды тестирования после изменений в коде?

Регрессионное тестирование (regression testing) — тестирование уже проверенной
функциональности после изменений в коде. Цель — убедиться, что эти изменения
не добавили или не активизировали ошибки в изменённых областях.

Повторное или подтверждающее тестирование (re-testing/confirmation testing) —
исполняются тестовые сценарии, выявившие ошибки во время последнего запуска.
Цель — подтвердить, что ошибки исправили, и приложение работает в соответствии
с требованиями

# Чем статическое тестирование отличается от динамического?

Статическое тестирование (static testing) — тестирование системы на уровне
спецификации или реализации без исполнения кода.

Динамическое тестирование (dynamic testing) — тестирование во время
выполнения программного обеспечения, компонента или системы. Проверка —
реальное поведение ПО во время его работы.

# Что такое позитивное тестирование? Что такое негативное тестирование?

Позитивное тестирование (positive testing) — тестирование с использованием
только корректных данных. Проверяет, правильно ли приложение выполняет
вызываемые функции. Проводится, чтобы подтвердить работоспособность объекта
тестирования.

Негативное тестирование (negative testing) направлено на исследование работы
приложения в ситуациях, когда выполняют некорректные операции или используют
данные, потенциально приводящие к ошибкам.

# Что такое Альфа-тестирование?

внутреннее пробное использование.
Выполняется внутри организации-разработчика, иногда — с частичным
привлечением пользователей.

Альфа-тестирование проводится после модульного, интеграционного и системного
тестирования, когда продукт уже частично готов к выпуску на рынок, но нужно его
доработать. Представляет собой имитацию реального использования, но
выполняется либо командой тестирования, либо другими сотрудниками
компании-разработчика в тестовой среде. Например, на тестовых стендах,
недоступных внешним пользователям.

# что такое бета-тестирование?

выполняется вне организации с активным
привлечением пользователей. Обычно представляет собой форму внешнего
приёмочного тестирования.

Продукт должен быть стабилен, но не исключено появление проблем и выявление
недостатков. Поэтому сначала доступ открывают для небольшой группы лояльных
пользователей, чтобы проверить работоспособность и получить обратную связь.

# Что такое Соук-тет (дымовой тест)?

это тип тестирования
программного обеспечения, который проверяет, правильно ли работают наиболее
важные функции программного приложения. Термин «дымовое тестирование»
происходит от идеи тестирования приложения ровно настолько, чтобы увидеть,
«горит» ли оно (т. е. сильно ли сломано), прежде чем проводить более глубокое
тестирование

Дымовые тесты обычно запускаются после сборки, чтобы убедиться, что
приложение может быть запущено и работают самые основные функции, прежде
чем будет выполнено более всестороннее тестирование.

# Что такое нефункциональное тестирование?

анализ свойств
компонента или системы, не относящихся к функциональности. То есть,
проверяется, «как работает система».

# Какие виды входят в нефункциональное тестирование?

1. Тестирование производительности:
    - нагрузочное тестирование,
    - тестирование масштабируемости,
    - объёмное тестирование,
    - стрессовое тестирование.
2. Тестирование безопасности.
3. Инсталляционное тестирование
4. Тестирование интерфейса (GUI/UI-тестирование).
5. Тестирование удобства использования.
6. Тестирование локализации.
7. Тестирование надёжности

# Что такое тестирование произвадительности?

помогает определить
работоспособность, стабильность, потребление ресурсов в условиях разных
сценариев использования и нагрузок.

# Что такое нагрузочное тестирование

— тип тестирования производительности,
цель которого — оценить поведение системы при возрастающей нагрузке, а также
определить нагрузку, которую может выдержать компонент или система.

# Что такое тестироваание масштабируемости

тестирование для
измерения возможностей вертикального и горизонтального масштабирования с
точки зрения любой из нефункциональных возможностей: увеличение количества
пользователей, рост количества транзакций, увеличение объёма данных.

# Что такое вертикальное мастштабирование

это увеличение производительности каждого
компонента системы для повышения общей производительности. Например,
увеличивается объём оперативной памяти на сервере, чтобы он быстрее
обрабатывал запросы. Это повысит производительность всей системы.

# что такое горизонтальное масштабирование

разбиение системы на структурные
компоненты и разнесение их по отдельным физическим машинам. А также
увеличение количества серверов, параллельно выполняющих одну и ту же
функцию. Например, увеличивается количество серверов, но каждый выполняет
одну и ту же задачу: принимает одни и те же запросы и отвечает на них.

# Что такое объёмное тестирование

тестирование на больших объёмах
данных. Например, тестируется поведение приложения при попытке загрузить в его
базу данных нескольких файлов очень большого размера.

# Что такое стрессовое тестирование

оценивает систему на граничных
значениях рабочих нагрузок, за их пределами или в состоянии ограниченных
ресурсов — памяти или доступа к серверу.

# Пропускная способность

фактическое количество запросов,
которое обрабатывает система за определённое время. Метрика пропускной
способности показывает объём данных, полученных и обработанных в момент
времени.

# Ширина пропускания канала

максимальное число запросов,
обрабатываемых системой. Используется, чтобы измерять максимальный объём,
который обрабатывает приложение.

# Процент ошибок

отношение невалидных ответов к валидным за промежуток
времени.

# Инсталляционное тестирование

тестирование, направленное
на проверку успешной установки и настройки, обновления или удаления
приложения при различном программном и аппаратном окружении. Оно позволяет
оценить работоспособность системы после завершения работы инсталлятора.

# Тестирование пользовательского интерфейса

проверка соответствия
интерфейса и требований, насколько удобно пользователям работать с
программным продуктом. Проверяют, ведёт ли себя программное обеспечение в
соответствии со спецификацией, когда пользователь взаимодействует с ним с
помощью клавиатуры и мыши (когда тестируется десктопное приложение), или с
помощью сенсорного экрана, жестов или движений устройства (когда тестируется
мобильное приложение).

# UX-тестирование (юзабилити-тестирование, Usability testing)

проверка того,
насколько легко пользователь понимает и осваивает программу, включая
функциональную составляющую (саму систему) и её документацию —
пользовательские инструкции.

# Тестирование локализации

проверка адаптации
программного обеспечения для нового места эксплуатации. Включает проверку
изменения языка и культурной адаптации.

# Тестирование безопасности

тестирование программного
продукта на предмет его защищённости. Основные понятия, которые охватывает
тестирование: конфиденциальность, целостность и сохранность данных,
аутентификация, авторизация и невозможность отказа от авторства (атрибуты
качества). Проводится для тех объектов, в работе которых обеспечение
защищённости — одна из важнейших задач.

# Тестирование надёжности

тестирование способности
приложения выполнять свои функции в заданных условиях на протяжении
заданного времени или установленного количества операций.

# Что такое баг?

это отклонение фактического результата от ожидаемого.

# Что такое баг - репорт?

отчёт о дефекте, или баг-репорт (bug report).

это документ, который описывает шаги воспроизведения
дефекта, фактический и ожидаемый результат, серьёзность дефекта и приоритет
устранения.

# Как должно составляться название отчета о дефекте?

 кратко сформулированная суть дефекта по правилу «Что?
Где? Когда?».

Название должно содержать ответы на вопросы:

1. Что происходит или не происходит согласно спецификации или
представлению тестировщика о нормальной работе продукта?
2. В каком месте интерфейса пользователя или архитектуры программного
продукта находится проблема?
3. В какой момент работы программного продукта, при наступлении какого
события или при каких условиях проявляется проблема?

# Что описываем в шагах воспроизведения?

последовательное описание действий,
которые привели к выявлению дефекта. Описываются максимально
подробно с указанием конкретных вводимых значений.

руководство к действию для тех, кто будет
решать проблему. Составляются по правилам:

1. Вернуться к началу. Первый шаг — указание, по какой
2. Шаг отвечает на вопрос «Что сделать?».
3. Количество шагов — от 2 до 8. Если больше, нужно подумать, какие шаги
лишние.
4. Последний шаг — указание, на что обратить внимание:

# Что описываем в фактическом результате? В ожидаемом результате?

1. Один дефект — один фактический и ожидаемый результат.
2. В ожидаемом результате дать ссылку на документацию.

Фактический результат — указывается, что работает не так, в каком месте
продукта и при каких условиях.

Ожидаемый результат — указывается, как именно должна работать система,
по мнению тестировщика, основанному на документации.

# Серьёзность и приоритет

Серьёзность показывает степень ущерба, который наносится проекту дефектом.

1. Блокирующий (Blocker) — функция не работает.
2. Критический (Critical) — функция работает, но с ограничениями.
3. Значительный (Major) — функция работает, но неправильно.
4. Незначительный (Minor) — функция работает,но неудобно.
5. Тривиальный (Trivial) — грамматические ошибки в пользовательской
документации.

Приоритет (срочность) показывает, как быстро нужно устранить дефект.

Срочность — высокая (High), средняя (Medium), низкая (Low). Порядок исправления
ошибок по их приоритетам:

1. High – высокий, дефект нуждается в срочном устранении.
2. Medium – средний, дефект нуждается в устранении, но это не срочно.
3. Low – низкая срочность исправления дефекта.

# Правила хорошего баг-репорта

1. Следовать правилу «Что? Где? Когда?».
2. Одна ошибка — один отчёт о дефекте.
3. Краткость — сестра баг-репорта.
4. Писать техническим языком с применением терминологии, принятой на
проекте.
5. Прикреплять дополнительные файлы: логи, скриншоты, видео.
6. Прикреплять ссылки к требованиям, чтобы избежать споров.
7. Избегать дубликатов дефектов — прежде чем сохранить отчёт о дефекте,
надо проверить в баг-трекере, есть ли уже такой дефект.
8. Указывать версию ПО и тестовый стенд (окружение), на котором
обнаружился дефект.
9. Воспроизводить дефект, следуя собственным шагам.

# Что такое баг-трекинговая система?

Система отслеживания ошибок (от англ. bug tracking system) — прикладная
программа, созданная, чтобы разработчикам ПО (программистам, тестировщикам и
другим) было проще:

- учитывать и контролировать ошибки и неполадки, найденные в программах,
а также пожелания пользователей;
- следить за устранением этих ошибок и выполнением или невыполнением
пожеланий.

Багтрекинговые системы используются для создания отчётов о дефектах и для
управления ими. Они также применяются при создании задач для команды
разработки.

# Отчётность

сбор и распространение информации о результатах работы, включая
текущий статус, оценку прогресса и прогноз развития ситуации.

# Отчёт о результатах тестирования

документ, обобщающий результаты работ по
тестированию и содержащий информацию, достаточную для соотнесения текущей
ситуации с тест-планом и для принятия необходимых управленческих решений.

# кто может быть заказчиком отчёта

менеджер по продукту, разработчики, руководители тестирования,
руководители разработки, менеджер проекта и многие другие

# какую информацию нужно предоставить в отчёте?

Разработчик, вероятно,
заинтересован в найденных дефектах, так что корректно добавить ссылку на
них в отчёт.

 Руководителю тестирования нужна вся информация по
проведенному вами процессу.

Менеджеру проекта стоит знать, в каком
состоянии мы находимся (продукт, разработка, контроль качества и так
далее), поэтому уместно предоставить общий отчёт о состоянии с
небольшими пояснениями.

# Как заказчики используют отчёт?

Разные специалисты делают это
по-разному:

- менеджер по продукту — для принятия решения о выпуске фичи;
- QA Lead — для планирования возможностей специалиста по
тестированию;
- разработчик — для планирования своих задач с учётом времени на
исправление ошибок.

# Содержание отчёта о тестировании фичи

Краткое описание — вводный раздел, в котором кратко описывается содержание
отчёта, перечисляются основные числовые показатели хода тестирования,
обозначаются главные выводы и даются рекомендации для дальнейшей работы.
Этой части отчёта достаточно для общей оценки ситуации заинтересованными
лицами (менеджерами, руководителями команд).

Команда тестировщиков — список участников проектной команды,
задействованных в тестировании, с указанием их должностей и ролей в отчётный
период.

Описание процесса тестирования — вся выполненная тестировщиками работа:
количество написанных и пройденных тест-кейсов, число найденных дефектов,
добавленные и протестированные функции.

Расписание — календарные сроки, в которые выполнены работы.

Статус активностей тестирования и прогресс по сравнению с планом
тестирования — график burndown, на котором видно соотношение
запланированных и проведённых работ.

Факторы, препятствующие прогрессу — критичные дефекты, недоработанная
функциональность, пробелы в требованиях.

Статистика по новым дефектам — количество дефектов, обнаруженных за
отчётный период, с указанием степени важности, срочности, места обнаружения и
прочего.

Список новых дефектов — список дефектов, обнаруженных в отчётном периоде, с
указанием их основных атрибутов.

Статистика по всем дефектам — график, который отражает динамику обнаружения
дефектов на протяжении всего процесса тестирования. В итоговом отчёте по
результатам тестирования указываются все обнаруженные дефекты за весь период
тестирования, распределённые по выбранной классификации, например, по
степени важности, времени обнаружения.

Качество объекта тестирования — экспертное заключение об уровне качества
продукта

Рекомендации — выводы по результатам тестирования и рекомендации по
повышению его эффективности в будущем.

Приложения — графики, таблицы, диаграммы, демонстрирующие числовые
характеристики процесса тестирования.

# Содержание комментария отчёта о тестировании конкретной задачи

- кейсы, которые проверили в рамках задачи (можно перечислить текстом или
прикрепить ссылку на тест-ран из TMS),
- окружение, на котором проверили (версия операционной системы, версия
приложения; если тестируем мобильное приложение — модель устройства,
если веб-приложение — браузер и его версия),
- что не смогли проверить — не работало окружение, какие-то кейсы нельзя
проверить по какой-либо причине.
- моменты, которые стоит зафиксировать — риски, некритичные баги,
которые будут правиться после релиза и подобное.

# Содержание отчёта об исследовательском тестировании

- Список протестированных разделов или модулей продукта. В дальнейшем
с его помощью можно оценить тестовое покрытие и необходимость
дополнительных исследований.
- Список дефектов: найденных вообще или самых критических (в зависимости
от того, для кого и на какой стадии тестирования делается отчёт).
- Найденные проблемы, вопросы, наблюдения.
- Риски. Важно рассказать о том, что не было протестировано и почему так
произошло — функциональность не входила в объём работ, не работал
сервер, не было подходящих тестовых данных и так далее.
- Краткий вывод по результатам тестирования в зависимости от его цели.
Например, можно ли передавать продукт заказчику для ознакомления.

# Из каких частей состоит отчет о результатах тестирования?

Краткое описание — вводный раздел, в котором кратко описывается содержание
отчёта, перечисляются основные числовые показатели хода тестирования,
обозначаются главные выводы и даются рекомендации для дальнейшей работы.
Этой части отчёта достаточно для общей оценки ситуации заинтересованными
лицами (менеджерами, руководителями команд).

Команда тестировщиков — список участников проектной команды,
задействованных в тестировании, с указанием их должностей и ролей в отчётный
период.

Описание процесса тестирования — вся выполненная тестировщиками работа:
количество написанных и пройденных тест-кейсов, число найденных дефектов,
добавленные и протестированные функции.

Расписание — календарные сроки, в которые выполнены работы.

Статус активностей тестирования и прогресс по сравнению с планом
тестирования — график burndown, на котором видно соотношение
запланированных и проведённых работ.

Факторы, препятствующие прогрессу — критичные дефекты, недоработанная
функциональность, пробелы в требованиях.

Статистика по новым дефектам — количество дефектов, обнаруженных за
отчётный период, с указанием степени важности, срочности, места обнаружения и
прочего.

Список новых дефектов — список дефектов, обнаруженных в отчётном периоде, с
указанием их основных атрибутов.

Статистика по всем дефектам — график, который отражает динамику обнаружения
дефектов на протяжении всего процесса тестирования. В итоговом отчёте по
результатам тестирования указываются все обнаруженные дефекты за весь период
тестирования, распределённые по выбранной классификации, например, по
степени важности, времени обнаружения.

Качество объекта тестирования — экспертное заключение об уровне качества
продукта.

Рекомендации — выводы по результатам тестирования и рекомендации по
повышению его эффективности в будущем.

Приложения — графики, таблицы, диаграммы, демонстрирующие числовые
характеристики процесса тестирования.

Отчёт о тестировании представляется в разных видах: в текстовом, табличном и
графическом.

# Частота формирования отчёта

Отчёт о результатах тестирования может формироваться каждый день, в конце
каждой итерации, каждую неделю и так далее — зависит от потребностей команды
проекта. При полном завершении тестирования формируется отчёт о его
результатах.

# расчётные показатели в отчёте

позволяют
контролировать и оценивать ситуацию. Их можно использовать в отчётах для
оценки хода тестирования и его результатов.

# Метрики в отчёте

Метрика — это:

- числовая характеристика показателя качества;
- мера, позволяющая получить численное значение некоторого свойства ПО
или его спецификаций;
- показатель текущего достижения поставленных целей;

# для чего нудны метрики

Метрики собираются во время и по завершении тестирования, чтобы оценить:

- прогресс относительно запланированного графика и бюджета;
- текущее качество объекта тестирования;
- адекватность подхода к тестированию;
- эффективность активностей тестирования по достижению целей
тестирования.

# Типы метрик

1. Прямые — для определения не производятся вычисления. Используются для
расчётных метрик. Примеры:

- количество разработанных тест-кейсов;
- количество найденных дефектов;
- время прохождения тест-кейсов.

2. Расчётные — вычисляются по формулам. Например:

- процентное соотношение выполненных/невыполненных тест-кейсов ко
всем имеющимся;
- процент успешного прохождения тест-кейсов ко всему их объёму;
- процент заблокированных тест-кейсов ко всему их объёму;
- плотность распределения дефектов;
- эффективность устранения дефектов;
- распределение дефектов по важности и срочности.

# Прямые метрики в отчёте могут содержать

Общее количество найденных дефектов — количество дефектов, найденных за
весь период тестирования. Представляется с разбивкой по степени важности /
срочности или по модулям, где обнаружились дефекты.

Текущее количество дефектов — количество дефектов, найденных в текущей
сборке, итерации, спринте. Показывает актуальную тестовую ситуацию и динамику
изменений: улучшение или ухудшение кода, процесса разработки, качества
тест-кейсов.

Общее устранение дефектов — процент устранения дефектов определённого
уровня важности за время существования проекта. Сколько всего дефектов
исправлено за время разработки и тестирования.

Текущее устранение дефектов — процент устранения в текущем билде или
итерации дефектов, обнаруженных в предыдущей сборке или итерации. Когда
выходит новая версия продукта или стартует новая итерация, нужно различать
дефекты, обнаруженные в предыдущей версии, и изъяны, появившиеся в
актуальной.

Плотность дефектов — количество дефектов на единицу размера: на весь продукт,
спринт, функцию, объём исходного кода. Метрика сигнализирует о наиболее
уязвимых модулях и участках кода.

# Расчётные метрики в отчёте могут содержать

формулу:
>Выполнение тест-кейсов -
(количество выполненных тест−кейсов/
общее количество тест−кейсов) * 100%

Ключевая метрика, которая показывает прогресс тестирования. Служит для
сравнения фактического прогресса с планом и для внесения корректировки в
работу тестировщиков.

формулу:
>Успешное прохождение тест-кейсов -
(количество успешно выполненных тест−кейсов/
общее количество тест−кейсов) * 100%

Метрика показывает качество приложения: если доля неуспешных или
заблокированных тест-кейсов высокая, это свидетельствует о некачественном
коде. Нужно внести изменения в процесс разработки, внедрить новые инструменты
и практики взаимных проверок.

**Коэффициент ретеста дефектов** —

**Коэффициент регрессии:**
**Стоп-фактор**

# Коэффициент ретеста дефектов

показывает, какую часть времени в
тестировании занимает перепроверка исправленных дефектов. Важно, чтобы
большая часть рабочего времени тестировщиков не уходила на ретесты вместо
проверки новой функциональности.

>количество закрытых дефектов / количество новых дефектов

>затраченное время на ретест /
затраченное время на тестирование новой функциональности

Если времени на перепроверку исправленных дефектов уходит больше, чем на
тестирование новой функциональности, должны быть приняты меры, так как это
может свидетельствовать о большом числе дефектов.

# Коэффициент регрессии
>
>количество дефектов в старом инструментарии /
количество дефектов в новом инструментарии

>количество тест−кейсов в статусе 𝑓𝑎𝑖𝑙𝑒𝑑 /
количество тест−кейсов в регрессионном наборе

Тестировщики следят, сколько дефектов появляется в уже протестированном
инструментарии при добавлении новых функций. Если их много, это
свидетельствует о низком качестве разработки.

Стоп-фактор — решение о приостановке тестирования. Учитывается текущее
значение метрик, выполнение и успешное прохождение тест-кейсов.
Если процент тест-кейсов, выполненных успешно, низкий (какой процент считать
низким и достаточным для принятия организационных решений, каждый проект
определяет самостоятельно), то тестирование может быть приостановлено до
исправления дефектов.

# Стоп-фактор

решение о приостановке тестирования. Учитывается текущее
значение метрик, выполнение и успешное прохождение тест-кейсов.
Если процент тест-кейсов, выполненных успешно, низкий (какой процент считать
низким и достаточным для принятия организационных решений, каждый проект
определяет самостоятельно), то тестирование может быть приостановлено до
исправления дефектов.

Есть несколько метрик, которые используются в процессе тестирования:

- степень взаимосвязанности требований;
- коэффициент стабильности требований;
- коэффициент повторно открытых дефектов;
- средняя стоимость исправления дефекта;
- скорость работы команды QA;
- среднее время жизни дефекта;
- коэффициент ошибок, пропущенных в продакшн (в релиз);
- доля неподтверждённых дефектов.

# Критерии тестирования

Перед проведением тестирования устанавливаются ориентиры, которые позволяют
принимать управленческие решения в процессе работы. Критерии тестирования
описываются в плановой документации. А также критерии устанавливаются
различными договорённостями между сотрудниками проекта.

# Критерии начала тестирования

 когда запускать тестирование на проекте.
Определение этого критерия при планировании тестирования уменьшает потери
времени на заведомо неэффективную работу. Критерии начала тестирования:

- готовность тестовой платформы;
- законченность разработки требуемого инструментария;
- наличие требуемой документации;
- выход новой версии продукта;
- успешный прогон Unit-тестов;
- успешный прогон Smoke-тестов

# Критерии приостановки тестирования

когда остановить тестирование, чтобы
ликвидировать проблемы.

1. Критичный баг препятствует тестированию.
2. Накопилось много багов: очевидно, после починки надо всё перепроверять.

# Критерии возобновления тестирования

когда возобновить тестирование после
приостановки.

1. Исправление критичного дефекта.
2. Выпуск новой, более стабильной, сборки.

# Критерии завершения тестирования

когда тестирование считается оконченным.

1. Выполнение более 90% запланированных на итерацию тест-кейсов.
2. Выдержка конкретного периода без открытия новых дефектов.
3. Истечение времени, отведённого на тестирование.
4. Отсутствие дефектов высокой степени важности.

Внесение этого критерия в проектную документацию позволяет избежать
преждевременного прекращения тестирования со стороны заказчика.

# Приёмочные критерии

1. Критерии, на основании которых заказчик считает свои требования
выполненными.
2. Критерии, которыми будут руководствоваться для вывода продукта на рынок.

- успешное прохождение 100% тест-кейсов уровня дымового
тестирования (smoke-тестов) и 90% тест-кейсов уровня критического
пути;
- условия по устранению 100% дефектов критической и высокой
важности;
- условие, что итоговое покрытие требований тест-кейсами составит не
менее 80%.

# Что такое требования?

Требование — описание функций и условий, которые выполняет приложение в
процессе решения пользовательской задачи (например, оформления заказа в
интернет-магазине). Это отправная точка процесса разработки.

# Кто создаёт требования?

Требования создаёт заказчик, аналитик или технические специалисты на этапе
планирования.

# Какая основная задача требования

зафиксировать ожидания заказчика о том, какой продукт
планируется разработать

# Какие есть виды требований

**Функциональные требования:**

Отвечают на вопрос: «Что должна делать программа?». Например, показывать
прогноз погоды или воспроизводить видео.

- бизнес-требования;
- пользовательские требования;
- системные требования.

**Нефункциональные требования:**

Отвечают на вопрос: «Как должна работать программа?». Связаны с
нефункциональными видами тестирования, то есть относятся к быстродействию,
внешнему виду, удобству использования, локализации и другим подобным
критериям.

- бизнес-правила;
- внешние интерфейсы;
- атрибуты качества.

# Бизнес-требования

это обобщённое описание функций продукта без
технической детализации (например, без требований к аппаратному обеспечению).
Они отвечают на вопрос: «Какую потребность пользователя закроет ПО?».

# Пользовательские требования

описание задач, которые пользователь сможет
решить, используя приложение. Эти требования более детализированные, чем
бизнес-требования, но не содержат технических подробностей.

# Системные требования

описание технической реализации программы, а также
требуемое программное и аппаратное окружение.

# Бизнес-правила

принципы, которые определяют, почему система должна работать именно так. Это
ссылки на законодательство, внутренние правила заказчика и другие причины.

# Внешние интерфейсы

интерфейсы пользователя (макеты) и протоколы
взаимодействия с другими системами

# Атрибуты качества

- лёгкость и простота использования;
- производительность;
- удобство эксплуатации и технического обслуживания;
- надёжность и устойчивость к сбоям;
- взаимодействия системы с внешним миром;
- расширяемость;
- требования к пользовательским и программным интерфейсам.

# Атрибуты требований

Чтобы требования считались корректными и давали разработчику и тестировщику
однозначные указания по работе приложения, они должны быть:

- атомарными
- полными;
- однозначными;
- непротиворечивыми;
- необходимыми;
- осуществимыми;
- тестируемыми.

# Атомарность

Требование нельзя разбить на отдельные части без потери деталей

# Полнота

Требования должны учитывать все возможные пользовательские действия,
входные параметры, сообщения об ошибках. Если требование неполное, в этом
месте возникают дефекты.

Лучший способ проверить требования на полноту — начать писать тесты. При
планировании проверок «белые пятна» станут очевидны.

# Однозначность

Важно, чтобы требования не допускали двусмысленных формулировок. Все
требования, касающиеся субъективных параметров, например, скорости работы,
эстетики интерфейса и удобства использования, описываются в абсолютных
числах.

# Непротиворечивость

Когда требований много, они противоречат сами себе. Например, поведение одного
и того же компонента описывается различными аналитиками в разных разделах
требований. И это поведение будет различаться.

# Необходимость

Принцип составления документации: «Кратко, но ёмко». Важно, чтобы в ней было
всё необходимое, но без лишней детализации.

# Осуществимость

Важно, чтобы требования осуществлялись с учётом внутреннего устройства
программы и технологий, которые используются разработчиками.

# Тестируемость

Важно, чтобы у тестировщика была возможность проверить функциональность,
которую создал разработчик. Особенно это касается автотестов: может случиться,
что действующие библиотеки автоматизации не покроют новые функции, и их
придётся дорабатывать.

# Дефекты в требованиях

Если требования не соответствуют атрибутам, значит, в них есть дефект. Дефекты
на требования заводятся при тестировании требований и сохраняются в
багтрекинговых системах, как и дефекты на функциональность.

# Что включает в себя дефект на требование

Дефект на требование может выглядеть так:

1. Название. Требование №1 — неоднозначное.
2. Описание. Непонятно, как именно выдаются проектные роли: в настройках
проекта, в панели администрирования или и там, и там?
В багах на требования не нужны шаги воспроизведения, ожидаемый и фактический
результат. Достаточно описать, какой атрибут не соблюдается.

# Форматы требований

Требования на проекте могут быть в разном виде — текст, схематическое описание,
user story или use case.

# Текстовое описание требований

В тексте требований должна быть описана логика, внешний вид, допустимые и
недопустимые значения и так далее.

# Схематичное описание требований

Описание функциональности представлено в виде схематичного изображения
требований из макетов с пояснениями и визуализацией переходов. Могут
использоваться таблицы, блок-схемы и так далее.

# User story — пользовательские истории

способ описания требований к системе в одном или
нескольких предложениях. Для заказчиков (пользователей) пользовательские
истории — основной инструмент влияния на разработку программного
обеспечения.

быстрый способ документировать требования клиента
без необходимости разрабатывать обширные формализованные документы и
тратить ресурсы на их поддержание. Цель пользовательских историй — оперативно
и без накладных затрат реагировать на быстро изменяющиеся требования
реального мира

- определяют, что должно реализоваться в программе;
- приоритезируются клиентом по важности для системы;
- разбиваются на серию задач и оцениваются разработчиками.

# Пользовательская история описывает

- человека, использующего систему (заказчик);
- то, что должно содержаться в этой системе (примечание);
- то, для чего она требуется пользователю (цель).

# Пользовательские требования

описание задач, которые сможет решить
пользователь, используя приложение. Эти требования более детализированные,
чем бизнес-требования, но не содержат технических подробностей.

# Use case — пользовательский сценарий (сценарии использования)

это сценарий,
по которому пользователь взаимодействует с приложением или программой для
выполнения действия или для достижения цели.

описывает взаимодействия участников, как правило,
пользователя и системы. Количество участников — от двух и больше. Пользователь
— человек или другая система. Оформляются в виде таблиц или диаграмм.

# Какие задачи решает Use case — пользовательский сценарий

1. Оценка трудоёмкость проекта
2. Планировка графика работ.
3. Выявление пропущенных требований.

# Сценарии использования описываются в разных формах

- список шагов;
- таблица с основными и альтернативными сценариями;
- диаграмма вариантов использования;
- диаграмма классов.

# Пользовательский сценарий, алгоритм списока шагов

1. Определить, какие параметры влияют на выполнение каждого шага.
2. С помощью техник тест-дизайна выявить значения параметров.
3. Скомпоновать параметры и представить в виде одного или нескольких
тест-кейсов.

# Диаграмма вариантов использования(сценариев поведения, прецедентов)

— это
концептуальное представлением системы в процессе проектирования и
разработки. Она состоит из актеров, вариантов использования и отношений
между ними.

# Актёр в диаграмме вариантов использования

Актером
(действующим лицом, актантом, актором) называется любой объект, субъект или
система, взаимодействующая с моделируемой системой извне.

изображается в виде человечка, но возможны варианты:
произвольная иконка или класс с текстовым стереотипом «actor».

# Вариант использования в диаграмме вариантов использования

это спецификация сервисов (функций), которые система
предоставляет актеру. Диаграмма составляется в соответствии с нотацией UML.

 обозначается эллипсом с описанием выполнения операции
или действия внутри.

# Что такое RMS (Система управления требованиями)

средство поддержки и автоматизации процесса работы с требованиями на
протяжении всего жизненного цикла разработки программного продукта

# Задачи RMS

1. Хранение требований в одном месте.
2. Единое управление требованиями.
3. Повышение производительности труда благодаря контролю над
изменениями в требованиях и управлению ими.
4. Минимизация расходов и рисков благодаря оценке влияния происходящих
изменений.
5. Демонстрация соответствия требований благодаря полному отслеживанию
требований.
6. Сокращение объёма доработок и ускорение выхода на рынок благодаря
совместной работе с заинтересованными лицами

# RMS система Confluence

— внутренняя вики-система для организаций. Поможет создать единую
базу знаний. Написана на Java, разрабатывается компанией Atlassian.
Распространяется под проприетарной лицензией, бесплатна для некоммерческих
организаций и открытых проектов.

# Какие задачи помогает решать Confluence

1. Создание и хранение проектной и технической документации.
2. Создание и управление требованиями в более узком виде, чем RMS.
3. Экспорт и импорт документации (документов).
4. Создание связи (ссылок и меток) между документами.
5. Возможность комментирования и обсуждения требований и документации.
6. Возможность отслеживания версионности и внесения изменений, а также
сравнения разных версий документа.
7. Автоматические уведомления о внесении изменений в документах и
страницах, на которые подписаны.
8. Управление доступом к проектам

# Декомпозиция требований. Mind Map

(диаграмма связей, интеллект-карта) — это способ представления и
хранения информации в виде некоторой схемы.

# преимущества Mind Map

- структурированная информация;
- снижение риска пропустить дефекты за счёт наглядности;
- возможность проведения тестирования по интеллект-карте без тестовой
документации.

# Техника предугадывания ошибок

метод проектирования тестов для
предугадывания дефектов в тестируемой системе. Основана на знаниях
тестировщика, включая:

- историю работы приложения,
- вероятные типы дефекты, которые допускают при разработке,
- типы дефектов, которые обнаружили в схожих приложениях.

# Цели техники предугадывания ошибок

- Быстро найти наибольшее количество багов в узких местах
функциональности или системы.
- Предусмотреть все возможные и невозможные кейсы, в частности
негативные. Проверить, что система работает корректно.
- Проверить систему на наличие популярных багов (например, возможность
ввода букв в числовое поле, активность кнопок и так далее).

# Плюсы техники предугадывания ошибок

- Техника эффективна в качестве дополнения к другим техникам.
Использовать её самостоятельно мы не можем из-за минусов. Но в качестве
дополнения она позволит проверить максимальное количество кейсов, в
которых потенциально может быть баг.
- Выявляет тестовые случаи, которые «никогда не должны случиться».
Большинство проверяемых сценариев при использовании этой техники
заключаются в «что будет, если?..». С помощью этих сценариев мы проверяем
кейсы, которые не должны были просто так возникнуть при прохождении
базовых кейсов

# Минусы техники предугадывания ошибок

- Техника основана на интуиции. Все кейсы придумывает сам тестировщик
без опоры на правила. Многие кейсы составляют интуитивно: если у
тестировщика есть опыт в тестировании и общее понимание разработки, он
может предположить определённое количество сценариев, в которых
потенциально может быть баг. Количество обнаруженных багов при
проведении этих проверок будет зависеть как от интуиции тестировщика, так
и от качества написанного кода.
- Нужен опыт в тестировании подобных систем и знание конкретного
проекта. Многие баги повторяются время от времени, одни и те же
разработчики допускают одни и те же ошибки.
- Малое покрытие тестами. Так как проверки составляются интуитивно, на
основании опыта, и в большинстве случаев затрагивают крайние кейсы, они
не обеспечивают полного покрытия функциональности тестами.

# Тестовое покрытие

метрика оценки качества тестирования, отражающая
плотность покрытия тестами требований и исполняемого кода.

# Метрики покрытия кода

Метрика покрытия кода позволяет оценить, насколько полно строчки кода,
написанные разработчиком, покрыты модульными или интеграционными тестами.
Вычисляется по формуле:
>Tcov = (Ltc / Lcode) ⋅ 100%

Где:

- Tcov — тестовое покрытие;
- Ltc — количество строк кода, покрытых тестами;
- Lcode — общее количество строк кода.

# SonarQube

это платформа с открытым исходным кодом, предназначенная для
непрерывного анализа и измерения качества кода и его покрытия

# преимущества SonarQube для разработчиков

1. Поддержка языков Java, C, C++, C#, Objective-C, Swift, PHP, JavaScript, Python
и других.
2. Предоставление отчётов о дублировании кода, соблюдении стандартов
кодирования, покрытии кода модульными тестами, а также о возможных
ошибках в коде, о плотности комментариев, техническом долге и так далее.
3. Сохранение истории метрик и построение графиков их изменения во
времени.
4. Интеграция с IDE (Visual Studio, IntelliJ IDEA и Eclipse) с помощью плагина
SonarLint.
5. Интеграция с внешними инструментами: JIRA, Mantis, LDAP, Fortify и другими.
6. Можно расширять функциональность с помощью сторонних плагинов.

# преимущества SonarQube для тестировщиков

Тестировщики могут использовать SonarQube, чтобы отслеживать качество кода и
динамику изменений в нём.

# Метрика покрытия требований

Чтобы определить качество и полноту покрытия кейсами, используют метрику
покрытия требований. Она также полезна, если изменения вносят часто: можно
отслеживать, что все они затронуты тест-кейсами. Вычисляется по формуле:
>Tcov = (Lcov / Ltotal) ⋅ 100%

Где:

- Tcov — тестовое покрытие;
- Lcov — количество требований, проверяемых тест-кейсами;
- Ltotal — общее количество требований.

Чем выше процент метрики, тем качественнее будет проведено тестирование.

# Матрица трассировки(Traceability matrix)

способ визуализации связей между
элементами системы. Представляет собой таблицу, где:

- по одной грани указаны все требования на проекте, требования, которые
должны быть протестированы в итерации или требования для определённого
модуля либо функции,
- по другой грани — все написанные тест-кейсы.

Матрицы трассировки используются не только для оценки покрытия, но и для
определения связи между задачами на разработку, требованиями и тестовыми
артефактами.

# Что содержит каждая строка матрицы

- номер и описание задачи на разработку;
- логический блок, к которому принадлежит задача (опционально);
- атомарное требование или приёмочный критерий;
- приоритет;
- номер и описание соответствующего тестового артефакта.
Такая трассируемость позволяет:
- визуализировать актуальное состояние реализации;
- разбивать требования на более атомарные и структурировать их;
- отслеживать, есть ли требования, на которые ещё не запланирована
разработка (пропуск реализации);
- отслеживать, реализовано ли требование в данный момент;
- отслеживать, покрыто ли требование тест-кейсом (пропуск тестирования);
- наглядно отображать приоритезацию требований.

# Варианты связей в матрице трассировки

Привязка требования и тест-кейса может быть:

- 1 к 1 — атомарное требование, которое покрывается одним тест-кейсом,
тест-кейс покрывает только это требование;
- 1 к n — требование, которое покрывается несколькими тест-кейсами, данные
тест-кейсы покрывают только это требование;
- n к n — требование, которое покрывается несколькими тест-кейсами, данные
тест-кейсы покрывают это и другие требования.

Если одно требование в матрице трассируемости покрывается несколькими
тестами, можно говорить об избыточности тестирования. Надо проанализировать,
насколько требование атомарно.

# Оценка покрытия с помощью матриц трассируемости

Если для оценки покрытия служит метрика «отношение количества требований к
количеству тестовых артефактов», то связи в матрице должны быть «1 к 1», а
требования максимально декомпозированы.

- разделить требования на отдельные атомарные функции текстового
редактора;
- для каждой функции написать приёмочный критерий;
- для каждого критерия создать тестовый артефакт;
- если несколько атомарных требований могут быть покрыты одним
чек-листом, можно не делать избыточного дробления, сэкономив ресурсы.

# Создание и ведение матрицы

1. Требования декомпозируются и приоритезируются. Результат этапа —
структурированный и приоритезированный список всех требований по
функциональности.
2. Постановка задач на разработку и внесение в матрицу соответствующих
требований. Результат — отслеживается трассируемость требований и задач
на разработку.
3. Разработка тест-кейсов и чек-листов. Матрица заполняется тест-кейсами.
4. Поддержка матрицы в актуальном состоянии. Изменения должны вноситься
при любых модификациях требований. Нужно учитывать интеграционные
связи между двумя матрицами, которые описывают разные фичи или модули.
При изменении в одной обязательно проверять, не нужно ли исправить
вторую.

# Сложности в работе с матрицей трассировки

1. Актуализация. Матрица полезна, когда поддерживается её актуальность.
Если не актуализировать матрицу, она будет вносить путаницу.
2. Временные ресурсы. На проекте может быть срочный релиз и работа с
новыми требованиями в одно и то же время. Все ресурсы QA направляются на
тестирование, а не на работу с требованиями. Из-за этого возрастает долг по
тестовой документации.
3. Эффективность. Если проект небольшой и все требования оформлены в
виде структурированного ТЗ, а тест-кейсы создаются на каждое требование
сразу, матрица трассировки будет дублировать информацию. Это лишняя
трата ресурсов.

# Практическая польза от матрицы трассировки

- Удобно контролировать реализацию требований, отслеживать, что все они
разработаны и протестированы, ничего не пропущено.
- Помогает команде QA отслеживать долг по тестовой документации.
- Можно контролировать изменённые требования.
- В процессах разработки и тестирования больше прозрачности.

# Клиент-серверная архитектура («Клиент — сервер» (англ. client–server))

вычислительная или сетевая архитектура, в
которой сетевая нагрузка распределена между поставщиками услуг, называемыми
серверами, и заказчиками услуг, называемыми клиентами. Иными словами, клиент и
сервер — это обычное программное обеспечение. Такие программы расположены на
разных вычислительных машинах и взаимодействуют между собой через вычислительную
сеть посредством сетевых протоколов, но они могут быть расположены также и на одной
машине.

# Клиент

Участник обмена (user agent) — это любой инструмент или устройство, действующие от лица
пользователя. Эту задачу преимущественно выполняет веб-браузер; в некоторых случаях участниками выступают программы, которые используются инженерами и
веб-разработчиками для отладки своих приложений

# сервер

 это вычислительная машина, которая может находиться в любой точке Земли и
которая хранит данные о вашем профиле и ваших заказ и множество других данных, таких,
как названия товаров, цены, картинки и многое другое.

# Программы-серверы

ожидают от клиентских программ запросы и предоставляют им свои
ресурсы в виде данных (например, загрузка файлов посредством HTTP, FTP, потоковое
мультимедиа или работа с базами данных) или в виде сервисных функций (например,работа с электронной почтой, общение посредством систем мгновенного обмена
сообщениями или просмотр web-страниц во всемирной паутине). Поскольку одна
программа-сервер может выполнять запросы от множества программ-клиентов, ее
размещают на специально выделенной вычислительной машине, настроенной особым
образом, как правило, совместно с другими программами-серверами, поэтому
производительность этой машины должна быть высокой.

# Балансировщик нагрузки (Load Balancer)

сервис, помогающий серверам эффективно
перемещать данные, оптимизирующий использование ресурсов доставки приложений и
предотвращающий перегрузки.

# Что делает Балансировщик нагрузки

Он управляет потоком информации между клиентом и сервером. Этот сервис проводит
непрерывные проверки работоспособности серверов, чтобы убедиться в их
работоспособности. При необходимости подсистема балансировки удаляет неисправные
серверы из пула.

# балансировщики выполняют следующие функции

- функция разгрузки — защищает от распределенных атак типа «отказ в
обслуживании» (DDoS);
- функция прогнозной аналитики — определяет узкие места трафика до того, как они
возникнут;
- функция запуска новых виртуальных хранилищ данных при превышении лимитов
входящего трафика.

# какими могут быть балансировщики

Балансировщики могут быть как отдельными физическими аппаратными устройствами, так
и поставляться в виде программы. Аппаратные устройства работают на основе
программного обеспечения, оптимизированного под специализированные процессоры. По
мере увеличения трафика, поставщик просто добавляет дополнительные устройства
балансировки нагрузки для обработки необходимого объема.

# клиент-серверные технологии

Архитектура «клиент-сервер» определяет общие принципы организации взаимодействия в
сети, где имеются серверы, узлы-поставщики некоторых специфичных функций (сервисов)
и клиенты (потребители этих функций).
Практические реализации такой архитектуры называются клиент-серверными
технологиями.

# Виды клиент-серверной архитектуры

- Двухзвенная архитектура
- Трехуровневая архитектура
- Многозвенная архитектура
- Монолитная архитектура
- Микросервисная архитектура

# Двухзвенная (двухуровневая) архитектура

распределение трех базовых компонентов между двумя узлами
(клиентом и сервером). Двухзвенная архитектура используется в клиент-серверных
системах, где сервер отвечает на клиентские запросы напрямую и в полном объеме.

# основные модели взаимодействия в рамках двухзвенной архитектуры

- Сервер терминалов — распределенное представление данных.
- Файл-сервер — доступ к удаленной базе данных и файловым ресурсам.
- Сервер БД — удаленное представление данных.
- Сервер приложений — удаленное приложение.
- Клиент – это браузер.

# Трехзвенная (трехуровневая) архитектура

 сетевое приложение разделено на две и более частей, каждая
из которых может выполняться на отдельном компьютере. Выделенные части приложения
взаимодействуют друг с другом, обмениваясь сообщениями в заранее согласованном
формате

Третьим звеном в трехзвенной архитектуре становится сервер приложений

# компоненты в трёхзвенной архитектуре

- Представление данных — на стороне клиента.
- Прикладной компонент — на выделенном сервере приложений (как вариант,
выполняющем функции промежуточного ПО).
- Управление ресурсами — на сервере БД, который и представляет запрашиваемые
данные.

# Веб-сервер

это сервер, принимающий HTTP-запросы от клиентов и выдающий им
HTTP-ответы. Веб-сервером называют как программное обеспечение, выполняющее
функции веб-сервера, так и непосредственно компьютер, на котором это программное
обеспечение работает. Наиболее распространенными видами ПО веб-серверов являются
Apache, IIS и NGINX. На веб-сервере функционирует тестируемое приложение, которое
может быть реализовано с применением самых разнообразных языков программирования:
PHP, Python, Ruby, Java, Perl и пр.

База данных фактически не является частью веб-сервера, но большинство приложений
просто не могут выполнять все возложенные на них функции без нее, так как именно в базе
данных хранится вся динамическая информация приложения (учетные, пользовательские
данные и пр).

# База данных

информационная модель, позволяющая упорядоченно хранить данные
об объекте или группе объектов, обладающих набором свойств, которые можно
категоризировать. Базы данных функционируют под управлением так называемых систем
управления базами данных (далее – СУБД). Самыми популярными СУБД являются MySQL,
MS SQL Server, PostgreSQL, Oracle (все – клиент-серверные).

# Многозвенная архитектура

Трехзвенная архитектура может быть расширена до многозвенной (N-tier, Multi-tier) путем
выделения дополнительных серверов, каждый из которых будет представлять собственные
сервисы и пользоваться услугами прочих серверов разного уровня

# Монолитная архитектура

это архитектура, где приложение представлено в виде единого
компонента и представляет собой разрез бизнес-логики, которая модульно прошита. Все
клиенты, как правило, обращаются только к одному приложению.

# монолитное приложение состоит из

- базы данных,
- клиентского пользовательского интерфейса,
- серверного приложения.

# Микросервисная архитектура (MSA)

это подход к созданию приложения, подразумевающий
отказ от единой, монолитной структуры. Приложения с микросервисной архитектурой
(MSA) состоят из n небольших подсистем, или микросервисов. Эти подсистемы и их
экземпляры могут выполняться как на одной физической машине, так и на нескольких. Во
втором случае отказоустойчивость сервиса выше

# общая точка входа в систему

в микросервисной архитектуре можно встретить API layer

Она балансирует нагрузку и ограничивает доступ к сервисам, но не является
обязательным компонентом.

# В основе дизайна MSA

лежат принципы domain-driven design, в частности ограниченные
контексты и домены. Таким образом, каждый микросервис реализует домен или поддомен,
имеет собственную базу данных (или не имеет, но у сервисов нет общей БД) и не имеет
общей кодовой базы с другими микросервисами. Хотя есть и исключения, например
шаблон sidecar.

# общение микросервисов

Микросервисы слабо связаны друг с другом. Чаще всего они общаются синхронно через
HTTP или асинхронно с помощью очередей сообщений (RabbitMQ, Redis, Amazon SQS) или
логстрима (Kafka, Amazon Kinesis). У такого подхода много преимуществ:

# Плюсы микросервисов

 Масштабируемость. Благодаря высокой гранулярности и отсутствию
централизованных баз данных масштабируемость микросервисной архитектуры
достигает наивысшего показателя. Дополнительные экземпляры микросервисов
поднимаются легко, и при этом база нагружается запросами лишь от одного
микросервиса, а не от всей системы. А еще мы экономим деньги, потому что
масштабируем только те сервисы, на которые идет трафик.

Эластичность. Этот показатель тоже достигает экстремально высокого уровня.
Новые экземпляры запускаются в течение десятых, а то и сотых долей секунды. При
резком увеличении нагрузки на определенные микросервисы система может
автоматически поднять дополнительные реплики.

Гибкость и изменяемость. Как бы хорошо ни был спроектирован монолит, когда
система разрастается, его все тяжелее поддерживать. Поэтому рано или поздно код
придется рефакторить. Микросервисы в этом плане очень удобны. Они похожи на
кубики лего, из которых можно пересобрать новую фигуру, а если нужно, дополнить
проект новыми «кубиками»

Скорость и изолированность доставки. Микросервисы просто разрабатывать и
деплоить. Отдельный микросервис устроен довольно просто, а значит, его гораздо
легче дорабатывать, тестировать и развертывать, чем монолит с комплексной
логикой.

Изолированность разработки. Много маленьких команд справятся с общей задачей
быстрее, чем одна большая. Согласитесь, менеджерить работу в команде из трех
человек куда проще, чем в команде из 30.

Надежность. Тут тоже все на высоком уровне, хотя не все так однозначно. С одной
стороны, изолированность микросервисов повышает отказоустойчивость всей
системы, а с другой — чем больше интеграций, тем выше риск отказа. Тем не менее
на практике этот показатель у проектов на MSA — выше среднего.

# API (Application programming interface)

это контракт, который предоставляет программа.
«Ко мне можно обращаться так и так, я обязуюсь делать то и это».

в целом все API – обмен данными. Обмен данными означает, что обе
стороны могут взаимодействовать и есть подход к описанию того как это взаимодействие
будет происходить, т.е. есть некоторый формат.

совокупность инструментов и функций в виде
интерфейса для создания новых приложений, благодаря которому одна программа будет
взаимодействовать с другой. Это позволяет разработчикам расширять функциональность
своего продукта и связывать его с другими.

# Преимущество подхода на основе API к проектированию архитектуры приложения

он позволяет большому количеству физических клиентских устройств и типов
приложений взаимодействовать с данным приложением. Один API можно использовать не
только для вычислений на базе ПК, но также для мобильных телефонов и устройств
Интернета вещей. Общение не ограничивается взаимодействием между людьми и
приложениями. С развитием машинного обучения и искусственного интеллекта
взаимодействие между сервисами, поддерживаемое API, станет основным видом
деятельности Интернета.

# Типы API

REST, SOAP, GraphQL, gRPC

# Simple Object Access Protocol (SOAP)

основан на xml

простой протокол доступа к объектам. Это
стандартизированный API с высоким уровнем безопасности. В основном используется в
финансовой сфере. Сообщения передаются в формате XML, который представляет собой
текстовый формат файла. Он состоит из набора условных меток.

протокол
обмена структурированными сообщениями в распределённой вычислительной среде. Протокол
используется для обмена произвольными сообщениями в формате XML.
SOAP используется с различными протоколами, таким как SMTP, FTP, HTTP, HTTPS. Чаще всего — с
HTTP, как с наиболее универсальным: его поддерживают все браузеры и серверы.

# SOAP API

веб-сервис, использующий протокол SOAP для обмена сообщениями между
серверами и клиентами. При этом сообщения должны быть написаны на языке XML в соответствии
со строгими стандартами, иначе сервер вернёт ошибку.

# XML (Extensible Markup Language)

простой, очень гибкий текстовый формат,
устанавливающий набор правил для структурирования сообщений. XML создали для удобного
хранения и передачи данных.
А также при передаче данных от клиента на сервер и наоборот нет проблем с совместимостью
данных.

# XSD (XML Schema Definition)

язык описания структуры XML-документа. Он используется для
определения правил, которым должен подчиняться документ, и был разработан, чтобы его можно
было использовать в создании программного обеспечения для обработки XML-документов. Файл,
содержащий XML Schema, обычно имеет расширение «.xsd» (XML Schema definition).

# XML схема определяет

- элементы, которые могут появляться в XML документе;
- атрибуты, которые могут появляться в XML документе;
- какие элементы являются дочерними;
- порядок дочерних элементов;
- количество дочерних элементов;
- пустой ли элемент или может содержать текст;
- типы данных элементов и атрибутов;
- фиксированные значения и значения по умолчанию элементов и атрибутов.

# Комментарии в XML схема

могут появляться в любом месте документа за пределами другой разметки, кроме
того, они могут появляться в объявлении типа документа в местах, разрешённых грамматикой. Они
не являются частью символьных данных документа.
> \<!-- объявления для \<head> и \<body> --->

# ограничения для типов данных

Ограничитель / Описание

enumeration - Определяет список приемлемых значений

fractionDigits - Определяет максимальное число знаков после десятичной запятой. Должно быть равно или
больше нуля

length - Определяет точное число символов или объектов списка. Должно быть равно или больше нуля

maxExclusive - Определяет верхнюю границу для числовых значений

maxInclusive - Определяет верхнюю границу для числовых значений

maxLength - Определяет максимальное число символов или объектов списка. Должно быть равно или
больше нуля

minExclusive -Определяет нижнюю границу для числовых значений

minInclusive -Определяет нижнюю границу для числовых значений

minLength -Определяет минимальное число символов или объектов списка (больше или равно нулю)

pattern -Определяет точную последовательность приемлемых символов

totalDigits -Определяет точное количество допустимых цифр (больше нуля)

whiteSpace -Определяет способ обработки пробельных символов

# Web Services Description Language (WSDL)

о язык на основе XML, который используется для
описания веб-сервисов. Эта аббревиатура также используется для любого конкретного
WSDL-описания сервиса. Описание представляет собой текстовый WSDL-файл, который содержит
описание того, как можно вызвать службу, какие параметры она ожидает и в каком формате она
возвращает данные.

# Документ WSDL использует следующие элементы в определении сетевых служб

- Типы — контейнер для определений типов данных с использованием некоторой системы
типов (например, XSD).
- Сообщение — абстрактное типизированное определение передаваемых данных.
- Операция — абстрактное описание действия, поддерживаемого сервисом.
- Тип порта — абстрактный набор операций, поддерживаемых одной или несколькими
конечными точками.
- Привязка — конкретный протокол и спецификация формата данных для определённого типа
порта.
- Порт — единая конечная точка, определяемая как комбинация привязки и сетевого адреса.
- Сервис – набор связанных конечных точек.

# Структура SOAP-сообщения

Корректное SOAP-сообщение состоит из нескольких структурных элементов: Envelope, Header, Body
и Fault.

В самой первой строке объявляется XML.

# Объявление XML указывает

указывает версию языка, на которой написан документ. Поскольку интерпретация
содержимого документа зависит от версии языка, то Спецификация предписывает начинать
документ с объявления XML. В первой (1.0) версии языка использование объявления не было обязательным, в последующих версиях оно обязательно. Таким образом, версия языка определяется
из объявления, и если объявление отсутствует, то принимается версия 1.0.
Кроме версии XML объявление может также содержать информацию о кодировке документа и
«оставаться ли документу со своим собственным DTD (DTD («document type definition») — позволяет
определить список разрешённых элементов для какой-то сущности в XML-файле.), или с
подключённым».

# Envelope («конверт»)

Это корневой элемент. Определяет XML-документ как сообщение SOAP с
помощью пространства имён xmlns:soap=»<http://www.w3.org/2003/05/soap-envelope/»>. Если в
определении будет указан другой адрес, сервер вернёт ошибку.

# Header («заголовок»)

Включает в себя атрибуты сообщения, связанные с конкретным приложением
(аутентификация, проведение платежей и так далее). В заголовке могут использоваться три
атрибута, которые указывают, как принимающая сторона должна обрабатывать сообщение, —
mustUnderstand, actor и encodingStyle. Значение mustUnderstand — 1 или 0 — говорит принимающему
приложению о том, следует ли распознавать заголовок в обязательном или опциональном порядке.
Атрибут actor задаёт конкретную конечную точку для сообщения. Атрибут encodingStyle
устанавливает специфическую кодировку для элемента. По умолчанию SOAP-сообщение не имеет
определённой кодировки.

# Body («тело»)

Сообщение, которое передаёт веб-приложение. Может содержать запрос к серверу
или ответ от него.

# В каких случаях используют SOAP

- Асинхронная обработка и последующий вызов. Стандарт SOAP 1.2 обеспечивает клиенту
гарантированный уровень надёжности и безопасности.
- Формальное средство коммуникации. Если клиент и сервер имеют соглашение о формате
обмена, то SOAP 1.2 предоставляет жёсткие спецификации для такого типа взаимодействия.
Пример — сайт онлайн-покупок, на котором пользователи добавляют товары в корзину перед
оплатой. Предположим, что есть веб-служба, которая выполняет окончательный платёж.
Может быть достигнуто соглашение, что веб-сервис будет принимать только название
товара, цену за единицу и количество. Если сценарий существует, лучше использовать
протокол SOAP.
- Операции с состоянием. Если приложение требует, чтобы состояние сохранялось от одного
запроса к другому, то стандарт SOAP 1.2 предоставляет структуру для поддержки таких
требований.

# Тестирование Soap

Для тестирования SOAP используется инструмент SOAP UI

# SOAP UI

кроссплатформенное приложение с открытым исходным кодом для тестирования веб-сервисов сервис - ориентированных архитектур (SOA)

# параметры в ответе SOAP UI

- SpellResult — корневой элемент;
- error — информация об ошибке (может быть несколько или может отсутствовать);
- word — исходное слово;
- s — подсказка (может быть несколько или может отсутствовать).

# Элемент \<error> содержит атрибуты

- code — код ошибки
- pos — позиция слова с ошибкой (отсчёт от 0);
- row — номер строки (отсчёт от 0);
- col — номер столбца (отсчёт от 0);
- len — длина слова с ошибкой.

# SOAP — Assertion

тесты на проверку
результата ответа,

# TestSuite

набор тестов

# QUERY_MATCH

на сэмулированные ответы можно добавить проверки

# недостаткам SOAP

- объёмные сообщения;
- поддержка только одного формата — XML;
- схема работы по принципу «один запрос — один ответ»;
- смена описания веб-сервиса может нарушить работу клиента

# REST API (Representational State Transfer)

 передача
состояния представления. В отличие от SOAP, REST является архитектурным стилем, а не
протоколом

Для
веб-служб, построенных с учетом требований REST, применяют термин «RESTful»

это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют
RESTful.

# Свойства архитектуры rest

- производительность

- масштабируемость

# REST (Representational State Transfer)

определяет стиль взаимодействия (обмена данными) между разными компонентами
системы, каждая из которых может физически располагаться в разных местах. Этот
архитектурный стиль представляет собой согласованный набор ограничений, учитываемых
при проектировании распределённой системы.

# Архитектурный стиль

это согласованный набор ограничений.

# REST API может передавать сообщения в разных форматах

HTML, JSON, XML, или YAML.
Самый распространенный — JSON ( JavaScript Object Notatio). Он не привязан к языку
программирования, в нем меньше слов, его проще писать и читать и у него выше скорость
передачи сообщений. API передающее данные в формате JSON называется JSON REST API.

# стартовая строка запроса

METHOD — это как раз метод HTTP-запроса

URI — идентификатор ресурса,

VERSION — версия протокола.

# Заголовки HTTP (Headers)

позволяют клиенту и серверу отправлять дополнительную информацию с HTTP
запросом или ответом. В HTTP-заголовке содержится не чувствительное к регистру название, а
после (:) — значение. Пробелы перед значением игнорируются.

набор пар «имя-значение», разделённых двоеточием. В заголовках передаётся
различная служебная информация: кодировка сообщения, название и версия браузера, адрес, с
которого пришёл клиент (Referrer) и так далее.

# по каким контекстам может быть сгруппированы заголовки

- Основные заголовки применяются как к запросам, так и к ответам, но не имеют отношения к
данным, передаваемым в теле.
- Заголовки запроса содержат больше информации о ресурсе, который нужно получить, или о
клиенте, запрашивающем ресурс.
- Заголовки ответа (en-US) содержат дополнительную информацию об ответе, например, его
местонахождение, или о сервере, предоставившем его.
- Заголовки сущности содержат информацию о теле ресурса, например, его длину
содержимого или тип MIME.

# на какие группы можно разделить множество заголовков запроса

- Основные заголовки (General headers), например, Via (en-US), относящиеся к сообщению в
целом.
- Заголовки запроса (Request headers), например, User-Agent, Accept-Type, уточняющие запрос
(как, например, Accept-Language), придающие контекст (как Referer) или накладывающие
ограничения на условия (like If-None).
- Заголовки сущности, например, Content-Length, относящиеся к телу сообщения. Как легко
понять, они отсутствуют, если у запроса нет тела.

# тело сообщения

передаваемые данные. В ответе передаваемыми данными, как
правило, является html-страница, которую запросил браузер, а в запросе (например, в теле
сообщения) передаётся содержимое файлов, загружаемых на сервер. Но, как правило, тело
сообщения в запросе вообще отсутствует.

# HTTP-глаголы

HTTP определяет множество методов запроса, которые указывают, какое желаемое действие
выполнится для этого ресурса. Несмотря на то что их названия могут быть существительными, эти
методы запроса иногда называются HTTP-глаголами

# общие свойства методов групп команд

методы могут быть безопасными, идемпотентными
или кэшируемыми.

# методы

GET — получение ресурса, тело сообщения отсутствует

запрашивает представление ресурса. Запросы с использованием этого метода могут
только извлекать данные

 POST — создание ресурса

 PUT — обновление ресурса

 DELETE — удаление ресурса

HEAD — запрашивает ресурс так же, как и метод GET, но без тела ответа.

CONNECT — устанавливает «туннель» к серверу, определённому по ресурсу.

OPTIONS — используется для описания параметров соединения с ресурсом.

TRACE — выполняет вызов возвращаемого тестового сообщения с ресурса.

PATCH — используется для частичного изменения ресурса.

# Кеширование данных

Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного
использования ранее полученных ресурсов. Веб-кеши сокращают задержку и снижают сетевой
трафик, уменьшая тем самым время, необходимое для отображения ресурсов. Благодаря
HTTP-кэшированию сайты становятся более отзывчивыми.

# виды кеширования

- приватные кеши;
- кеши совместного использования

# кеши совместного использования (shared cache) (Общий прокси-кеш)

хранятся копии, которые могут направляться
разным пользователям.

кеш, который сохраняет ответы, чтобы их потом могли
использовать разные пользователи. Например, в локальной сети вашего провайдера или компании
может быть установлен прокси, обслуживающий множество пользователей, чтобы можно было
повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время
ожидания.

# Приватный кеш (private cache) браузера

предназначен для отдельного пользователя.

Кеш браузера содержит все документы, загруженные
пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при
навигации назад/вперёд, позволяет сохранять страницы или просматривать их код, не обращаясь
лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.

# Цели кеширования

повторное успользование уже сохранённых ресурсов
стандартные кеши HTTP обычно
способны кэшировать только ответы на запросы методом GET, а другие отклоняют

# что обычно записывается в кеш

- Успешно загруженные ресурсы: ответ 200 OK на запрос методом GET HTML-документов,
изображений или файлов.
- Постоянные перенаправления: ответ 301 Moved Permanently («перемещено навсегда»).
- Сообщения об ошибках: ответ 404 Not Found («не найдено»).
- Неполные результаты: ответ 206 Partial Content («частичное содержимое»).
- Ответы на запросы, отличные от GET, если есть что-либо, подходящее для использования в
качестве ключа кеша.

# Свежесть сохраненной копии в кеше

Однажды попав в кеш, ресурс теоретически может храниться там вечно.
Однако, поскольку объём
хранилища конечен, записи периодически приходится оттуда удалять. Этот процесс называют
вытеснением данных из кеша (cache eviction)
Кроме того, ресурсы могут изменяться на сервере,
поэтому кеш требуется обновлять. Поскольку HTTP является клиент-серверным протоколом, сервера
не могут сами обращаться к кешам и клиентам при изменении ресурса — им необходимо
договориться о сроке действия сохранённой копии. До его истечения ресурс считается свежим
(fresh), после устаревшим (stale).

# JSON (сокр. от англ. JavaScript Object Notation)

простой формат обмена данными, удобный для
чтения и написания как человеком, так и компьютером.

JSON часто используется для сериализации структурированных данных и обмена ими по сети,
обычно между сервером и веб-приложениями.

# из каких типов данных состоит JSON

- Строка
- Число
- Логическое значение
- Нуль
- Объект
- Массив

# Строка в JSON

состоит из символов Юникода, начинающихся с обратной косой черты (\\), либо
латинские буквы остаются без изменений:

# Числовые значения в JSON

```json
{
"number_1" : 210,
"number_2" : 215,
"number_3" : 21.05,
"number_4" : 10.05
}
```

# Логические значения в JSON

Булевы значения обозначаются как true или false. Логические значения не заключаются в кавычки и
рассматриваются как строковые значения

# Нуль в JSON

Нуль — это пустое значение. Если ключу не присвоено никакого значения, его можно считать
значением Null.

# Объект в JSON

Тип данных объекта JSON — это набор пар имени или значения, вставленных между {} (фигурными
скобками). Ключи должны быть строками и должны быть уникальными, разделёнными запятыми

# Массив в JSON

Тип данных массива — это упорядоченный набор значений. В JSON значения массива должны быть
строкой, числом, объектом, массивом, логическим значением или значением Null.

# Postman

инструмент с открытым исходным кодом, который используется для тестирования REST
API.

# Коллекции в Postman

группа сохранённых запросов. Каждый запрос, который вы отправляете в Postman,
отображается на вкладке «История» боковой панели. В небольших масштабах повторное
использование запросов через раздел истории удобно. По мере роста вашего использования
Postman может потребоваться много времени, чтобы найти конкретный запрос в вашей истории.
Вместо того чтобы прокручивать раздел истории, вы можете сохранить все свои запросы в виде
группы для более удобного доступа.

# API Builder

поддерживает запуск модульных тестов, они являются скорее
инструментом разработчика, а не тестировщика. Чтобы начать использовать API Builder, вы можете
создать новый API в своей рабочей области. Вы также можете переименовать или удалить
существующие API.

# Окружение в Postman

набор переменных, которые вы можете использовать в своих запросах Postman. Вы
можете использовать среды для группировки связанных наборов значений и управления доступом к
общим данным Postman, если вы работаете в команде.

# Мок-серверы в Postman

В Postman можно делать запросы, которые возвращают фиктивные данные, определённые в
Postman, если у вас нет готового производственного API или вы пока не хотите запускать свои
запросы с реальными данными. Добавляя фиктивный сервер в свою коллекцию и добавляя примеры
к своим запросам, вы можете имитировать поведение реального API.

# Мониторы в Postman

Этот раздел необходим для автоматизирования прогонов. Здесь имеется возможность планирования
прогонов и получение отчётов о результатах прогонов.

# История в Postman

В разделе с историей отображаются все выполненные ранее запросы через Postman.

# Автоматизация запросов в Postman на примере готовых сниппетов

можете
добавить код JavaScript для выполнения во время двух событий в потоке:

- Перед отправкой запроса на сервер в виде сценария предварительного запроса.
- После получения ответа в виде тестового скрипта на вкладке Tests.

# порядок выполнения скрипта для одного запроса в Postman

- Сценарий предварительного запроса, связанный с запросом, будет выполняться до отправки
запроса.
- Тестовый сценарий, связанный с запросом, будет выполняться после отправки запроса.

# Pre-request Script в Postman

это логика или часть кода, выполнение которого гарантировано до начала
выполнения запроса. Это позволяет добавить динамическое поведение для выполнения запроса.

Здесь важно отметить, что сценарии предварительного запроса также могут применяться на уровне
коллекции, что косвенно означает, что сценарий предварительного запроса будет применяться ко
всем запросам, являющимся частью этой коллекции.

Простыми словами, пользование pre-request script может быть полезно, если вам необходимо
передать какое-либо значение для переменной перед выполнением запроса.

# Вкладка Tests в Postman

необходима для написания тестов, которые будут выполняться после получения
ответа на запрос.
Код не обязательно писать с нуля. В Postman есть уже готовый список тестов для проверки API.
Любой из них можно отредактировать под свои нужды для экономии времени.

# Отличия SOAP от REST

SOAP — протокол, а REST — архитектурный стиль

REST поддерживает несколько форматов помимо XML: JSON, TXT, CSV, HTML. Вместо создания
громоздкой структуры XML-запросов при использовании REST чаще всего можно передать нужный
URL. Эти особенности делают стиль REST простым и понятным, а приложения и веб-сервисы,
использующие его, отличаются высокой производительностью и легко масштабируются.

# REST есть ряд недостатков

- при использовании REST сложнее обеспечить безопасность конфиденциальных данных;
- трудности с проведением операций, которым необходимо сохранение состояния. Как,
например, в случае с корзиной в онлайн-магазине, которая должна сохранять добавленные
товары до момента оплаты

# GraphQL

это язык запросов для API для получения данных. Это альтернатива REST API. Он
не специфичен для одной платформы и работает для всех типов клиентов, включая Android,
iOS или веб. Он располагается между сервером и клиентом и помогает запрашивать данные
более оптимизированным способом.

названии
технологии GraphQL две последние буквы, QL, означают «query language», то есть — язык
запросов. Речь идет, в буквальном смысле, о новом языке написания запросов на
получение данных

# Запросы GraphQL

это сущности, представляющие собой запрос к серверу на получение
неких данных.

# gRPC

это новый и современный фреймворк для разработки масштабируемых,
современных и быстрых API и дословно переводится как система удаленного вызова
процедур, разработанный компанией Google еще в далеком 2015 году. Используется
многими ведущими компаниями, такими как Google, Square и Netflix, и позволяет
программистам писать микросервисы на любом языке, который они хотят, сохраняя при
этом возможность легко устанавливать связь между этими сервисами.

# Протокол HTTP

предназначен для передачи содержимого в Интернете

это простой
протокол, который использует для передачи содержимого надежные службы протокола
TCP. Благодаря этому HTTP считается очень надежным протоколом для обмена
содержимым. Также HTTP является одним из самых часто используемых протоколов
приложений. Все операции в Интернете используют протокол HTTP. Подключение в HTTP
устанавливается по стандартному TCP-порту 80

это протокол, позволяющий получать различные ресурсы, например
HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP
является протоколом клиент-серверного взаимодействия, что означает инициирование
запросов к серверу самим получателем, обычно веб-браузером (web-browser). Полученный
итоговый документ будет (может) состоять из различных документов, являющихся частью
итогового документа: например, из отдельно полученного текста, описания структуры
документа, изображений, видео-файлов, скриптов и многого другого.

клиент-серверный протокол, то есть запросы отправляются какой-то одной
стороной — участником обмена (user-agent) (либо прокси вместо него). Чаще всего в
качестве участника выступает веб-браузер, но им может быть кто угодно, например, робот,
путешествующий по Сети для пополнения и обновления данных индексации веб-страниц
для поисковых систем.

# HTTPS

это безопасная версия протокола HTTP, которая реализует протокол HTTP с
использованием протокола TLS для защиты базового TCP-подключения. За исключением
дополнительной конфигурации, необходимой для настройки TLS, использование протокола
HTTPS по сути не отличается от протокола HTTP. Подключение в HTTPS устанавливается по
TCP-порту 443

# HTTP-коды

- Информационные 100 – 199
- Успешные 200 – 299
- Перенаправления 300 – 399
- Клиентские ошибки 400 – 499
- Серверные ошибки 500 – 599

# Информационные 100 – 199 (1xx: Information)

100: Continue

# Успешные 200 – 299 (2xx: Success)

200: OK

201: Created

202: Accepted

204: No Content

# Перенаправления 300 – 399 (3xx: Redirect)

301: Moved Permanently

307: Temporary Redirect

# Клиентские ошибки 400 – 499 (4xx: Client Error)

400: Bad Request

401: Unauthorized

403: Forbidden

404: Not Found

# Серверные ошибки 500 – 599 (5xx: Server Error)

500: Internal Server Error

501: Not Implemented

502: Bad Gateway

503: Service Unavailable

504: Gateway Timeout

# как взаимодействуют клиент и сервер

Клиенты и серверы взаимодействуют, обмениваясь одиночными сообщениями (а не
потоком данных). Сообщения, отправленные клиентом, обычно веб-браузером, называются
запросами, а сообщения, отправленные сервером, называются ответами.

# Составляющие систем, основанных на HTTP

Каждый запрос (англ. request) отправляется серверу, который обрабатывает его и
возвращает ответ (англ. response). Между этими запросами и ответами как правило
существуют многочисленные посредники, называемые прокси
1
, которые выполняют
различные операции и работают как шлюзы или кэш, например.

Обычно между браузером и сервером гораздо больше различных устройств-посредников,
которые играют какую-либо роль в обработке запроса: маршрутизаторы, модемы и так
далее. Благодаря тому, что Сеть построена на основе системы уровней (слоев)
взаимодействия, эти посредники "спрятаны" на сетевом и транспортном уровнях. В этой
системе уровней HTTP занимает самый верхний уровень, который называется
"прикладным" (или "уровнем приложений"). Знания об уровнях сети, таких как
представительский, сеансовый, транспортный, сетевой, канальный и физический, имеют
важное значение для понимания работы сети и диагностики возможных проблем, но не
требуются для описания и понимания HTTP.

# HTTP-запросы

 это сообщения, отправляемые клиентом, чтобы инициировать реакцию со стороны
сервера.

# Строка ответа HTTP (называемая строкой статуса)

содержит следующую информацию:

- Версию протокола, обычно HTTP/1.1.
- Код состояния (status code), показывающий, был ли запрос успешным. Примеры: 200, 404
или 302.
- Пояснение (status text). Краткое текстовое описание кода состояния, помогающее
пользователю понять сообщение HTTP

# Веб-сервер

обслуживает
(англ. serve) пользователя, предоставляя ему документы по запросу. С точки зрения
конечного пользователя, сервер всегда является некой одной виртуальной машиной,
полностью или частично генерирующей документ, хотя фактически он может быть группой
серверов, между которыми балансируется нагрузка, то есть перераспределяются запросы
различных пользователей, либо сложным программным обеспечением, опрашивающим
другие компьютеры (такие как кеширующие серверы, серверы баз данных, серверы
приложений электронной коммерции и другие).

Сервер не обязательно расположен на одной машине, и наоборот - несколько серверов
могут быть расположены (поститься) на одной и той же машине. В соответствии с версией
HTTP/1.1 и имея Host заголовок, они даже могут делить тот же самый IP-адрес.

# Прокси-сервер

это промежуточная программа или компьютер, используемый при навигации по
разным сетям Интернета. Они облегчают доступ к контенту во всемирной паутине. Прокси-сервер
перехватывает запросы и возвращает ответы; он может пересылать запросы или нет (например, в
случае кеша), и он может изменять его (например, изменяя его заголовки на границе между двумя
сетями). Прокси-сервер может находиться на локальном компьютере пользователя или в любом
месте между компьютером пользователя и конечным сервером в Интернете.

# Прокси

Между веб-браузером и сервером находятся большое количество сетевых узлов,
передающих HTTP сообщения. Из-за слоистой структуры большинство из них оперируют
также на транспортном сетевом или физическом уровнях, становясь прозрачным на HTTP слое и потенциально снижая производительность. Эти операции на уровне приложений
называются прокси.

# какие функции могут исполнять прокси

Они могут быть прозрачными или нет, (изменяющие запросы не
пройдут через них), и способны исполнять множество функций:

- caching (кеш может быть публичным или приватными, как кеш браузера)
- фильтрация (как сканирование антивируса, родительский контроль, …)
- выравнивание нагрузки (позволить нескольким серверам обслуживать разные
запросы)
- аутентификация (контролировать доступом к разным ресурсам)
- протоколирование (разрешение на хранение истории операций)

# Основные аспекты HTTP

- HTTP - прост
- HTTP - расширяемый
- HTTP не имеет состояния, но имеет сессию

# HTTP - прост

Даже с большей сложностью, введенной в HTTP/2 путем инкапсуляции
HTTP-сообщений в фреймы, HTTP, как правило, прост и удобен для
восприятия человеком. HTTP-сообщения могут читаться и пониматься
людьми, обеспечивая более легкое тестирование разработчиков и
уменьшенную сложность для новых пользователей.

# HTTP - расширяемый

Введенные в HTTP/1.0 HTTP-заголовки сделали этот протокол легким для
расширения и экспериментирования. Новая функциональность может быть
даже введена простым соглашением между клиентом и сервером о
семантике нового заголовка.

# HTTP не имеет состояния, но имеет сессию

HTTP не имеет состояния: не существует связи между двумя запросами,
которые последовательно выполняются по одному соединению. Из этого
немедленно следует возможность проблем для пользователя, пытающегося
взаимодействовать с определенной страницей последовательно, например,
при использовании корзины в электронном магазине. Но хотя ядро HTTP не
имеет состояния, куки позволяют использовать сессии с сохранением
состояния. Используя расширяемость заголовков, куки добавляются к
рабочему потоку, позволяя сессии на каждом HTTP-запросе делиться
некоторым контекстом или состоянием.

# HTTP и соединения

Соединение управляется на транспортном уровне, и потому принципиально выходит за
границы HTTP. Хотя HTTP не требует, чтобы базовый транспортного протокол был основан
на соединениях, требуя только надежность, или отсутствие потерянных сообщений (т.е. как
минимум представление ошибки). Среди двух наиболее распространенных транспортных
протоколов Интернета, TCP надежен, а UDP — нет. HTTP впоследствии полагается на
стандарт TCP, являющийся основанным на соединениях, несмотря на то, что соединение не
всегда требуется.

# HTTP/1.0

0 открывал TCP-соединение для каждого обмена запросом/ответом, имея два
важных недостатка: открытие соединения требует нескольких обменов сообщениями, и
потому медленно, хотя становится более эффективным при отправке нескольких
сообщений, или при регулярной отправке сообщений: теплые соединения более
эффективны, чем холодные.

# HTTP/1.1

предоставил конвейерную обработку (которую
оказалось трудно реализовать) и устойчивые соединения: лежащее в основе TCP
соединение можно частично контролировать через заголовок Connection

# HTTP/2

 сделал
следующий шаг, добавив мультиплексирование сообщений через простое соединение,
помогающее держать соединение теплым и более эффективным.

# HTTP поток

Когда клиент хочет взаимодействовать с сервером, являющимся конечным сервером или
промежуточным прокси, он выполняет следующие шаги:

1. Открытие TCP соединения: TCP-соединение будет использоваться для отправки
запроса (или запросов) и получения ответа. Клиент может открыть новое
соединение, переиспользовать существующее или открыть несколько
TCP-соединений к серверу.
2. Отправка HTTP-сообщения: HTTP-сообщения (до HTTP/2) являются
человекочитаемыми. Начиная с HTTP/2, простые сообщения инкапсулируются во
фреймы, делая невозможным их чтение напрямую, но принципиально остаются
такими же.
3. Читает ответ от сервера:
4. Закрывает или переиспользует соединение для дальнейших запросов.

# HTTP сообщения

HTTP/1.1 и более ранние HTTP сообщения человекочитаемые. В версии HTTP/2 эти
сообщения встроены в новую бинарную структуру, фрейм, позволяющий оптимизации,
такие как компрессия заголовков и мультиплексирование. Даже если часть оригинального
HTTP сообщения отправлена в этой версии HTTP, семантика каждого сообщения не
изменяется и клиент воссоздает (виртуально) оригинальный HTTP-запрос. Это также
полезно для понимания HTTP/2 сообщений в формате HTTP/1.1.

# два типа HTTP сообщений

 запросы и ответы

# Запросы

Запросы содержат следующие элементы:

- HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS
или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно,
клиент хочет получить ресурс (используя GET) или передать значения HTML-формы
(используя POST), хотя другие операция могут быть необходимы в других случаях.
- Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста,
например без протокола (http://), домена (здесь developer.mozilla.org), или TCP порта
(здесь 80).
- Версию HTTP-протокола.
- Заголовки (опционально), предоставляющие дополнительную информацию для
сервера.
- Или тело, для некоторых методов, таких как POST, которое содержит отправленный
ресурс.

# Ответы

Ответы содержат следующие элементы:

- Версию HTTP-протокола.
- HTTP код состояния, сообщающий об успешности запроса или причине неудачи.
- Сообщение состояния — краткое описание кода состояния.
- HTTP заголовки, подобно заголовкам в запросах.
- Опционально: тело, содержащее пересылаемый ресурс.

# The OpenAPI Specification (с англ. — «спецификация OpenAPI»; изначально известная как Swagger Specification)

 формализованная спецификация и экосистема множества
инструментов, предоставляющая интерфейс между front-end системами, кодом библиотек
низкого уровня и коммерческими решениями в виде API.

# Swagger

The OpenAPI Specification (с англ. — «спецификация OpenAPI»; изначально известная как
Swagger Specification) — формализованная спецификация и экосистема множества
инструментов, предоставляющая интерфейс между front-end системами, кодом библиотек
низкого уровня и коммерческими решениями в виде API. Вместе с тем, cпецификация
построена таким образом, что не зависит от языков программирования, и удобна в
использовании как человеком, так и машиной.

Относительно назначения, OpenAPI рассматривается как универсальный интерфейс для
пользователей (клиентов) по взаимодействию с сервисами (серверами). Если
спроектирована спецификация для некоторого сервиса, то на ее основании можно
генерировать исходный код для библиотек клиентских приложений, текстовую
документацию для пользователей, варианты тестирования и др. Для этих действий имеется
большой набор инструментов для различных языков программирования и платформ.

это фреймворк для спецификации RESTful API. Его прелесть заключается в том,
что он дает возможность не только интерактивно просматривать спецификацию, но и
отправлять запросы – так называемый Swagger UI.

# Написание документации Swagger

- Автогенерация на основе кода.
- Документация пишется отдельно от кода. Данный подход требует знать синтаксис
Swagger Specification. Документация пишется либо в YAML/JSON файле, либо в
редакторе Swagger Editor.

# Для чего необходимо тестирование веб-приложений

один из самых популярных видов приложений. В браузере
можно делать практически всё. И каждый тестировщик в своей работе обязательно столкнётся с
тестированием веб-приложений.

# Браузеры и движки (browser engine)

У современных браузеров обычно выделяется два: один
отвечает за HTML и CSS, второй — за интерпретацию скриптов, написанных на JavaScript

# несколько актуальных движков

- Gecko (мозила) — сегодня используется в Firefox и других продуктах, входящих в Mozilla, например, в
почтовом клиенте Thunderbird. Соответствующий JS-движок — SpiderMonkey. Разные версии
движка носят слегка различные наименования, так что мы можем встретить такие
обозначения, как IonMonkey или OdinMonkey, но это относится к одному и тому же продукту.
- Blink (хром, яндекс, опера, эдж) — сейчас это наиболее популярный движок. Он основа браузера с открытым кодом
Chromium, на базе которого, в свою очередь, разрабатывается браузер Chrome и
многочисленные сторонние браузеры: Opera, «Яндекс.Браузер», Atom от «Майл.Ру» и другие.
За основу Blink взят другой движок — WebKit, но сейчас они уже сильно отличаются. За
JS-часть отвечает движок V8, который разработала компания Google.
- WebKit (сафари) — движок для браузера Safari — стандартный браузер в macOS. WebKit основан на
другом движке KHTML, на котором построен браузер Konqueror в Linux/KDE. JavaScript в
браузере Safari обрабатывается движком Nitro.

Не так давно в эту компанию входили движки от Internet Explorer:

- Microsoft Trident — используется в Internet Explorer 11 и 12. Вместе с ним работает JS-движок
Chakra.
- EdgeHTML — основа для Microsoft Edge, браузера в Windows 10.
Но Trident уже давно не поддерживается самой компанией Microsoft, а EdgeHTML просуществовал
очень недолго и сейчас заменён на Blink, то есть внутри Internet Explorer находится Google Chrome.

# Веб-приложение (WEB)

приложение, не требующее установки, все обновления происходят на
сервере, доставляются пользователям сразу — достаточно просто перезагрузить страницу или
выйти, а потом снова зайти в аккаунт. Но иногда для его работы нужно установить дополнительные
библиотеки или использовать защищённые сетевые протоколы.

# Мобильная версия (Mobile WEB)

приложение, адаптированное под мобильную версию.
Адаптирован, значит, что пользователю будет комфортно работать с веб-приложением мобильного
устройства. Чаще всего, такие мобильные версии открываются по отдельному URL: в ссылке приписывается буква m

# почему в иногда открывая сайт на мобильном устройстве, в ссылке не прописывается буква m

существует
несколько способов перенаправления пользователей: с помощью PHP или .htaccess. Данный
редирект работает ориентируясь на юзер-агент (user agent)

Иными словами, сервер понимает, с какого устройства (мобильного или ПК) к нему обращается
пользователь и на такую версию сайта переадресовывает. Если у посетителя будет неизвестный
юзер-агент, то редиректа не произойдёт.

Существует второй способ — определять разрешение
экрана и показывать ту версию сайта, подходящую под размер экрана пользователя. В обоих случаях
используется адаптивная вёрстка.

# Адаптивная вёрстка

меняет дизайн страницы в
зависимости от размера экрана и ориентации девайса и считается неотъемлемой частью
современной веб-разработки. Она позволяет существенно экономить и не отрисовывать новый
дизайн для каждого разрешения, а менять размеры и расположение отдельных элементов.

# Медиазапросы (media queries)

правила CSS, которые позволяют управлять стилями элементов в
зависимости от значений технических параметров устройств. Иными словами, это конструкции,
позволяющие определять на основании некоторых условий, какие стили надо использовать на
веб-странице, и наоборот.

# Адаптивная вёрстка реализуется также через jQuery

# Bootstrap

HTML, CSS и JS фреймворк с открытым исходным кодом, который используется
веб-разработчиками для быстрой вёрстки адаптивных дизайнов сайтов и веб-приложений. С ним
верстаются сайты в несколько раз быстрее, чем на «чистом» CSS и JavaScript. Этот фреймворк —
набор CSS- и JavaScript-файлов, и, чтобы использовать эти файлы, они подключаются к странице.
После этого доступны инструменты этого фреймворка: колоночная система (сетка Bootstrap), классы
и компоненты.

# Способы тестирования адаптивной вёрстки

используются облачные фермы устройств (онлайн-сервисы,
предоставляющие доступ к множеству устройств), такие как: BrowserStack, Firebase Test Lab,
Samsung Remote Test Lab, AWS Device Farm, Sauce Labs, Xamarin Test Cloud, Perfecto и многие другие

# BrowserStack

предоставляет как разработчикам, так и тестировщикам, возможность
тестировать веб-приложения, а также мобильные приложения в браузерах на устройствах с
различными операционными системами и даже на реальных мобильных устройствах.

# User-Agent

это HTTP-заголовок, отправляемый клиентом серверу, который содержит строку,
описывающую клиентский браузер, операционную систему, разрядность и другие характеристики
клиента.

Типичная строка заголовка User-Agent для современного браузера выглядит примерно так:

>*Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.60*

# развитие браузеров

Вначале был один браузер Mosaic, а у него — User-Agent NCSA_Mosaic/2.0.
Через некоторое время
появился второй браузер, который в процессе разработки назывался Mozilla, но его коммерческим
названием стало Netscape Navigator. А вот в коде он так и остался Mozilla, поэтому его User-Agent был
Mozilla/1.0.

Чуть позже из того же браузера Mosaic вышел ещё один популярный продукт — Internet Explorer.  но сервера не
спешили отдавать ему продвинутые версии страниц, потому что он — не Netscape.

Тогда в Microsoft решили добавить строку Mozilla в свой User-Agent, и заголовок стал выглядеть
примерно так: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1). А расшифровывался он как
mozilla-совместимый MicroSoft Internet Explorer версии 2.0 на Windows 3.1.
Остальные браузеры, которые стали появляться позже, также унаследовали эту традицию и
дописывали себе слово Mozilla.
Netscape Navigator и Internet Explorer активно развивались, и в определённый момент Microsoft
добавила в User-Agent упоминание не только браузера, но и движка, и эта строка стала вида
Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0) — так себя идентифицировал браузер
Internet Explorer 8. Такая же штука появилась и в браузере Netscape, который к тому времени
переименовался в Mozilla Firefox, и его User-Agent тоже стал содержать название движка: Mozilla/5.0
(Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11.

Как ни удивительно, но «новый» браузер Mozilla Firefox неплохо справлялся с реализацией
стандартов HTML/CSS/JS и очень хорошо отображал страницы. Слово Mozilla не было уникальным
маркером для определения браузера, поэтому веб-разработчики стали вычислять Firefox по слову
Gecko в строке User-Agent.
А тем временем под Linux вышла очередная версия браузера Konqueror, работающего на движке
KHTML. Новая версия стала поддерживать различные стандарты не хуже Firefox, и чтобы получать те
же современные версии сайтов, что и Firefox, в User-Agent добавилось упоминание его движка
Gecko. Эти разработчики хотели сказать, что KHTML совсем как Gecko: Mozilla/5.0 (compatible;
Konqueror/3.2; Linux) (KHTML, like Gecko)

компания Apple берёт именно эту разработку для
создания собственного браузера Safari, движком которого стал переработанный KHTML под
названием Webkit. Safari унаследовал от своего прародителя упоминание like Gecko: Mozilla/5.0
(Macintosh; U; PPC Mac OS X; en-us) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.6, но добавил к
нему название своего движка — AppleWebKit, а также название браузера — Safari.

Затем на основе Webkit появился движок Blink и браузер Chrome, идентифицируя себя практически
как Safari, добавляя к той строке лишь версию Chrome:

>*Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.60
Safari/537.36*

Такой User-Agent можно прочитать как «Я браузер Chrome 87, но работаю совсем как Safari на
движке WebKit версии 537, который, вообще-то, движок KHTML, который совсем как движок Gecko,
на котором основана Mozilla».

# UI-элементы на странице

User Interface (дословно «пользовательский интерфейс») — то, как выглядит интерфейс

# Navbar

Navigation Bar (Навигационный бар) это часть пользовательского интерфейса, помогающая
пользователю перемещаться по разным страницам веб-приложения. Во время тестирования
панели навигации проверять необходимо корректную переадресацию на страницу, а также
возвращение на предыдущую страницу, откуда мы пришли

# Buttons

Кнопки — элементы, которые позволяют осуществить или подтвердить какое-либо действие на
странице. Во время тестирования стоит обращать внимание на состояние кнопок
(активна/неактивна), на кейсы при клике на кнопки с отключённым соединением с интернетом

# Spinner

Спиннер — компонент, предназначенный для создания на веб-проектах загрузочной анимации,
которая в основном используется для индикации на сайте не очень длительных по времени
процессов (в среднем выполняющихся в пределах от 1 до 4 секунд). Следует проверять
отображение и что этот элемент не «зависает» при загрузке контента.

# Input

Инпут — поле, позволяющее ввести какое-либо значение. При тестировании инпутов стоит
вспомнить техники тест-дизайна (граничные значения, классы эквивалентности). Часто инпуты
ограничивают по количеству допустимых символов как на клиенте, так и на сервере. Стоит
учитывать проверки на отображение ошибок, если поле неверно заполнено.

# Dropdown

Раскрывающийся список (выпадаюзий список) — элемент, служащий для отображения списка выбора, из которого
пользователь может выбрать одно или несколько значений. Выпадающие списки могут
содержать неактивные элементы (те элементы, которые невозможно выбрать).

# Select

Элемент, служащий для отображения списка выбора, с возможностью поиска по списку.

# Search & Placeholder

Поле ввода даёт возможность указать значение с помощью клавиатуры, например, выполнить
поиск.

Если из названия не очевидно, как заполнять поле, используется плейсхолдер — подсказка,
которая отображается внутри поля, пока оно не заполнено. При получении полем фокуса
плейсхолдер становится светлее, при вводе первого символа исчезает.

Поле поиска может содержать садджесты (подсказки), которые должны совпадать по смыслу с
вводимыми значениями.

# Cards

Карточки — контейнер (какая-то группа, набор элементов) содержимого с множеством вариантов
(например: карточки товаров, объявлений, блюд и т. д.). Часто в различных веб-приложениях
ломается выдача и отображение карточек на разных разрешениях экранов

# Carousel

Карусель — это слайд-шоу для циклического просмотра серии контента. При тестировании
каруселей уделять стоит отдельное внимание анимации контента.

# Tags input

Тэги или баблы — элемент выбора какого-либо параметра, чаще всего используется в фильтрах.
Теги могут быть выбраны, а может пользователь их удалить.

# Progress bars

Индикатор выполнения — элемент, который позволяет показывать прогресс выполнения
определённых задач вроде скачивания или загрузки, в основном всё, что занимает некоторое
время. Во время тестирования стоит обращать внимание на анимацию и действительный
прогресс выполнения (загрузки или индикатор выполнения каких-либо действий пользователя).

# Slider

Слайдер или ползунок — предназначен для ввода данных в указанном диапазоне.

# Navigation

Навигационная панель — элемент, позволяющий перемещаться между элементами страницы.

# Pagination

Пагинация — отображение разбивки на страницы. При выборе той или иной страницы стоит
обращать внимание на то, что действительно эта страница открывается.

# Checkbox

Чекбокс используется для управления параметром с двумя состояниями. Используют чекбоксы в
фильтрах, в различных меню для выбора дополнительных ингредиентов, опций и много другого.

# Radio Button

Группа радиокнопок используется для выбора одного значения из нескольких. Важно во время
проверки учитывать кейс, что должно быть выбрано хотя бы одно значение, в отличие от
чекбокса

# Hamburger menu

Гамбургер меню — меню, скрытое от пользователей.

# Kebab-menu

Кебаб-меню (потому что три точки, расположенные вертикально, напоминают люля-кебаб)
содержит действия с объектом.

# Switches

Переключает состояния. Например, включает или отключает уведомления в настройках.

# Tooltip

Тултип — это подсказка, появляющаяся при наведении на элемент.

# Form

Форма — раздел, позволяющий пользователю вводить информацию для последующей обработки
системой.

# Modal window

Модальное окно — это элемент интерфейса, которой визуально представляет собой
«всплывающее окно», отображающееся над остальной частью страницы. При этом показ окна
обычно сопровождают затемнением всей другой части страницы. Это действие позволяет
визуально отделить его от остального содержимого страницы, а также показать, что в данный
момент только оно одно является активным элементом

# Footer

Подвал сайта — раздел, где располагается автор сайта, дата документа, контактная и правовая
информация и многое другое.

# Тестирование UI и UX (UX Design или User Experience Design)

аналитическая и техническая область разработки, в то время как UI Design или User Interface Design
— то, что мы иногда ошибочно называем графическим дизайном

# User experience

 это процесс определения проблем пользователя и решение этих проблем с целью
повышения его удовлетворённости. Улучшение удобства использования, простота использования и
удовлетворение, которое клиент получает при взаимодействии с продуктом, определяют качество и
востребованность этого продукта

# Инструменты для создания интерфейсов

Zeplin — один из инструментов для совместной работы дизайнеров UI и фронтенд-разработчиков.
Дизайнеры экспортируют файлы из Photoshop или Sketch в Zeplin, и он отображает все свойства
дизайна для разработчиков.

Figma — графический редактор для совместного проектирования сайтов, приложений и других
дизайнерских продуктов. Она появилась как аналог Sketch и Adobe XD, но спустя пару лет стала
одним из самых популярных инструментов у дизайнеров.

# Инструменты для создания интерфейсов позволяют

- изучать дизайн, подготовленный в Photoshop или Sketch, без необходимости использования
оригинальных программ и быстро получать размеры в соответствии с платформой, для
которой ведётся разработка;
- получать все необходимые элементы дизайна, такие как изображения и иконки, а также все
свойства объектов (шрифты, цвета и размеры);
- экспортировать ресурсные файлы для любых элементов, будь то текст, кнопка или что-то
ещё;
- добавлять комментарии или заметки для членов команды прямо в текущем макете.

# Тестирование вёрстки (PerfectPixel, Page Ruler)

Необходимо проводить тестирование вёрстки. Существует множество инструментов,
рассмотрим несколько из них.

Расположение кнопок, различных элементов должно быть 1:1 по сравнению с макетом. Допускается
расхождение с макетом, чтобы не затягивать релиз, но чаще всего расположения, цвета — сверяют с
макетом. Существует плагин Pixel Perfect (для Mozilla Firefox и Google Chrome).

# Page Ruler

это отличный инструмент для frontend разработчиков и
тестировщиков, который помогает определить ширину, высоту и положение любого элемента на
странице.

# Кросс-браузерное тестирование

проверка отображения и работы веб-приложения в разных
браузерах. Ручное кросс-браузерное тестирование достаточно доступно, так как браузеры — это
бесплатное программное обеспечение, и любой пользователь может установить себе несколько
браузеров, чтобы посмотреть отображение сайта и сравнить результаты работы приложения в
разных браузерах.

# инструменты для кросс - браузерного тестирования

BrowserStack

Samsung Remote Test Lab

# Кросс-платформенное тестирование

тестирование веб-приложения под разными
операционными системами либо под разными видами устройств (десктоп, мобильный, планшет).

# направления «кросс» тестирования

1. Браузеры: Chrome, Firefox, Safari, Internet Explorer, Edge, UC Browser, Opera и другие.
2. Операционные системы: Windows, Android, iOS, Mac OS, Linux.
3. Устройства: ПК (десктопы и ноутбуки), смартфоны, планшеты, телевизоры и другие.

# на что стоит обращать внимание при кросс-браузерном тестировании со стороны приложения

1. Отображение страниц, то есть вёрстка (HTML + CSS).
2. Работоспособность различного интерактивного инструментария (JavaScript)

При оформлении бага, найденного при кросс-тестировании, не забываем указывать:

- операционную систему;
- версию ОС;
- браузер и его версию

# как тестироващики иногда планируют кросс-браузерное тестирование?

используя таблицу
поддержки браузеров и операционных систем. Она позволяет убедиться, что покрыты все
требуемые вариации и поддерживаемые десктопными и мобильными операционными системами
браузеры, а неподдерживаемые или не нуждающиеся в проверке — исключены из тестирования

# Что такое SPA-приложение?

SPA (Single Page Application)
одностраничное приложение, содержащее HTML-страницу, которая динамически (без полной
перезагрузки) обновляется в ответ на действия пользователя
Подобный эффект для SPA обеспечивают современные
JavaScript фреймворки (jQuery для небольших проектов и Angular для крупных)

# Ajax (Asynchronous JavaScript and XML)

подход к построению интерактивных пользовательских
интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с
веб-сервером

# как работает Ajax

он запрашивает у сервера недостающую информацию и добавляет её на
страницу. А сама страница не перезагружается.

# DevTools

о набор инструментов для веб-разработчиков, встроенных непосредственно в браузер.
Этот набор инструментов позволяет тестировать, отлаживать, профилировать, проверять код на
соответствие стандартам и делать многое другое. Инструменты для разработчиков имеются во всех
современных браузерах, таких как Chrome, Mozilla Firefox, Safari и многих других.

# Структура DevTools

Панель Elements используется для выбора и редактирования любых HTML-элементов на странице.
Позволяет свободно манипулировать DOM и CSS.

Панель Console применяется для логирования диагностической информации в процессе разработки
или взаимодействия с JavaScript на странице.

Панель Recorder применяется для записи, воспроизведения и измерения пользовательских
действий.

Панель Sources показывает все файлы, подключённые к текущей странице.

Панель Network позволяет мониторить процесс загрузки страницы и всех файлов, которые
подгружаются при её загрузке.

Панель Performance отображает таймлайн использования сети, выполнения JavaScript-кода и
загрузки памяти, применяется для оценки производительности работы страницы в целом.

Панель Memory используется для отслеживания нагрузки, которую оказывает выполнение JS-кода
на систему.

Панель Application содержит инструменты для просмотра всех загруженных ресурсов и работы с
ними: cookie, кеша приложения, изображений, шрифтов, таблиц стилей, локального хранилища.

На панели Security отображается информация о протоколе безопасности, данные о сертификате,
если он есть, безопасной загрузке ресурсов. Инструмент используется для обнаружения проблем
безопасного или небезопасного содержимого, проблем сертификатов и так далее.

Панель Lighthouse: после выбора параметров и запуска системы аудита происходит анализ
загружаемой страницы и предоставляются предложения по оптимизации страницы для уменьшения
времени её загрузки и увеличения отзывчивости.

# Device Toolbar

r служит для эмуляции внутри браузера различных разрешений экрана и
разных устройств, например, телефонов или планшетов. Они используются для базового
тестирования совместимости сайта с разными устройствами

Активация Device Toolbar происходит при клике на кнопку Device Toolbar или комбинацией клавиш
Ctrl+Shift+M:

# Доступно несколько режимов подключения Device Toolbar

- Mid-tier mobile (средняя скорость соединения)
- Low-end mobile (слабая скорость соединения)
- Offline (без сети)

# собственные настройки Device Toolbar

Show/Hide device frame включает и отключает отображение рамки для некоторых устройств.

Show/Hide media queries включает наглядный график отображения загрузки медиа запросов:

Show/Hide rules включает отображение линейки:

Также можно сделать скриншот страницы видимой части (Capture screenshot) или же полностью всей
страницы (Capture full size screenshot):

# Elements

При активном пункте меню Elements можно видеть всё DOM-дерево веб-страницы, изменять
свойства HTML-элемента и отслеживать изменения на веб-странице без перезагрузки,
просматривать ссылки и многое другое:

# Event Listeners

содержит все события, относящиеся к конкретному элементу. Например, у
активного элемента прописывается выполнение определённого JavaScript-кода при нажатии
на элемент. Тогда такое событие будет описано как click в этой вкладке:

# DOM Breakpoints

 точки останова для элемента. Используются программистами для
отладки JavaScript-кода. Программист может добавить остановку выполнения скрипта при
изменении DOM, затрагивающем этот элемент: изменении атрибутов этого элемента,
дочерней структуры DOM или при полном удалении элемента:

# Properties

список всех свойств элемента:

# Ключевые возможности Elements

1. Просмотр и редактирование в live-режиме любого элемента DOM.
2. Просмотр и изменение CSS-правил, применяемых к любому выбранному элементу в панели
Styles.
3. Просмотр всего списка событий и свойств для элемента на соответствующих вкладках.

# Способы поиска подходящего элемента для работы

1. При наведении курсора на код соответствующий элемент на самой странице автоматически
подсвечивается, а также указывается название тега и его размер в пикселях:
Если у элемента есть внутренние и внешние поля, они выделяются цветом:

2. Поиском по DOM-дереву. На панели инструментов нажимаем Ctrl+F и вводим строку для
поиска, например, тег, CSS-класс или XPath:

# Работа с конкретным элементом

Выбрав конкретный элемент, можно менять его свойства и смотреть, как это влияет на страницу.
Например, так меняется имя тега. Закрывающий тег автоматически изменится. Аналогично
меняются названия классов, параметры высоты и ширины, отступы — все поля доступны для
редактирования. Изменения применяются сразу после клика вне тега.

# Дополнительные функции редактирования элементов

доступны по правому клику на элемент:
Через это меню можно быстро отредактировать элемент как HTML в текстовом поле для ввода,
удалить элемент, спрятать его или добавить к нему атрибуты.

# Активация псевдоклассов

Псевдоклассы на элементах вызываются, чтобы исследовать, как элемент отреагирует, если на
него, например, навести мышку. Мы можем активировать псевдоклассы active, focus, hover и
visited.

Активировать псевдокласс можно через меню, доступное по правому клику на элемент:

# DOM (Document Object Model)

«объектная модель документа». Это программный интерфейс,
позволяющий программам и скриптам представлять содержимое HTML, XHTML и XML-документов в
виде дерева, изменять содержимое, структуру и оформление таких документов.

Когда мы загружаем страницу из интернета, браузер в ответе на GET-запрос получает исходный код
страницы, которую надо отобразить. Компонент браузера, отвечающий за работу с HTML,
анализирует этот исходный код и из него собирает собственную модель страницы в памяти,
используя DOM. DOM необязательно будет соответствовать исходному коду страницы.

# XPath

 это язык запросов, позволяющий найти определённый элемент в дереве элементов DOM
(HTML, XML).

XPath использует обозначение пути (как в URL-адресах) для навигации по структуре
HTML-документа.

Путь XPath состоит из шагов адресации, разделённых символом «/»

**Путь может быть абсолютным (или полным) и относительным.**

Полный путь всегда начинается с
корневого элемента — HTML, и он в общем случае определяет строго один элемент. В начале полного
пути ставится знак «/».

Относительный путь начинается с символов «//» и определяет некоторую последовательность
элементов внутри дерева DOM.

>//table/tr[1]/td[1]/span.

Этот код найдёт все элементы span, расположенные в первой ячейке первой строки таблицы. Если
на странице несколько таких таблиц, то и элементов span будет найдено несколько

# из чего состоит шаг адресации XPath

1. Ось, представляющая собой направление, в котором происходит поиск по дереву элементов.
По умолчанию значение оси child::, то есть осуществляется переход к дочерним элементам,
и зачастую этого варианта достаточно, но есть и другие варианты осей:
    - child:: — множество элементов-потомков, расположенных на один уровень ниже.
Это название можно опускать, оно считается значением по умолчанию.
    - descendant:: — рекурсивное множество всех элементов-потомков.
    - descendant-or-self:: — полное множество элементов-потомков и текущий элемент.
Основа для поиска относительного пути: ось /descendant-or-self::node()/
записывается как //.
    - ancestor:: — множество элементов-предков.
    - ancestor-or-self:: — множество элементов-предков и текущий элемент.
    - parent:: — родительский элемент. Это обращение можно заменить на ..
    - self:: — текущий элемент. Это обращение заменяется на .
    - following:: — множество элементов, расположенных ниже текущего элемента по
дереву, на всех уровнях и слоях, исключая собственных потомков.
    - following-sibling:: — содержит множество братских элементов того же уровня,
следующих за текущим слоем.
    - preceding:: — множество элементов, расположенных выше текущего элемента по
дереву, на всех уровнях и слоях, исключая множество собственных предков.
    - preceding-sibling:: — множество братских элементов того же уровня,
предшествующих текущему слою.
    - attribute:: — множество атрибутов текущего элемента, обычно заменяется символом
@.
    - namespace:: — содержит множество элементов, относящихся к тому или иному
пространству имён, то есть содержится атрибут xmlns.
2. Выражение, определяющее отбираемые элементы, например, имя тега (html), значения
атрибута (@id=”form”), все элементы (*).
3. Предикаты — дополнительные условия отбора. Их может быть несколько. Каждый предикат
заключается в квадратные скобки [ ] и подразумевает логическое выражение для проверки
отбираемых элементов. Если предиката нет, то отбираются все подходящие элементы.
Наиболее популярные варианты предикатов:
    - [N], где N — любое натуральное число, выберет элемент с порядковым номером N,
например, подходящую строку таблицы или элемент списка.
    - [last()] — выберет последний элемент из множества.
    - [@attribute=”value”] — выберет элемент, у которого есть атрибут attribute и его
значение равно value.
    - [contains(@class, “name”)] — выберет элемент, у которого есть атрибут class, и его
значение содержит подстроку name.

# URI

(Uniform
Resource Identifier) — унифицированный идентификатор ресурса

абсолютный путь

# URL

 (Uniform Resource Locator) —
унифицированный локатор ресурса

относительный путь

# Структура URI

Абсолютные ссылки указывают полный путь к ресурсу

<схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<путь>][?<параметры>][#<якорь>]

Схема — схема обращения к ресурсу. В большинстве случаев имеется в виду сетевой протокол,
например, http.

Логин — имя пользователя, используемое для доступа к ресурсу.

Пароль — пароль указанного пользователя.

Хост — доменное имя (site.com) или IP-адрес (127.0.0.1).

Порт — порт для подключения.

Путь — информация о месте нахождения ресурса на конкретном хосте.

Параметры — строка запроса с передаваемыми на сервер методом GET параметрами. Начинается с
символа «?», в качестве разделителя используется &. Пример:
?параметр1=значение1&параметр2=значение_2.

Якорь — идентификатор якоря внутри документа.

# типы относительных ссылок

1. Ссылка сетевого пути. Например, //mysite.com/files/. Эта ссылка перенаправляет на
указанный адрес с использованием текущей схемы. То есть, если мы находимся на
<https://anysite.com>, откроется адрес <https://mysite.com/files/>, а если на ftp://anysite.com —
ftp://mysite.com/files. Полный адрес ресурса высчитывается относительно URI-схемы.
2. Ссылка абсолютного пути. Она имеет вид /path/to/some/uri и начинается с символа «/»,
который указывает, что отсчёт надо начинать с корня домена. В этом случае откроется ресурс
с этого же домена, но путь к конечному ресурсу будет одинаков для всех страниц на этом
домене.
3. Ссылка относительного пути. Такая ссылка высчитывается относительно текущего адреса.
Например, ссылка вида images/photos/photo01.jpg означает, что для подразделов сайта
mysite.com/events/ и mysite.com/tours/ она будет указывать на разные файлы. Строка «../»
говорит о переходе на один уровень вверх по структуре пути. Если ссылка
../images/photos/photo02.jpg находится на странице <http://mysite.com/events/about.html>, то
полный путь будет <http://mysite.com/images/photos/photo02.jpg>. А если на той же странице
есть ссылка images/photos/photo02.jpg, то полный путь —
<http://mysite.com/events/images/photos/photo02.jpg>.
4. Ссылка внутри документа. Она задаётся посредством якоря #. Например, можно в начале
документа присвоить какому-то элементу name="top”, тогда ссылка вида \<a
href=”#top”>Наверх</a> перекинет нас в начало документа.

# какие есть типы ссылок

Кроме ссылок типа http(s), есть множество других типов ссылок (схем) в веб-приложениях:

- mailto;
- tel;
- javascript;
- ftp;
- telnet;
- file;
- git;
- xmpp;
- skype;
- steam;
- tg;
- многие другие

А ещё можно создать собственную схему и задать её обработку определённому приложению.

# Console

Вкладка Console позволяет просматривать, отлаживать и выполнять JS-код для загруженной
страницы.

# Recorder

Панель Recorder применяется для записи, воспроизведения и измерения пользовательских
действий

# Sources

Основное назначение этой вкладки — работать с исходным кодом файлов веб-приложения.

Эта вкладка имеет несколько вложенных вкладок: Page, Filesystem, Overrides, Content Scripts,
Snippets.

# Вкладка Page

показывает все файлы, которые используются на этой странице — сам исходный код,
файлы стилей, код на JavaScript, изображения, шрифты и так далее.

# На вкладке Filesystem

можно добавить папки с диска и посмотреть содержимое текстовых файлов
(html, css, js), отредактировать код, скопировать его или сохранить изменённый файл как новый. Эта
вкладка используется и как полноценный редактор кода, если подключиться к локальным файлам:

# Network

Эта вкладка позволяет мониторить процесс загрузки страницы и всех файлов, которые
подгружаются при загрузке

Её удобно использовать для оптимизации загрузки страниц и мониторинга запросов и ответов

На панели отображается таблица всех запросов к данным и файлам, над ней располагаются кнопки
для фильтрации запросов, очистки таблицы или включения и отключения записи запросов, кнопки
управления отображением таблицы

# дополнительные переключатели Network

1. Preserve log — не очищать таблицу при перезагрузке страницы.
2. Disable cache — отключить кеш браузера — будет работать только при открытом DevTools.
3. Offline — эмулирует отсутствие интернета, также позволяет эмулировать скорость
скачивания и загрузки данных и пинг для различных типов сетей.

Под таблицей указывается количество всех запросов, общее количество загруженных данных,
общее время загрузки всех данных, время загрузки и построения DOM-дерева и время загрузки всех
ресурсов, влияющих на отображение этой страницы.

# Ключевые возможности Network

1. Возможность отключить кеширование или установить ограничения пропускной способности.
2. Получение подробной таблицы с информацией о каждом запросе.
3. Фильтрация и поиск по всему списку запросов.

# Время загрузки страницы DOMContentLoaded в панели Network

В инструментах разработчика можно увидеть время DOMContentLoaded и общее время загрузки.
Чтобы его отобразить, выбираем панель Network и нажимаем Ctrl + R для обновления страницы.
Появится синяя линия для DOMContentLoaded и красная — для общего времени загрузки. Обычно
всё, что находится справа от синей линии или касается её, — это данные, которые блокируют DOM.
Они называются ресурсами блокировки рендеринга.

# Режим диафильма Capture screenshots в панели Network

Функция захвата скриншотов позволяет видеть, как страница отображается от начала до конца. Она
создаёт скриншоты в процессе загрузки. Это отличный способ увидеть, как рендерится страница в
браузере при загрузке.

Для этого кликаем на панель Network, открываем настройки, включаем Capture screenshots и
нажимаем клавиши Ctrl + R для обновления страницы. Затем панель покажет, как страница
отображается в процессе загрузки.

# Фильтры (Filter)

Раздел фильтров позволяет показывать только элементы, удовлетворяющие определённым
условиям.

# набор предустановленных фильтров

1. All — все элементы, без фильтрации.
2. XHR (XMLHttpRequest) — запросы к серверу из JavaScript-кода.
3. JS — только файлы JavaScript (*.js).
4. CSS — только файлы стилей (*.css).
5. Img — только изображения: JPEG, GIF, PNG, SVG и другие.
6. Media — аудио- и видеоматериалы.
7. Font — шрифты.
8. Doc — документы, под которыми обычно подразумеваются сами HTML-страницы (text/html).
9. WS (WebSocket) — запросы по технологии веб-сокетов. Могут быть, например, в чатах.
10. Manifest — файлы манифеста. Специальные файлы для настройки отображения сайта на
мобильных устройствах.
11. Other — остальное.

# что можно вводить в поле Filter

можно вводить специальные строки, чтобы отфильтровать результаты по конкретному
запросу, например,

Is:running — для просмотра всё ещё выполняющихся на странице запросов,

larger-than:1024 — для просмотра ресурсов размером более 1024 байт,

status-code:200 — для
просмотра всех успешно загруженных ресурсов.

Можно использовать несколько свойств одновременно, разделяя их пробелами. Например,
mime-type:image/gif larger-than:1K отображает все GIF-файлы, размер которых превышает один
килобайт. Эти фильтры с несколькими свойствами эквивалентны операциям «и». Операции «или» в
настоящее время не поддерживаются.

# Все поддерживаемые свойства Filter

1. domain: — отображать только ресурсы из указанного домена. Маска (*) используется для
отображения нескольких доменов. Например,* .com отображает ресурсы со всех доменов,
заканчивающихся на .com. DevTools автоматически подтягивает все домены, запрошенные
сайтом, и добавляет их в подсказки.
2. has-response-header: — показать ресурсы, которые содержат указанный HTTP-заголовок в
ответе.
3. is:running — позволяет найти ресурсы типа WebSocket.
4. larger-than: — показать ресурсы, размер которых превышает указанный размер в байтах.
Установка значения 1 000 эквивалентна установке значения 1k.
5. method: — показать ресурсы, которые получены с использованием указанного HTTP-метода:
GET, POST и так далее.
6. mime-type: — показать ресурсы с выбранным MIME-типом.
7. mixed-content: — показать все ресурсы со смешанным контентом (mixed-content: all) или
только те, что отображаются сейчас (mixed-content: display).
8. scheme: — показать ресурсы, полученные по HTTP (scheme:http) или HTTPS (scheme:https).
9. set-cookie-domain: — показать ресурсы, которые имеют заголовок Set-Cookie с указанным
доменом.
10. set-cookie-name: — показать ресурсы с заголовком Set-Cookie с именем, соответствующим
указанному значению.
11. set-cookie-value: — показать ресурсы, которые имеют заголовок Set-Cookie со значением,
соответствующее указанному в фильтре значению.
12. status-code: — отображать только те ресурсы, HTTP-код состояния которых соответствует
указанному коду: 200, 301, 404 и так далее.

# Профили сети

Мы можем добавить настраиваемые профили сети. Это полезно, если надо протестировать свой
проект на определённой скорости загрузки:

Чтобы добавить настраиваемый профиль, кликаем на панель Network и выбираем раскрывающийся
список Online. Затем кликаем на Custom — Add — Add custom profile и вводим название, скорость
скачивания и загрузки, задержку.

# Performance

Панель отображает таймлайн использования сети, выполнения JavaScript-кода и загрузки памяти.
После первоначального построения графиков таймлайна станут доступны подробные данные о
выполнении кода и обо всём жизненном цикле страницы. Можно будет ознакомиться со временем
исполнения отдельных частей кода, появится возможность выбрать отдельный промежуток на
временной шкале и ознакомиться с тем, какие процессы происходили в этот момент.

Инструмент применяется для улучшения производительности страницы в целом.

# Ключевые возможности Performance

1. Возможность сделать запись, чтобы проанализировать каждое событие, которое произошло
после загрузки страницы или взаимодействия с пользователем.
2. Возможность просмотреть FPS, загрузку CPU и сетевые запросы в области Overview.
3. Возможность посмотреть детали по каждому событию.
4. Возможность изменить масштаб таймлайна, чтобы сделать анализ проще.

# Memory

Панель «Память» в Chrome Developer Tools предоставляет информацию о том, как страница
использует память. Утечки памяти происходят, когда веб-сайт потребляет больше ресурсов, чем
необходимо. Серьёзные утечки памяти могут даже сделать сайты непригодными для использования.

# три вариантра исследования по использованию памяти веб-сайта

1. Heap snapshot — распределение памяти по DOM.
2. Allocation instrumentation on timeline — выделение памяти в процессе загрузки страницы.
3. Allocation sampling — измерение выделенной памяти для «долгоиграющих» запросов.

# Ключевые возможности Memory

1. Исправление проблем с памятью.
2. Профилирование CPU при работе с JavaScript.

# Application

Вкладка для инспектирования и очистки всех загруженных ресурсов, в том числе IndexedDB или
Web SQL баз данных, local и session storage, cookie, кеша приложения, изображений, шрифтов и
таблиц стилей.

# Ключевые возможности Application

1. Быстрая очистка хранилищ и кеша.
2. Инспектирование хранилищ, баз данных и кеша, управление ими.
3. Инспектирование и удаление файлов cookie.

# Кеш браузера

У каждого браузера есть особая папка на жёстком диске, в которую сохраняются элементы
веб-страниц, запрашиваемых в браузере. К этим элементам относятся изображения, видео, стили,
скрипты и многое другое — в общем, всё, что нечасто меняется и часто имеет значительный объём.
При загрузке страницы браузер сбрасывает этот контент на жёсткий диск. Эта особая папка
называется кеш браузера, а сохранённые на диск данные — закешированными данными.

# для чего используется кеш

кеш используется, чтобы ускорить загрузку страниц, которые мы уже
посещали. Если элементы сайта уже сохранились в кеше браузера, то при его повторном открытии
часть информации, что занимает большой объём, будет загружаться не из сети, а прямо из кеша
браузера (с компьютера). Такая страница откроется очень быстро.

# Cookie

HTTP-cookie — это небольшой фрагмент данных, отправляемых с веб-сайта и сохраняемых
браузером на пользовательском компьютере во время просмотра сайта

cookie — это
наиболее распространённый метод, которым веб-серверы определяют, вошёл пользователь в систему или нет, и если да, то с какой учётной записью.

Cookie также используются для отслеживания действий пользователей на сайте

# для чего разработаны Cookie

чтобы
сайты:

надёжно запоминали информацию о состоянии, например, товары, добавленные в корзину
интернет-магазина;

или сохраняли информацию о действиях пользователя на сайте, включая нажатие на конкретные
кнопки, вход в систему или посещённые страницы;

запоминали информацию, которую пользователь ранее вводил в поля формы — имена, адреса,
пароли.

# Типы cookie

Сессионные cookie

Постоянные cookie

Сторонние cookie

Зомби-cookie

# Сессионные (временные) cookie

есть только в оперативной памяти и только пока пользователь
находится на сайте. Браузеры обычно удаляют сессионные cookie после закрытия окна браузера. В
отличие от других типов cookie, сессионные cookie не имеют истечения срока действия, и поэтому
браузеры понимают их как временные.

# Постоянные cookie

Постоянные cookie-файлы удаляются в конкретную дату или через определённый промежуток
времени. Это означает, что информация о cookie будет передаваться на сервер каждый раз, когда
пользователь посещает веб-сайт, которому эти cookie принадлежат. Такие cookie иногда называются
следящими, поскольку рекламодатели обычно записывают с их помощью предпочтения
пользователя в течение долгого времени. Однако cookie используются и в «мирных» целях,
например, чтобы избежать повторного ввода данных при каждом посещении сайта.

# Сторонние cookie

Как правило, атрибут домена cookie совпадает с доменом, отображаемым в адресной строке
браузера, однако сторонний cookie принадлежит не тому домену, который указан в адресной строке.
Такой тип файлов, как cookie обычно появляется, когда веб-страницы содержат контент с других
сайтов, например, рекламные баннеры. Это позволяет отслеживать историю посещений
пользователя, что часто используют рекламодатели для предоставления релевантной рекламы.

# Зомби-cookie

Поскольку cookie можно легко удалить, программисты ищут способы идентифицировать
пользователей даже после полной очистки истории браузера. Одно из таких решений —
зомби-cookie — evercookie, или persistent cookie — не удаляемые или трудноудаляемые cookie,
которые восстанавливаются в браузере через JavaScript.

Это возможно потому, что для хранения cookie сайт одновременно использует все доступные
хранилища браузера — HTTP ETag, Session Storage, Local Storage, IndexedDB. В этот список также
входят хранилища приложений, таких как:

1. Flash Player (Local Shared Objects);
2. Microsoft Silverlight (Isolated Storage);
3. Java (Java persistence API).

Когда программа обнаруживает отсутствие в браузере cookie-файла, информация о котором есть в
других хранилищах, она тут же восстанавливает его на место, идентифицируя пользователя для
сайта.

# Управление cookie

Работа с Cookie в DevTools позволяет добавлять, изменять и удалять cookie для каждого сайта

# Подмена cookie

Авторизуемся под логином user, паролем Password! на сайте <http://testingcourse.ru/docs/start> в
браузере Google Chrome. Скопируем полученные cookie и подставим их для авторизации на этом же
сайте только в другом браузере (те без фактической авторизации). Кстати, подобный метод
используют и злоумышленники: они похищают cookie через уязвимости на сайте или незащищённое
интернет-соединение

# Edit This Cookie

расширение для
браузеров Chrome, Yandex и Opera, которое позволяет изменять данные в файлах Cookie

После установки расширения Edit This Cookie в интерфейсе браузера появится значок в виде
«печеньки», нажав на который появится доступ к функциям и настройкам. Чтобы посмотреть
куки-файлы, надо зайти на сайт, и при нажатии на значок «изменить этот файл Cookie» появится
окно, где отобразятся все активные файлы cookie

# Сессии

HTTP — stateless-протокол, то есть он не хранит информацию о предыдущем состоянии клиента или
сервера, об их актуальном статусе. Каждый HTTP-запрос обрабатывается как новый запрос,
соответственно, имеющимися средствами HTTP невозможно понять, идут ли запросы от одного
пользователя или разных, нельзя сохранить какие-либо данные между запросами. Поэтому для
длительного взаимодействия появился механизм сессий. Когда мы открываем сайт и отправляем
первый GET HTTP-запрос, сервер его обрабатывает и вместе с ответом передаёт конкретный
параметр — идентификатор сессии, который хранится на клиенте и в дальнейшем передаётся с
каждым запросом. Таким образом, сервер понимает, что запрос относится к той или иной сессии, и
не требует повторной авторизации.

# Существует два вида сессий

Local Storage и Session Storage

# данные Session Storage

очищаются по завершении сеанса.

# Local Storage

срок действия данных
не истекает

# Security

На вкладке можно ознакомиться с протоколом безопасности при его наличии и просмотреть данные
о сертификате безопасности, если он есть.

Инструмент используется для отладки проблем смешанного контента, проблем сертификатов и так
далее.

# Ключевые возможности Security

1. Окно Security Overview быстро подскажет, безопасна текущая страница или нет.
2. Есть возможность ознакомиться с отдельными источниками, чтобы:
    - просмотреть соединение и детали сертификата (для безопасных источников);
    - или узнать, какие запросы не защищаются (для небезопасных источников).

# Lighthouse

После выбора настроек и нажатия кнопки Generate report панель аудита анализирует, как
загружается страница, и затем предоставляет предложения по оптимизации для уменьшения
времени загрузки страницы и увеличения её отзывчивости.

# какие параметры анализируются в Lighthouse

кеширование ресурсов, gzip-сжатие, наличие неиспользуемых
частей JS-кода и CSS-правил и многое другое.

# Сниффинг

 процесс мониторинга и перехвата всех пакетов, проходящих через сеть, с
помощью инструментов сниффинга (Charles Proxy).

# Как осуществляется проксирование трафика

Сниффер трафика — программа, которая устанавливается и запускается на компьютере в той
же локальной подсети, что и веб-, мобильное приложение или иное тестируемое приложение.
Снифферы трафика работают по принципу man in the middle. Имеется промежуточный сервер
(в данном случае наш ПК), через который проходят запросы и ответы.

# проксирования HTTP-трафика

практически в любом инструменте
необходимо настроить Wi-Fi соединение. В настройках прокси или Wi-Fi мобильного
устройства в качестве прокси-сервера указывается IP-адрес компьютера и порт инструмента.

# проксирования HTTPS-трафика

нужно установить SSL-сертификат сниффера на устройство и
разрешить девайсу доверять сертификату, чтобы трафик расшифровывался.

# Инструменты прокси-трафика

Fiddler Classic

Fiddler Everywhere

Charles Proxy

Mitmproxy

Proxyman

# Charles Proxy

кроссплатформенное приложение прокси-сервера для отладки HTTP,
написанное на Java. Он позволяет пользователю просматривать HTTP, HTTPS и
активированный трафик TCP-порта, доступ к которому осуществляется с локального
компьютера, на него или через него. Сюда входят запросы и ответы, включая HTTP-заголовки
и метаданные (например, файлы cookie, кеширование и кодирование информации), с
функциями, предназначенными для помощи разработчикам и тестировщикам в анализе
соединений и обмене сообщениями

# Настройка Charles

Для работы с HTTPS-трафиком надо установить сертификаты прокси-сервера Charles в
браузер. В зависимости от браузера этот сценарий отличается.

# Возможности Charles Proxy

1. Подмена данных
2. Recording Settings
3. Focus
4. Repeat
5. Repeat Advanced

# Подмена данных Charles Proxy

три способа подмены данных:

- breakpoint
- rewrite
- map local

# Breakpoint

некая точка остановки запроса. Когда обнаруживается запрос из заданного
списка, для дальнейшего ручного взаимодействия с параметрами запроса открывается
отдельное окно. В нём перейдите к ручному изменению запросов и ответов. Удобно
использовать эту функцию, когда тестируете API или разные ответы сервера.

# Rewrite

 инструмент, позволяющий создавать правила, которые изменяют запросы и
ответы, когда те проходят через Charles Proxy. Например, можно добавлять и изменять
заголовок, искать и заменять текст в теле ответа или запроса и т. д.

# Map Local

инструмент, который позволяет использовать локальные файлы, словно они
являются частью сервера.

# Throttle Settings

функция, позволяющая задавать разные параметры скорости соединения с
выбранным доменом.

Если выбрать Only for selected hosts, то можно задать определённый хост, к которому будут
применяться ваши настройки. Здесь можно использовать готовые пресеты с настройками для
различных типов (4G, 3G и т. д.).Также можно задать разные параметры. Коротко перечислю
некоторые из них:

- Bandwidth — максимальный объём данных, который может быть передан с течением
времени.
- Utilisation — доля общей пропускной способности, которая может быть предоставлена
пользователю в любое время.
- Latency — задержка в миллисекундах по запросу firts между клиентом и удалённым
сервером.
- MTU — максимальное передающее устройство для текущего пресета.
- Reliability — мера вероятности, что соединение не удастся. Используется для имитации
ненадёжных сетевых условий.
- Stability — мера вероятности, что соединение будет нестабильным и, следовательно,
снизится качество. Полезно для моделирования сетей, в которых периодических
падает качество связи, например, мобильных.

# Reverse Proxies

обратный прокси-сервер. Обычно используется для того, чтобы принимать
запросы из интернета и перенаправлять их на один из веб-серверов.

# Port Forwarding

проброс портов, который иногда называют перенаправлением портов, или
туннелированием — процесс пересылки трафика, адресованного конкретному сетевому порту,
с одного сетевого узла на другой. Этот метод позволяет внешнему пользователю достичь
порта внутри локальной сети

# MacOS Proxy/Windows Proxy

MacOS Proxy или Windows Proxy (в зависимости от вашей ОС) — проксирование трафика с
вашего веб-браузера.

# No Caching

Инструмент No Caching предотвращает кеширование, манипулируя заголовками HTTP,
которые управляют кешированием ответов. Заголовки If-Modified-Since и If-None-Match
удаляются из запросов, добавляются Pragma: no-cache и Cache-control: no-cache. Заголовки
Expires, Last-Modified и ETag удаляются из ответов и добавляются Expires: 0 и Cache-Control:
no-cache.

# Block Cookies

заголовок файла Cookie удаляется из запросов, предотвращая отправку
значений файла из клиентского приложения, например, веб-браузера, на удалённый сервер. А
также из ответов удаляется заголовок Set-Cookie, предотвращая получение клиентским
приложением запросов на установку файлов cookie с удалённого сервера. В настройках
можно включить удаление Cookie как для всех хостов, так и для выбранных. В примере ниже
включено удаление Cookie для всех запросов.

# Map Remote

позволяет переадресовать запросы с одного URL Map From на другой Map To.
Подменяет хост, путь целиком или только параметры — в зависимости от вашей задачи. В
примере ниже подменён запрос с prod-сервера на dev-сервер

# Block List

 позволяет блокировать определённые доменные имена. Когда веб-браузер
попытается запросить любую страницу из заблокированного доменного имени, она
заблокируется. Можно выбрать либо Drop connection, либо возврат ошибки 403.

# DNS Spoofing

Виртуальный хостинг — это когда у вас есть несколько сайтов на одном IP-адресе, и
веб-сервер определяет, какой сайт вы запрашиваете, основываясь на имени, введённом в
браузере. Точнее, сервер смотрит на заголовок хоста, отправленный в запросе. Например,
когда нужно подменить хосты, чтобы при вводе какого-либо адреса в браузере (скажем,
api.youla.ru) запросы уходили по другому адресу (допустим, на тестовую площадку). DNS
Spoofing — перенаправляет доменное имя на определённый IP-адрес.

# Mirror

эта функция позволяет автоматически сохранять все ответы, возвращаемые в Charles
Proxy. Они раскладываются локально в такой же иерархии, как на сервере. Если внезапно
случился даунтайм на бэкенде, отвалилась тестовая среда и т. д., у вас уже есть готовые моки
для Map Local. Активировать функцию можно так: Tools → Mirror или Tools → Auto Save.

# Compose

функция редактирования запросов, которые вы поймали.

# Recording Settings

настройки отображения списков разрешённых и запрещённых доменов

Во вкладке Options можно настроить лимит, то есть количество запросов, которое Charles
Proxy должен записать.

Во вкладке Include можно выбрать конкретный домен для отображения пакетов.

Во вкладке Exclude можем выбрать те домены, которые необходимо спрятать при сниффинге.

# Focus

функция, которая перемещает домен на первые позиции в списке.

# Repeat

 отправляет на сервер запрос, идентичный выбранному.

# Repeat Advanced

идентично Repeat, только можно выбрать количество отправляемых
запросов и задержку между ними. Эта функция пригодится при проверке реакции сервера на
флуд.

# Concurrency в Repeat Advanced

— количество пользователей

# Iterations в Repeat Advanced

количество повторений каждого
запроса

# Описание форм в HTML

Формы — одна из важнейших частей любого веб-приложения. Регистрация, вход, поиск,
отправка обратной связи, создание разных заявок, покупки в интернет-магазинах — не
обходятся без соответствующих форм.

# Параметр action в формах

указывает на скрипт, который будет обрабатывать эту форму,

# Параметр method — post или get в формах

каким HTTP-методом данные станут передаваться на сервер. Подавляющее
большинство форм отправляет данные в теле запроса методом POST.

# HTML5 имеет встроенную поддержку разных типов полей

email, tel, url,
number, time, date, datetime, datetime-local, month, week, range, search, color. Есть также

# тип поля — password

 символы пароля должны маскироваться звёздочками.

# поле обязательно для заполнения

атрибут required="required", который означает, что поле обязательно для заполнения. Можно
указать атрибут required без значения: это не ошибка, а рекомендуемый способ
использования данного атрибута.

# отправка формы

Специальная кнопка с типом submit

# элементы не видимые пользователю

 элементы с типом type="hidden".

# Тестирование форм

тестировать с позиции чёрного ящика

В версии HTML4 валидация форм осуществлялась через JavaScript на клиентской стороне и
посредством различных языков программирования — на серверной. С появлением HTML5

предыдущие методы валидации не исчезли, но в последней версии появились новые
атрибуты, и, таким образом, добавилась валидация форм средствами браузера.

# Основные атрибуты

1. Required, без которого форма не отправится.
2. Атрибуты min и max, указывающие, соответственно, минимум и максимум для
числового поля ввода.
3. Minlength, Maxlength — ограничение на длину ввода.
4. Pattern=”\\+[0-9]{11}” — регулярное выражение, которому соответствует вводимый
текст.

# Регистрация

Если форма заполнена верно, пользователь успешно пройдёт регистрацию. По каким данным
он должен фильтроваться, зависит от требований, и это надо уточнить заранее:

1. По логину.
2. Телефону.
3. Электронной почте.
4. По комбинации этих полей.

Как правило, телефон и электронная почта уникальны, а если есть логин, то он тоже уникален.

# Валидация полей ввода

Сначала надо обратить внимание на обязательность к заполнению. Если эти поля есть, должен
ли человек указывать фамилию, имя и отчество? И может ли он их не заполнять? А если
указано только имя, то надо ли вводить и фамилию, и отчество? Здесь может быть
довольно-таки сложная логика, поэтому потребуется составить список потенциальных
проверок. Вот возможный вариант такого списка при условии, что Ф. И. О. помечены как
необязательные. Требования: поля необязательные, но если заполнена фамилия, то
обязательно указывается и имя.

# Авторизация

1. Пользователь с указанными логином и паролем существует в системе.
2. Пользователь с указанным логином не существует в системе.
3. Пользователь с указанным логином существует в системе, но пароль неверен.
4. Пользователь с указанным логином и паролем существует в системе, но имеет
неактивный статус.
    - Логин не активирован.
    - Логин заблокирован.
5. Валидация полей ввода.

# Поиск

1. По наличию искомого.
    - Результаты существуют.

        - Найдено всё соответствующее.
        - Поисковому запросу не соответствует ничего не актуального.
    - Результаты не существуют.
        - В поиск не попало ничего не актуального.
        - Выдано корректное сообщение о пустом результате.

2. По типу поиска.
    - По точному совпадению.
    - Умный поиск, по неточному совпадению.
    - С использованием логических операторов, если они поддерживаются.

# Язык запросов

двойные кавычки

плюс

site:

# двойные кавычки

Если вы заключите слова запроса в кавычки, то мы будем искать
документы, которые содержат именно такой порядок слов без каких-либо изменений

# Оператор плюс

предлагает найти все тексты, содержащие искомое слово в любой форме

# оператор «site:»

Если вы уверены, что интересующая вас информация находится на определённом сайте,
используйте оператор «site:».

# Если поисковая система не находит ничего, удовлетворяющего вашему запросу

она начинает
игнорировать действие операторов

# Suggests (подсказки)

Поисковые подсказки («саджесты») — это продолжения запроса, который вы начинаете
вводить. Они помогают уточнить и быстро выбрать подходящий вариант запроса, не набирая
его целиком.

Саджест обновляется по мере ввода букв или слов. Подходящий запрос можно выбрать как
мышкой, кликнув на него, так и передвигаясь при помощи клавиш «вверх/вниз».

# Фильтры поиска

1. По результату.
    - Фильтр возвращает непустой результат.
        - В фильтр попали все подходящие данные.
        - В фильтр не попали несоответствующие данные.
    - Фильтр возвращает пустой результат.
        - В фильтр не попали несоответствующие данные.
        - Валидное сообщение об ошибке.
2. По фильтрам.
    - Применён один фильтр.
    - Применена группа фильтров.
        - Результат должен соответствовать каждому фильтру.

# Обратная связь

Эти формы часто содержат лишь несколько текстовых полей «Тема» и «Сообщение», если
пользователь зарегистрирован, и «Имя» и «Электронная почта» или «Телефон», когда
регистрации на сайте нет. Их тестирование в этом случае мало отличается от тестирования,
скажем, полей ввода в формах регистрации.

# Обход клиентской валидации

Отключение фильтрации методом редактирования HTML

Отправка GET/POST-запроса через Postman

# Валидация данных в форме на клиенте

это, безусловно, хорошо: пользователь получает
мгновенную обратную связь без необходимости отправлять данные на сервер. Но этого
способа недостаточно, и все полученные данные обязательно надо проверять на сервере. Без
проверки полученных от клиента данных приложение уязвимо для взлома и сбоев в работе.
Поэтому тестирование форм в обход валидации в браузере — это один из базовых способов
тестирования безопасности.

# Отключение фильтрации методом редактирования HTML

открыть HTML-код,  двойной клик на атрибуте required Удаляем всё, что там есть, и нажимаем Enter. поля стали необязательными - отправляем форму и если сервер вернул ошибку, Значит, на сервере проводится валидация данных, а мы, по сути, получили то,
что ожидали. Тест успешно пройден.

# Отправка GET/POST-запроса через Postman

1. Ищем в поисковике «как отправить данные формы через postman» / how to send form
data from postman — читаем документацию.
2. Определяем, какие поля надо отправлять.
3. Не забываем про CSRF-токены.

# описание способов, которыми одна компьютерная программа может взаимодействовать с другой

API

# проверка отображения и работы веб-приложения в разнвх браузерах

кроссбраузерное тестирование
